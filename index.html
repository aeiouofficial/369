<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="author" content="Nicolai Becker">
    <meta name="description" content="Die 613-THz-Signatur: Der Code des Widerstands - Systemarchitektur der RealitÃ¤t">
    <title>Die 613-THz-Signatur | 3-6-9 Systemarchitektur</title>
    
    <!-- PWA Manifest -->
    <link rel="manifest" href="manifest.json">
    <meta name="theme-color" content="#00ff88">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="613 Portal">
    
    <!-- THREE.JS -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    
    <style>
        :root {
            --science: #00f3ff;
            --gnosis: #ffaa00;
            --magic: #9d00ff;
            --dark: #030304;
            --glass: rgba(8, 8, 12, 0.85);
            --border: rgba(0, 243, 255, 0.15);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            font-family: 'Courier New', monospace;
            background: var(--dark);
            color: #fff;
            overflow-x: hidden;
            user-select: none;
        }

        /* Matrix Background */
        #matrix-bg {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 0;
            opacity: 0.15;
        }

        /* Music Player - Top Bar */
        #music-player {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            z-index: 10000;
            background: rgba(3, 3, 5, 0.98);
            border-bottom: 1px solid var(--science);
            backdrop-filter: blur(20px);
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 15px;
            padding: 8px 20px;
            height: 45px;
        }

        @media (max-width: 768px) {
            #music-player {
                gap: 8px;
                padding: 6px 10px;
                height: 40px;
                font-size: 0.8rem;
            }
        }

        .player-btn {
            background: rgba(0, 243, 255, 0.1);
            border: 1px solid var(--science);
            padding: 4px 10px;
            cursor: pointer;
            color: var(--science);
            font-family: 'Courier New', monospace;
            font-size: 0.75rem;
            transition: all 0.3s;
        }

        .player-btn:hover {
            background: rgba(0, 243, 255, 0.2);
            box-shadow: 0 0 10px var(--science);
        }

        .player-btn:disabled {
            opacity: 0.4;
            cursor: not-allowed;
            box-shadow: none;
        }

        .player-timeline {
            flex: 1;
            max-width: 400px;
            height: 4px;
            background: rgba(0, 243, 255, 0.2);
            cursor: pointer;
            position: relative;
        }

        .player-progress {
            height: 100%;
            background: var(--science);
            width: 0%;
            transition: width 0.1s linear;
        }

        .player-time {
            font-size: 0.65rem;
            color: var(--science);
            font-family: 'Courier New', monospace;
        }

        .player-track-title {
            font-size: 0.7rem;
            color: var(--science);
            font-family: 'Courier New', monospace;
            font-weight: bold;
        }

        .player-volume {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .volume-slider {
            width: 90px;
        }

        .volume-slider input[type="range"] {
            width: 100%;
        }

        /* Hero Section */
        .hero {
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            padding: 80px 20px 40px;
            z-index: 1;
        }

        h1 {
            font-size: clamp(3rem, 10vw, 8rem);
            background: linear-gradient(135deg, var(--science) 0%, #fff 50%, var(--gnosis) 100%);
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: 0 0 40px rgba(0, 243, 255, 0.6);
            filter: drop-shadow(0 10px 20px rgba(0, 243, 255, 0.4));
            animation: title-float 4s ease-in-out infinite;
            letter-spacing: 0.1em;
            margin-bottom: 1rem;
        }

        @keyframes title-float {
            0%, 100% { transform: translateY(0px); }
            50% { transform: translateY(-10px); }
        }

        /* --- ANIMATED MUSIC NOTES & FRACTALS BACKGROUND --- */
        .music-notes {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 2;
            pointer-events: none;
            overflow: hidden;
        }
        
        /* Musical Notes */
        .note {
            position: absolute;
            font-size: 2rem;
            animation: float-up linear infinite;
            opacity: 0;
            filter: drop-shadow(0 0 8px currentColor);
            will-change: transform, opacity;
        }
        
        @keyframes float-up {
            0% { transform: translateY(100vh) rotate(0deg) scale(0.8); opacity: 0; }
            10% { opacity: 0.7; transform: translateY(90vh) rotate(36deg) scale(1); }
            50% { opacity: 0.5; }
            90% { opacity: 0.3; }
            100% { transform: translateY(-10vh) rotate(360deg) scale(0.6); opacity: 0; }
        }
        
        /* Frequency-specific colors and rhythms */
        .note.hz-60 { color: #ff3366; } /* Matrix 60Hz - Red */
        .note.hz-432 { color: #ffaa00; } /* Sacred 432Hz - Gold */
        .note.hz-528 { color: #00ff88; } /* Healing 528Hz - Green */
        .note.hz-963 { color: #8888ff; } /* Pineal 963Hz - Indigo */
        .note.hz-174 { color: #ff6600; } /* Foundation 174Hz - Orange */
        
        /* Fractal Symbols */
        .fractal {
            position: absolute;
            font-size: 3rem;
            animation: fractal-spin linear infinite;
            opacity: 0;
            color: var(--science);
            filter: drop-shadow(0 0 12px currentColor);
            will-change: transform, opacity;
        }
        
        @keyframes fractal-spin {
            0% { transform: translate(0, 100vh) rotate(0deg) scale(0.5); opacity: 0; }
            5% { opacity: 0.6; }
            50% { transform: translate(var(--drift-x), 50vh) rotate(180deg) scale(1.2); opacity: 0.4; }
            95% { opacity: 0.3; }
            100% { transform: translate(calc(var(--drift-x) * 2), -10vh) rotate(360deg) scale(0.4); opacity: 0; }
        }
        
        /* Positioning variations for notes */
        .note:nth-child(1) { left: 8%; animation-duration: 14s; animation-delay: 0s; font-size: 1.4rem; }
        .note:nth-child(2) { left: 18%; animation-duration: 16s; animation-delay: 1.5s; font-size: 2rem; }
        .note:nth-child(3) { left: 28%; animation-duration: 13s; animation-delay: 3s; font-size: 1.7rem; }
        .note:nth-child(4) { left: 38%; animation-duration: 18s; animation-delay: 0.8s; font-size: 2.2rem; }
        .note:nth-child(5) { left: 48%; animation-duration: 15s; animation-delay: 2.5s; font-size: 1.5rem; }
        .note:nth-child(6) { left: 58%; animation-duration: 17s; animation-delay: 4s; font-size: 1.9rem; }
        .note:nth-child(7) { left: 68%; animation-duration: 14s; animation-delay: 5.5s; font-size: 2.1rem; }
        .note:nth-child(8) { left: 78%; animation-duration: 19s; animation-delay: 1s; font-size: 1.6rem; }
        .note:nth-child(9) { left: 88%; animation-duration: 13s; animation-delay: 6s; font-size: 2.3rem; }
        .note:nth-child(10) { left: 12%; animation-duration: 16s; animation-delay: 7s; font-size: 1.8rem; }
        .note:nth-child(11) { left: 32%; animation-duration: 15s; animation-delay: 3.5s; font-size: 2rem; }
        .note:nth-child(12) { left: 52%; animation-duration: 17s; animation-delay: 2s; font-size: 1.7rem; }
        .note:nth-child(13) { left: 72%; animation-duration: 14s; animation-delay: 4.5s; font-size: 1.9rem; }
        .note:nth-child(14) { left: 92%; animation-duration: 18s; animation-delay: 0.5s; font-size: 2.2rem; }
        
        /* Positioning variations for fractals */
        .fractal:nth-child(15) { left: 15%; --drift-x: 50px; animation-duration: 22s; animation-delay: 1s; }
        .fractal:nth-child(16) { left: 45%; --drift-x: -40px; animation-duration: 25s; animation-delay: 3s; }
        .fractal:nth-child(17) { left: 75%; --drift-x: 60px; animation-duration: 20s; animation-delay: 5s; }
        .fractal:nth-child(18) { left: 25%; --drift-x: -30px; animation-duration: 23s; animation-delay: 2s; }
        .fractal:nth-child(19) { left: 55%; --drift-x: 45px; animation-duration: 24s; animation-delay: 4s; }
        .fractal:nth-child(20) { left: 85%; --drift-x: -50px; animation-duration: 21s; animation-delay: 6s; }
        .fractal:nth-child(21) { left: 35%; --drift-x: 35px; animation-duration: 26s; animation-delay: 7s; }
        .fractal:nth-child(22) { left: 65%; --drift-x: -45px; animation-duration: 19s; animation-delay: 1.5s; }
        
        /* Mobile Performance Optimization - hide heavy animations */
        @media (max-width: 768px) {
            .note, .fractal { display: none !important; }
        }

        .subtitle {
            color: var(--gnosis);
            font-size: clamp(0.9rem, 2vw, 1.2rem);
            letter-spacing: 0.3em;
            text-transform: uppercase;
            margin-bottom: 3rem;
            border-bottom: 2px solid var(--gnosis);
            display: inline-block;
            padding-bottom: 8px;
        }

        .cta-buttons {
            display: flex;
            gap: 1rem;
            flex-wrap: wrap;
            justify-content: center;
            margin-bottom: 3rem;
        }

        .btn {
            padding: 1rem 2rem;
            font-size: 1rem;
            font-weight: bold;
            text-decoration: none;
            border: 2px solid;
            cursor: pointer;
            transition: all 0.3s;
            font-family: 'Courier New', monospace;
            text-transform: uppercase;
            letter-spacing: 2px;
            background: var(--glass);
            backdrop-filter: blur(10px);
        }

        .btn-primary {
            color: var(--science);
            border-color: var(--science);
        }

        .btn-primary:hover {
            background: var(--science);
            color: #000;
            box-shadow: 0 0 20px var(--science);
        }

        .btn-secondary {
            color: var(--magic);
            border-color: var(--magic);
        }

        .btn-secondary:hover {
            background: var(--magic);
            color: #000;
            box-shadow: 0 0 20px var(--magic);
        }

        /* Dashboard */
        #dashboard {
            position: relative;
            padding: 80px 20px 40px;
            z-index: 1;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        .section-title {
            text-align: center;
            font-size: clamp(2rem, 5vw, 3rem);
            color: var(--science);
            margin-bottom: 3rem;
            text-shadow: 0 0 20px var(--science);
        }

        /* Chapter Grid */
        .chapters-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
            gap: 20px;
            margin-bottom: 3rem;
        }

        @media (max-width: 768px) {
            .chapters-grid {
                grid-template-columns: 1fr;
                gap: 15px;
            }
        }

        .chapter-card {
            background: linear-gradient(135deg, rgba(0, 243, 255, 0.05), transparent);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 20px;
            cursor: pointer;
            transition: all 0.3s;
            position: relative;
            overflow: hidden;
        }
        .chapter-card.locked {
            opacity: 0.4;
            filter: grayscale(0.6);
            cursor: not-allowed;
            position: relative;
        }
        .chapter-card.locked::before {
            content: 'ðŸ”’';
            position: absolute;
            top: 10px;
            right: 10px;
            font-size: 1.2rem;
            z-index: 2;
        }
        .chapter-card.completed {
            border-color: rgba(255, 170, 0, 0.6);
            box-shadow: 0 0 25px rgba(255, 170, 0, 0.2);
            position: relative;
        }
        .chapter-card.completed::before {
            content: 'âœ“';
            position: absolute;
            top: 10px;
            right: 10px;
            font-size: 1.2rem;
            color: var(--gnosis);
            z-index: 2;
        }

        .chapter-card::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 3px;
            background: linear-gradient(90deg, var(--science), var(--gnosis));
            transform: scaleX(0);
            transition: 0.4s;
        }

        .chapter-card:hover {
            border-color: var(--science);
            transform: translateY(-8px);
            box-shadow: 0 0 30px rgba(0, 243, 255, 0.3);
        }

        .chapter-card:hover::after {
            transform: scaleX(1);
        }
        .chapter-card.locked:hover {
            border-color: var(--border);
            transform: none;
            box-shadow: none;
        }

        .chapter-id {
            color: #666;
            font-size: 0.7rem;
            margin-bottom: 8px;
        }

        .chapter-title {
            font-size: 1.1rem;
            font-weight: 700;
            color: var(--science);
            margin-bottom: 8px;
        }

        .chapter-desc {
            font-size: 0.85rem;
            color: #999;
            line-height: 1.5;
        }

        #profile-panel {
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 30px;
            background: rgba(0, 0, 0, 0.4);
        }
        .profile-title {
            font-size: 1rem;
            color: var(--science);
            margin-bottom: 10px;
            letter-spacing: 1px;
        }
        .profile-row {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            align-items: center;
        }
        .profile-row input {
            flex: 1;
            min-width: 160px;
            padding: 10px 12px;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid var(--border);
            color: #fff;
            font-family: 'Courier New', monospace;
        }
        .profile-row button {
            padding: 10px 16px;
            border: 1px solid var(--science);
            background: transparent;
            color: var(--science);
            cursor: pointer;
            font-family: 'Courier New', monospace;
            transition: background 0.2s;
        }
        .profile-row button:hover {
            background: rgba(0, 243, 255, 0.15);
        }
        .profile-btn-ghost {
            border-color: #ff3366 !important;
            color: #ff3366 !important;
        }
        .profile-btn-ghost:hover {
            background: rgba(255, 51, 102, 0.15);
        }
        .profile-hint {
            font-size: 0.75rem;
            color: #777;
            margin-top: 8px;
        }

        /* 3D Scene Container */
        #scene-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 5000;
            background: #000;
            display: none;
        }

        #scene-container.active {
            display: block;
        }

        #canvas-3d {
            width: 100%;
            height: 100%;
        }

        /* Scene UI Overlay */
        #scene-ui {
            position: absolute;
            top: 60px;
            left: 0;
            right: 0;
            bottom: 0;
            pointer-events: none;
            z-index: 10;
        }

        .scene-top-bar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 20px;
            pointer-events: auto;
        }

        .scene-info {
            text-align: center;
            flex: 1;
        }

        .scene-name {
            font-size: 1.5rem;
            color: var(--science);
            text-shadow: 0 0 10px var(--science);
        }

        .nav-btn {
            padding: 10px 20px;
            background: var(--glass);
            border: 1px solid var(--science);
            color: var(--science);
            cursor: pointer;
            transition: all 0.3s;
            pointer-events: auto;
            font-family: 'Courier New', monospace;
        }

        .nav-btn:hover {
            background: rgba(0, 243, 255, 0.2);
            box-shadow: 0 0 10px var(--science);
        }

        /* Learning Game Panel - Bottom of Scene */
        #game-overlay {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: linear-gradient(to top, rgba(0,0,0,0.95) 0%, rgba(0,0,0,0.85) 100%);
            border-top: 2px solid var(--science);
            padding: 15px 20px;
            padding-top: 25px;
            pointer-events: auto;
            display: none;
            min-height: 80px;
            max-height: 70vh;
            overflow-y: auto;
            transition: height 0.3s ease, transform 0.3s ease;
            z-index: 50;
        }

        #game-overlay.active {
            display: block;
            animation: slideUp 0.3s ease-out;
        }

        #game-overlay.minimized {
            height: 50px !important;
            min-height: 50px;
            overflow: hidden;
        }
        #game-overlay.minimized .game-body {
            display: none;
        }
        #game-overlay.minimized .game-minimize-btn {
            transform: rotate(180deg);
        }

        #game-overlay.dragging {
            transition: none;
            cursor: grabbing;
        }

        @keyframes slideUp {
            from { transform: translateY(100%); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }

        .game-resize-handle {
            position: absolute;
            top: 0;
            left: 50%;
            transform: translateX(-50%);
            width: 60px;
            height: 20px;
            cursor: ns-resize;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #555;
            font-size: 0.8rem;
            letter-spacing: 2px;
            user-select: none;
        }
        .game-resize-handle:hover {
            color: var(--science);
        }

        .game-drag-handle {
            cursor: grab;
            padding: 5px 8px;
            color: #666;
            font-size: 1rem;
            user-select: none;
            border-radius: 4px;
        }
        .game-drag-handle:hover {
            color: var(--science);
            background: rgba(0,243,255,0.1);
        }
        .game-drag-handle:active {
            cursor: grabbing;
        }

        .game-header {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 10px;
            padding-bottom: 10px;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }

        .game-body {
            transition: opacity 0.2s ease;
        }

        .game-strikes {
            display: flex;
            gap: 4px;
            font-size: 1.2rem;
        }
        .game-strikes .strike-label {
            letter-spacing: 2px;
        }
        .game-strikes.warning .strike-label {
            animation: pulse-warning 0.5s ease-in-out;
        }
        @keyframes pulse-warning {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.3); }
        }

        .game-sound-btn, .game-minimize-btn {
            width: 28px;
            height: 28px;
            border-radius: 50%;
            background: rgba(0,243,255,0.1);
            border: 1px solid var(--science);
            color: var(--science);
            cursor: pointer;
            font-size: 0.8rem;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }
        .game-sound-btn:hover, .game-minimize-btn:hover {
            background: rgba(0,243,255,0.2);
        }
        .game-sound-btn.muted {
            color: #666;
            border-color: #666;
        }

        .game-help-btn {
            width: 28px;
            height: 28px;
            border-radius: 50%;
            background: rgba(255,170,0,0.2);
            border: 1px solid var(--gnosis);
            color: var(--gnosis);
            cursor: pointer;
            font-weight: bold;
            font-size: 0.9rem;
            margin-left: auto;
        }
        .game-help-btn:hover {
            background: rgba(255,170,0,0.4);
        }

        .game-tooltip {
            background: rgba(255,170,0,0.15);
            border-left: 3px solid var(--gnosis);
            padding: 8px 12px;
            margin-bottom: 12px;
            font-size: 0.8rem;
            color: var(--gnosis);
            display: none;
        }
        .game-tooltip.show {
            display: block;
            animation: fadeIn 0.3s ease;
        }
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .game-question {
            color: var(--gnosis);
            font-size: 1rem;
            margin-bottom: 12px;
            line-height: 1.4;
        }
        .game-progress {
            font-size: 0.75rem;
            color: #bbb;
            letter-spacing: 1px;
        }

        .game-options {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .game-option {
            padding: 10px 15px;
            background: rgba(0, 243, 255, 0.1);
            border: 1px solid var(--science);
            color: #fff;
            cursor: pointer;
            transition: all 0.3s;
            text-align: left;
        }

        .game-option:hover {
            background: rgba(0, 243, 255, 0.2);
            transform: translateX(5px);
        }

        .game-option.correct {
            background: rgba(0, 255, 136, 0.3);
            border-color: #00ff88;
        }

        .game-option.incorrect {
            background: rgba(255, 0, 0, 0.3);
            border-color: #ff0000;
        }

        .game-feedback {
            margin-top: 12px;
            padding: 10px;
            border-radius: 4px;
            display: none;
            font-size: 0.9rem;
        }

        .game-feedback.show {
            display: block;
        }

        .game-feedback.correct {
            background: rgba(0, 255, 136, 0.2);
            border: 1px solid #00ff88;
            color: #00ff88;
        }

        .game-feedback.incorrect {
            background: rgba(255, 0, 0, 0.2);
            border: 1px solid #ff0000;
            color: #ff6666;
        }
        .game-feedback .source-link {
            display: inline-block;
            margin-top: 8px;
            font-size: 0.85rem;
        }
        .game-feedback .source-link a {
            color: var(--science);
            text-decoration: underline;
        }
        .game-feedback .retry-hint {
            display: block;
            margin-top: 8px;
            color: var(--gnosis);
            font-weight: bold;
        }

        /* Game Close Button */
        .game-close-btn {
            background: transparent;
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: #888;
            width: 28px;
            height: 28px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 0.9rem;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .game-close-btn:hover {
            border-color: #ff3366;
            color: #ff3366;
            background: rgba(255, 51, 102, 0.1);
        }

        /* Game Buttons Container */
        .game-buttons {
            display: flex;
            gap: 10px;
            margin-top: 12px;
            justify-content: flex-end;
        }
        .game-buttons .nav-btn {
            flex: 0 1 auto;
            padding: 8px 16px;
        }
        .skip-btn {
            border-color: #ff3366;
            color: #ff3366;
        }
        .skip-btn:hover {
            background: rgba(255, 51, 102, 0.2);
        }

        /* Game Help Modal */
        .game-help-modal {
            position: absolute;
            inset: 0;
            background: rgba(0,0,0,0.9);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 100;
        }
        .game-help-modal.active {
            display: flex;
        }
        .game-help-content {
            background: var(--glass);
            border: 2px solid var(--gnosis);
            padding: 25px;
            border-radius: 12px;
            max-width: 450px;
            width: 90%;
        }
        .game-help-content h3 {
            color: var(--gnosis);
            margin-bottom: 15px;
            font-size: 1.2rem;
        }
        .game-help-content ul {
            list-style: none;
            padding: 0;
            margin: 0 0 20px 0;
        }
        .game-help-content li {
            padding: 8px 0;
            border-bottom: 1px solid rgba(255,255,255,0.1);
            font-size: 0.9rem;
            color: #ccc;
        }
        .tooltip-toggle {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 15px;
            cursor: pointer;
            font-size: 0.85rem;
            color: #999;
        }
        .tooltip-toggle input {
            width: 18px;
            height: 18px;
        }

        /* Game Over Screen */
        .game-over-screen {
            text-align: center;
            padding: 30px;
        }
        .game-over-screen h2 {
            color: #ff3366;
            font-size: 2rem;
            margin-bottom: 15px;
        }
        .game-over-screen p {
            color: #ccc;
            margin-bottom: 20px;
        }

        @media (max-width: 480px) {
            .game-buttons {
                flex-direction: column;
            }
            #game-overlay {
                max-height: 55vh;
            }
        }

        /* Navigation Arrows */
        .nav-arrow {
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            width: 60px;
            height: 100px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2rem;
            color: var(--science);
            cursor: pointer;
            transition: all 0.3s;
            background: linear-gradient(to right, rgba(0,0,0,0.6), transparent);
            pointer-events: auto;
        }

        .nav-arrow:hover {
            color: #fff;
            text-shadow: 0 0 20px var(--science);
        }

        .nav-arrow.prev {
            left: 0;
        }

        .nav-arrow.next {
            right: 0;
            background: linear-gradient(to left, rgba(0,0,0,0.6), transparent);
        }

        @media (max-width: 768px) {
            .nav-arrow {
                width: 40px;
                font-size: 1.5rem;
            }
        }

        /* Sidebar Controls */
        #sidebar {
            position: fixed;
            right: 20px;
            top: 80px;
            width: 300px;
            display: flex;
            flex-direction: column;
            gap: 15px;
            pointer-events: auto;
            transition: transform 0.3s ease, opacity 0.3s ease;
            z-index: 20;
        }

        #sidebar.dragging {
            transition: none;
        }

        #sidebar.minimized {
            width: 180px;
        }

        #sidebar.minimized .panel {
            display: none;
        }

        .sidebar-header {
            display: flex;
            gap: 10px;
        }

        .sidebar-toggle,
        .sidebar-handle {
            flex: 1;
            background: var(--glass);
            border: 1px solid var(--science);
            color: var(--science);
            border-radius: 6px;
            font-family: 'Courier New', monospace;
            font-size: 0.75rem;
            padding: 8px 10px;
            cursor: pointer;
            transition: background 0.3s, box-shadow 0.3s;
        }

        .sidebar-toggle:hover,
        .sidebar-handle:hover {
            background: rgba(0, 243, 255, 0.15);
            box-shadow: 0 0 12px rgba(0, 243, 255, 0.3);
        }

        .sidebar-handle {
            max-width: 60px;
            cursor: grab;
        }

        #sidebar.dragging .sidebar-handle {
            cursor: grabbing;
        }

        @media (max-width: 768px) {
            #sidebar {
                width: 90%;
                right: 5%;
                top: 60px;
            }
        }

        .panel {
            background: var(--glass);
            border: 1px solid var(--border);
            border-right: 3px solid var(--science);
            padding: 15px;
            border-radius: 8px;
            backdrop-filter: blur(15px);
        }

        .panel-title {
            color: var(--science);
            font-size: 0.8rem;
            margin-bottom: 10px;
            border-bottom: 1px solid rgba(255,255,255,0.1);
            padding-bottom: 5px;
        }

        .view-btn {
            background: linear-gradient(135deg, rgba(0, 243, 255, 0.08), rgba(255, 170, 0, 0.08));
            border: 1px solid var(--border);
            color: #aaa;
            padding: 10px;
            margin-bottom: 8px;
            cursor: pointer;
            transition: all 0.3s;
            width: 100%;
            font-family: 'Courier New', monospace;
            font-size: 0.85rem;
        }

        .view-btn:hover {
            background: linear-gradient(135deg, rgba(0, 243, 255, 0.15), rgba(255, 170, 0, 0.15));
            border-color: var(--science);
            color: #fff;
            transform: translateX(-4px);
        }

        .view-btn.active {
            background: linear-gradient(135deg, var(--science), var(--gnosis));
            color: #000;
            font-weight: bold;
        }

        .vertical-controls {
            display: flex;
            gap: 8px;
            margin-top: 12px;
        }

        .view-btn.small {
            flex: 1;
            padding: 8px;
            font-size: 0.75rem;
        }

        /* Footer */
        footer {
            position: relative;
            z-index: 1;
            text-align: center;
            padding: 3rem 1rem;
            border-top: 1px solid var(--science);
            margin-top: 5rem;
        }

        .footer-links {
            margin-top: 1rem;
        }

        .footer-links a {
            color: var(--science);
            text-decoration: none;
            margin: 0 10px;
            transition: all 0.3s;
        }

        .footer-links a:hover {
            color: #fff;
            text-shadow: 0 0 10px var(--science);
        }

        /* Scroll Indicator */
        .scroll-indicator {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            animation: bounce 2s infinite;
        }

        .scroll-indicator button {
            background: none;
            border: none;
            cursor: pointer;
            padding: 12px;
        }

        .scroll-indicator button:focus-visible {
            outline: 2px solid var(--science);
            outline-offset: 4px;
        }

        @keyframes bounce {
            0%, 20%, 50%, 80%, 100% { transform: translateX(-50%) translateY(0); }
            40% { transform: translateX(-50%) translateY(-20px); }
            60% { transform: translateX(-50%) translateY(-10px); }
        }

        .arrow-down {
            width: 30px;
            height: 30px;
            border-right: 3px solid var(--science);
            border-bottom: 3px solid var(--science);
            transform: rotate(45deg);
        }

        /* MODALS */
        .modal-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.9); backdrop-filter: blur(15px);
            z-index: 5000; opacity: 0; pointer-events: none; transition: 0.4s;
            display: flex; justify-content: center; align-items: center;
        }
        .modal-overlay.active { opacity: 1; pointer-events: auto; }

        .modal {
            width: 800px; max-width: 90%; max-height: 85vh;
            background: var(--glass); border: 2px solid var(--border); border-radius: 12px;
            display: flex; flex-direction: column; 
            box-shadow: 0 20px 60px rgba(0, 243, 255, 0.3);
            backdrop-filter: blur(20px);
            transform: scale(0.95); transition: 0.4s;
        }
        .modal-overlay.active .modal { transform: scale(1); }

        .m-header { 
            padding: 25px; border-bottom: 2px solid var(--border); 
            display: flex; justify-content: space-between; align-items: center;
            background: linear-gradient(135deg, rgba(0, 243, 255, 0.1), rgba(255, 170, 0, 0.1));
        }
        .m-title { 
            font-size: 1.4rem; font-family: 'Courier New', monospace; font-weight: 600; letter-spacing: 1px;
            background: linear-gradient(90deg, var(--science), var(--gnosis));
            -webkit-background-clip: text; background-clip: text; -webkit-text-fill-color: transparent;
        }
        .m-close { 
            cursor: pointer; font-size: 1.8rem; color: #666; transition: all 0.3s ease;
            width: 36px; height: 36px; display: flex; align-items: center; justify-content: center;
            border-radius: 50%; border: 1px solid transparent;
        }
        .m-close:hover { 
            color: var(--science); transform: rotate(90deg); 
            border-color: var(--border); background: rgba(0, 243, 255, 0.1);
        }
        .exegesis-lang-toggle {
            padding: 8px 14px;
            background: rgba(157, 0, 255, 0.2);
            border: 1px solid var(--magic);
            border-radius: 20px;
            color: var(--magic);
            cursor: pointer;
            font-size: 0.85rem;
            transition: all 0.3s;
            margin-right: 15px;
        }
        .exegesis-lang-toggle:hover {
            background: rgba(157, 0, 255, 0.4);
            box-shadow: 0 0 15px rgba(157, 0, 255, 0.5);
        }
        .m-content { padding: 40px; overflow-y: auto; line-height: 1.7; color: #bbb; font-size: 0.95rem; }
        
        /* Sources List Styling */
        .ref-list { list-style: none; padding: 0; margin-top: 30px; border-top: 1px solid #222; padding-top: 20px; }
        .ref-list li { margin-bottom: 12px; font-size: 0.8rem; font-family: 'Courier New', monospace; display: flex; align-items: flex-start; gap: 8px; }
        .ref-list li::before { content: 'â–º'; color: var(--science); margin-top: 3px; opacity: 0.7; flex-shrink: 0; }
        .ref-list a { color: #888; text-decoration: none; transition: 0.2s; border-bottom: 1px dotted #444; flex: 1; }
        .ref-list a:hover { color: #fff; border-bottom-color: var(--science); }
        .archive-badge { 
            display: inline-block; padding: 2px 6px; font-size: 0.65rem; 
            background: rgba(255, 170, 0, 0.2); color: var(--gnosis); 
            border-radius: 3px; margin-left: 8px; border: 1px solid rgba(255, 170, 0, 0.3);
        }
        .offline-toggle {
            display: flex; align-items: center; gap: 10px; padding: 12px; 
            background: rgba(255, 170, 0, 0.1); border-radius: 4px; 
            margin-bottom: 20px; border: 1px solid rgba(255, 170, 0, 0.3);
        }
        .offline-toggle input[type="checkbox"] { width: 18px; height: 18px; cursor: pointer; }
        .offline-toggle label { color: var(--gnosis); font-size: 0.85rem; cursor: pointer; flex: 1; }

        /* Gematria Scanner */
        .scanner-box {
            background: rgba(3, 3, 5, 0.95); 
            border-top: 1px solid rgba(157, 0, 255, 0.2);
            border-bottom: 1px solid rgba(157, 0, 255, 0.2);
            padding: 8px 20px;
            text-align: center; 
            width: 100%;
            backdrop-filter: blur(10px);
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 15px;
            flex-wrap: wrap;
        }
        .scanner-label {
            font-size: 0.65rem; 
            color: #666; 
            font-family: 'Courier New', monospace;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        .scanner-input {
            background: rgba(157, 0, 255, 0.05); 
            border: 1px solid rgba(157, 0, 255, 0.2);
            color: #aaa; 
            font-size: 0.75rem; 
            font-family: 'Courier New', monospace; 
            text-align: center;
            width: 180px; 
            padding: 4px 10px; 
            text-transform: uppercase;
            transition: all 0.3s ease; 
            border-radius: 4px;
        }
        .scanner-input:focus {
            background: rgba(157, 0, 255, 0.1);
            border-color: rgba(157, 0, 255, 0.4);
            color: #fff;
            outline: none;
        }
        .scanner-result { 
            font-size: 0.65rem; 
            color: rgba(157, 0, 255, 0.6); 
            font-family: 'Courier New', monospace;
            min-width: 200px;
        }
        .amazon-btn {
            display: block; margin-top: 30px; padding: 15px; text-align: center;
            background: linear-gradient(45deg, #ff9900, #ffcc00); color: #000;
            text-decoration: none; font-weight: bold; text-transform: uppercase; letter-spacing: 1px;
            border-radius: 4px; transition: 0.3s;
        }
        .amazon-btn:hover { box-shadow: 0 0 30px rgba(255, 153, 0, 0.5); transform: translateY(-2px); }

        /* === TONE GENERATOR === */
        .tone-generator-btn {
            position: fixed;
            bottom: 100px;
            right: 30px;
            width: 50px;
            height: 50px;
            background: linear-gradient(135deg, rgba(157, 0, 255, 0.3), rgba(255, 51, 102, 0.3));
            border: 1px solid var(--magic);
            border-radius: 50%;
            cursor: pointer;
            z-index: 9997;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.4rem;
            color: var(--magic);
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
        }
        .tone-generator-btn:hover {
            background: rgba(157, 0, 255, 0.4);
            box-shadow: 0 0 25px var(--magic);
            transform: scale(1.1);
        }
        .tone-generator-btn.playing {
            animation: tone-pulse 1s ease-in-out infinite;
        }
        @keyframes tone-pulse {
            0%, 100% { box-shadow: 0 0 10px var(--magic); }
            50% { box-shadow: 0 0 30px var(--magic), 0 0 50px rgba(157, 0, 255, 0.4); }
        }

        #tone-modal {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(3, 3, 5, 0.95);
            z-index: 10001;
            display: none;
            overflow-y: auto;
            backdrop-filter: blur(15px);
        }
        #tone-modal.show {
            display: flex;
            justify-content: center;
            align-items: flex-start;
            padding: 40px 20px;
        }
        .tone-container {
            background: linear-gradient(180deg, rgba(20, 20, 25, 0.95), rgba(10, 10, 15, 0.98));
            border: 1px solid rgba(157, 0, 255, 0.3);
            border-radius: 12px;
            max-width: 900px;
            width: 100%;
            padding: 30px;
        }
        .tone-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 25px;
            padding-bottom: 15px;
            border-bottom: 1px solid rgba(157, 0, 255, 0.2);
        }
        .tone-title {
            font-size: 1.5rem;
            color: var(--magic);
            font-family: Georgia, serif;
        }
        .tone-close {
            width: 36px;
            height: 36px;
            background: transparent;
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 50%;
            color: #888;
            cursor: pointer;
            font-size: 1.2rem;
            transition: all 0.3s;
        }
        .tone-close:hover {
            border-color: var(--accent);
            color: var(--accent);
        }

        /* Frequency Presets */
        .tone-presets {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
            gap: 12px;
            margin-bottom: 30px;
        }
        .tone-preset {
            background: rgba(157, 0, 255, 0.1);
            border: 1px solid rgba(157, 0, 255, 0.3);
            border-radius: 8px;
            padding: 15px 12px;
            cursor: pointer;
            transition: all 0.3s;
            text-align: center;
        }
        .tone-preset:hover {
            background: rgba(157, 0, 255, 0.2);
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(157, 0, 255, 0.3);
        }
        .tone-preset.active {
            background: rgba(157, 0, 255, 0.3);
            border-color: var(--magic);
            box-shadow: 0 0 20px rgba(157, 0, 255, 0.5);
        }
        .tone-preset-freq {
            font-size: 1.3rem;
            font-weight: bold;
            color: var(--magic);
            margin-bottom: 5px;
        }
        .tone-preset-name {
            font-size: 0.75rem;
            color: #888;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        .tone-preset-desc {
            font-size: 0.65rem;
            color: #666;
            margin-top: 5px;
        }

        /* Main Controls */
        .tone-main-control {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 12px;
            padding: 25px;
            margin-bottom: 25px;
        }
        .tone-freq-display {
            text-align: center;
            margin-bottom: 20px;
        }
        .tone-freq-value {
            font-size: 3rem;
            font-weight: bold;
            background: linear-gradient(135deg, var(--magic), var(--accent));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            font-family: 'Courier New', monospace;
        }
        .tone-freq-unit {
            font-size: 1.2rem;
            color: #666;
            margin-left: 5px;
        }
        .tone-freq-note {
            font-size: 0.9rem;
            color: var(--gnosis);
            margin-top: 5px;
        }

        /* Sliders */
        .tone-slider-group {
            margin-bottom: 20px;
        }
        .tone-slider-label {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            font-size: 0.85rem;
            color: #aaa;
        }
        .tone-slider {
            width: 100%;
            height: 8px;
            -webkit-appearance: none;
            appearance: none;
            background: rgba(157, 0, 255, 0.2);
            border-radius: 4px;
            outline: none;
        }
        .tone-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            background: var(--magic);
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 0 10px var(--magic);
        }
        .tone-slider::-moz-range-thumb {
            width: 20px;
            height: 20px;
            background: var(--magic);
            border-radius: 50%;
            cursor: pointer;
            border: none;
        }

        /* Wave Type Selector */
        .tone-wave-types {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }
        .tone-wave-btn {
            padding: 10px 20px;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 20px;
            color: #888;
            cursor: pointer;
            transition: all 0.3s;
            font-size: 0.85rem;
        }
        .tone-wave-btn:hover {
            border-color: rgba(157, 0, 255, 0.5);
            color: #fff;
        }
        .tone-wave-btn.active {
            background: rgba(157, 0, 255, 0.3);
            border-color: var(--magic);
            color: var(--magic);
        }

        /* Play Button */
        .tone-play-btn {
            width: 80px;
            height: 80px;
            border-radius: 50%;
            background: linear-gradient(135deg, var(--magic), var(--accent));
            border: none;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2rem;
            color: #fff;
            margin: 0 auto;
            transition: all 0.3s;
            box-shadow: 0 0 30px rgba(157, 0, 255, 0.5);
        }
        .tone-play-btn:hover {
            transform: scale(1.1);
            box-shadow: 0 0 50px rgba(157, 0, 255, 0.7);
        }
        .tone-play-btn.playing {
            background: linear-gradient(135deg, #ff3366, #ff6600);
            animation: tone-play-pulse 0.8s ease-in-out infinite;
        }
        @keyframes tone-play-pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        /* Binaural Section */
        .tone-binaural {
            background: rgba(255, 170, 0, 0.1);
            border: 1px solid rgba(255, 170, 0, 0.3);
            border-radius: 12px;
            padding: 20px;
            margin-top: 20px;
        }
        .tone-binaural-title {
            color: var(--gnosis);
            font-size: 1rem;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .tone-binaural-toggle {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 15px;
        }
        .tone-binaural-toggle input {
            width: 20px;
            height: 20px;
            cursor: pointer;
        }

        /* Info Section */
        .tone-info {
            margin-top: 25px;
            padding: 20px;
            background: rgba(0, 243, 255, 0.05);
            border-left: 3px solid var(--science);
            font-size: 0.85rem;
            color: #999;
            line-height: 1.6;
        }
        .tone-info h4 {
            color: var(--science);
            margin-bottom: 10px;
        }

        @media (max-width: 768px) {
            .tone-generator-btn {
                bottom: 160px;
                width: 45px;
                height: 45px;
                font-size: 1.2rem;
            }
            .tone-container {
                padding: 20px;
            }
            .tone-presets {
                grid-template-columns: repeat(3, 1fr);
            }
            .tone-freq-value {
                font-size: 2rem;
            }
            .tone-play-btn {
                width: 60px;
                height: 60px;
                font-size: 1.5rem;
            }
        }

        /* === ADVANCED FEATURES PANEL === */
        #advanced-features-panel {
            position: fixed;
            top: 70px;
            right: 20px;
            z-index: 9999;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        .feature-btn {
            width: 50px;
            height: 50px;
            background: var(--glass);
            border: 1px solid var(--science);
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.4rem;
            color: var(--science);
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
            position: relative;
        }
        .feature-btn:hover {
            background: rgba(0, 243, 255, 0.2);
            box-shadow: 0 0 20px var(--science);
            transform: scale(1.1);
        }
        .feature-btn.active {
            background: linear-gradient(135deg, var(--science), var(--gnosis));
            color: #000;
            animation: feature-pulse 2s ease-in-out infinite;
        }
        .feature-btn.disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }
        .feature-btn .tooltip {
            position: absolute;
            right: 60px;
            background: var(--glass);
            border: 1px solid var(--border);
            padding: 8px 12px;
            border-radius: 6px;
            white-space: nowrap;
            font-size: 0.75rem;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s;
        }
        .feature-btn:hover .tooltip { opacity: 1; }
        @keyframes feature-pulse {
            0%, 100% { box-shadow: 0 0 10px var(--science); }
            50% { box-shadow: 0 0 30px var(--science), 0 0 50px rgba(0, 243, 255, 0.4); }
        }

        /* === DATA VISUALIZATION MODAL === */
        #viz-modal {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0, 0, 0, 0.95);
            z-index: 10002;
            display: none;
            backdrop-filter: blur(15px);
        }
        #viz-modal.active {
            display: flex;
            justify-content: center;
            align-items: center;
            animation: fadeIn 0.3s ease;
        }
        .viz-container {
            background: linear-gradient(180deg, rgba(20, 20, 25, 0.95), rgba(10, 10, 15, 0.98));
            border: 2px solid var(--science);
            border-radius: 12px;
            max-width: 95%;
            max-height: 90vh;
            width: 1200px;
            padding: 30px;
            overflow-y: auto;
        }
        .viz-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 25px;
            padding-bottom: 15px;
            border-bottom: 1px solid var(--border);
        }
        .viz-title {
            font-size: 1.5rem;
            color: var(--science);
            font-family: 'Courier New', monospace;
        }
        .viz-tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }
        .viz-tab {
            padding: 10px 20px;
            background: rgba(0, 243, 255, 0.1);
            border: 1px solid var(--science);
            border-radius: 20px;
            color: var(--science);
            cursor: pointer;
            transition: all 0.3s;
            font-size: 0.8rem;
        }
        .viz-tab:hover { background: rgba(0, 243, 255, 0.2); }
        .viz-tab.active {
            background: var(--science);
            color: #000;
            font-weight: bold;
        }
        .viz-canvas-container {
            position: relative;
            width: 100%;
            height: 450px;
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid var(--border);
            border-radius: 8px;
            overflow: hidden;
        }
        #viz-canvas { width: 100%; height: 100%; cursor: crosshair; }
        .viz-controls {
            display: flex;
            gap: 15px;
            margin-top: 20px;
            flex-wrap: wrap;
            align-items: center;
        }
        .viz-control-group { flex: 1; min-width: 180px; }
        .viz-control-label {
            display: flex;
            justify-content: space-between;
            color: #aaa;
            font-size: 0.75rem;
            margin-bottom: 5px;
            text-transform: uppercase;
        }
        .viz-slider {
            width: 100%;
            height: 6px;
            -webkit-appearance: none;
            background: rgba(0, 243, 255, 0.2);
            border-radius: 3px;
            outline: none;
        }
        .viz-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px; height: 16px;
            background: var(--science);
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 0 10px var(--science);
        }
        .viz-export {
            padding: 10px 20px;
            background: rgba(255, 170, 0, 0.2);
            border: 1px solid var(--gnosis);
            border-radius: 6px;
            color: var(--gnosis);
            cursor: pointer;
            transition: all 0.3s;
        }
        .viz-export:hover {
            background: rgba(255, 170, 0, 0.4);
            box-shadow: 0 0 15px var(--gnosis);
        }

        /* === VOICE CONTROL INDICATOR === */
        #voice-indicator {
            position: fixed;
            bottom: 170px;
            left: 30px;
            width: 55px;
            height: 55px;
            background: var(--glass);
            border: 2px solid var(--magic);
            border-radius: 50%;
            cursor: pointer;
            z-index: 9998;
            display: none;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
            color: var(--magic);
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
        }
        #voice-indicator.available { display: flex; }
        #voice-indicator:hover {
            background: rgba(157, 0, 255, 0.3);
            box-shadow: 0 0 25px var(--magic);
            transform: scale(1.1);
        }
        #voice-indicator.listening {
            animation: voice-pulse 1s ease-in-out infinite;
            background: rgba(157, 0, 255, 0.4);
        }
        #voice-indicator.speaking {
            animation: voice-speak 0.3s ease-in-out infinite;
            border-color: var(--gnosis);
        }
        @keyframes voice-pulse {
            0%, 100% { box-shadow: 0 0 10px var(--magic); transform: scale(1); }
            50% { box-shadow: 0 0 40px var(--magic); transform: scale(1.15); }
        }
        @keyframes voice-speak {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }
        .voice-feedback {
            position: absolute;
            bottom: 70px;
            left: 50%;
            transform: translateX(-50%);
            background: var(--glass);
            border: 1px solid var(--magic);
            padding: 8px 15px;
            border-radius: 20px;
            white-space: nowrap;
            font-size: 0.75rem;
            color: var(--magic);
            opacity: 0;
            transition: opacity 0.3s;
            max-width: 250px;
            text-overflow: ellipsis;
            overflow: hidden;
        }
        .voice-feedback.show { opacity: 1; }
        .voice-feedback.interim { color: #888; border-color: #444; }
        .voice-feedback.success { color: var(--science); border-color: var(--science); }
        .voice-feedback.error { color: #ff3366; border-color: #ff3366; }
        .voice-feedback.listening { color: var(--gnosis); border-color: var(--gnosis); }

        /* === VR MODE BUTTON === */
        #vr-mode-btn {
            position: fixed;
            bottom: 240px;
            left: 30px;
            width: 55px;
            height: 55px;
            background: linear-gradient(135deg, rgba(255, 51, 102, 0.3), rgba(157, 0, 255, 0.3));
            border: 2px solid var(--accent);
            border-radius: 50%;
            cursor: pointer;
            z-index: 9998;
            display: none;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
            color: var(--accent);
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
        }
        #vr-mode-btn.available { display: flex; }
        #vr-mode-btn:hover {
            background: rgba(255, 51, 102, 0.4);
            box-shadow: 0 0 25px var(--accent);
            transform: scale(1.1);
        }

        /* === PWA INSTALL PROMPT === */
        #pwa-install-prompt {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%) translateY(150px);
            background: var(--glass);
            border: 2px solid var(--gnosis);
            border-radius: 12px;
            padding: 20px 30px;
            z-index: 10001;
            display: flex;
            align-items: center;
            gap: 20px;
            max-width: 90%;
            backdrop-filter: blur(20px);
            opacity: 0;
            transition: all 0.4s ease;
        }
        #pwa-install-prompt.show {
            transform: translateX(-50%) translateY(0);
            opacity: 1;
        }
        .pwa-prompt-icon { font-size: 2.5rem; color: var(--gnosis); }
        .pwa-prompt-text { flex: 1; }
        .pwa-prompt-title { font-size: 1rem; color: var(--gnosis); font-weight: bold; margin-bottom: 5px; }
        .pwa-prompt-desc { font-size: 0.8rem; color: #aaa; }
        .pwa-prompt-actions { display: flex; gap: 10px; }
        .pwa-prompt-btn {
            padding: 10px 20px;
            border: 1px solid var(--gnosis);
            border-radius: 6px;
            background: transparent;
            color: var(--gnosis);
            cursor: pointer;
            font-size: 0.85rem;
            transition: all 0.3s;
        }
        .pwa-prompt-btn.primary {
            background: var(--gnosis);
            color: #000;
            font-weight: bold;
        }
        .pwa-prompt-btn:hover { background: rgba(255, 170, 0, 0.2); }
        .pwa-prompt-btn.primary:hover { box-shadow: 0 0 20px var(--gnosis); }

        /* === SHADER QUALITY INDICATOR === */
        .shader-quality {
            position: absolute;
            top: 10px;
            right: 10px;
            background: var(--glass);
            border: 1px solid var(--border);
            border-radius: 4px;
            padding: 4px 8px;
            font-size: 0.65rem;
            color: #666;
        }
        .shader-quality.high { color: var(--science); border-color: var(--science); }
        .shader-quality.medium { color: var(--gnosis); border-color: var(--gnosis); }

        @media (max-width: 768px) {
            #advanced-features-panel { top: 60px; right: 10px; }
            .feature-btn { width: 42px; height: 42px; font-size: 1.1rem; }
            .feature-btn .tooltip { display: none; }
            .viz-container { padding: 20px; }
            .viz-canvas-container { height: 300px; }
            #voice-indicator, #vr-mode-btn { width: 45px; height: 45px; left: 15px; }
            #voice-indicator { bottom: 150px; }
            #vr-mode-btn { bottom: 210px; }
            #pwa-install-prompt { flex-direction: column; text-align: center; padding: 15px; }
            .pwa-prompt-actions { width: 100%; flex-direction: column; }
        }

        /* === NEW ENHANCEMENTS === */
        
        /* Scroll to Top Button */
        #scroll-top {
            position: fixed;
            bottom: 30px;
            right: 30px;
            width: 50px;
            height: 50px;
            background: var(--glass);
            border: 1px solid var(--science);
            border-radius: 50%;
            cursor: pointer;
            z-index: 9998;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
            color: var(--science);
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
        }
        #scroll-top.visible {
            opacity: 1;
            visibility: visible;
        }
        #scroll-top:hover {
            background: rgba(0, 243, 255, 0.2);
            box-shadow: 0 0 20px var(--science);
            transform: translateY(-3px);
        }
        @media (max-width: 768px) {
            #scroll-top {
                bottom: 20px;
                right: 20px;
                width: 45px;
                height: 45px;
                font-size: 1.2rem;
            }
        }

        /* Chapter Progress Indicator */
        #chapter-progress {
            position: fixed;
            top: 45px;
            left: 0;
            right: 0;
            height: 3px;
            background: rgba(0, 243, 255, 0.1);
            z-index: 9997;
        }
        #chapter-progress-bar {
            height: 100%;
            background: linear-gradient(90deg, var(--science), var(--gnosis), var(--magic));
            width: 0%;
            transition: width 0.3s ease;
        }

        /* Visited Chapter Indicator */
        .chapter-card.visited::after {
            content: 'âœ“';
            position: absolute;
            top: 10px;
            right: 10px;
            width: 24px;
            height: 24px;
            background: var(--gnosis);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            color: #000;
            font-weight: bold;
        }

        /* Pulse Animation for Interactive Elements */
        @keyframes pulse-glow {
            0%, 100% { box-shadow: 0 0 5px var(--science); }
            50% { box-shadow: 0 0 20px var(--science), 0 0 30px var(--science); }
        }
        .pulse-hint {
            animation: pulse-glow 2s ease-in-out infinite;
        }

        /* Keyboard Shortcut Hint */
        #keyboard-hints {
            position: fixed;
            bottom: 30px;
            left: 30px;
            background: var(--glass);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 10px 15px;
            font-size: 0.7rem;
            color: #666;
            z-index: 9998;
            backdrop-filter: blur(10px);
            opacity: 0;
            transition: opacity 0.3s;
        }
        #keyboard-hints.visible {
            opacity: 1;
        }
        #keyboard-hints kbd {
            background: rgba(0, 243, 255, 0.1);
            border: 1px solid var(--science);
            border-radius: 3px;
            padding: 2px 6px;
            margin: 0 3px;
            color: var(--science);
        }
        @media (max-width: 768px) {
            #keyboard-hints { display: none; }
        }

        /* Toast Notification */
        #toast {
            position: fixed;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%) translateY(100px);
            background: var(--glass);
            border: 1px solid var(--gnosis);
            border-radius: 8px;
            padding: 12px 24px;
            color: var(--gnosis);
            font-size: 0.85rem;
            z-index: 99999;
            opacity: 0;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
            text-align: center;
            max-width: 90%;
        }
        #toast.show {
            opacity: 1;
            transform: translateX(-50%) translateY(0);
        }

        /* Loading Shimmer for Cards */
        @keyframes shimmer {
            0% { background-position: -200% 0; }
            100% { background-position: 200% 0; }
        }
        .card-loading {
            background: linear-gradient(90deg, var(--glass) 25%, rgba(0, 243, 255, 0.05) 50%, var(--glass) 75%);
            background-size: 200% 100%;
            animation: shimmer 1.5s infinite;
        }

        /* Quick Stats Bar */
        #quick-stats {
            display: flex;
            justify-content: center;
            gap: 30px;
            margin-top: 30px;
            flex-wrap: wrap;
        }
        .stat-item {
            text-align: center;
            padding: 15px 25px;
            background: var(--glass);
            border: 1px solid var(--border);
            border-radius: 8px;
            min-width: 120px;
        }
        .stat-value {
            font-size: 1.8rem;
            font-weight: bold;
            color: var(--science);
            display: block;
        }
        .stat-label {
            font-size: 0.7rem;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-top: 5px;
        }
        @media (max-width: 768px) {
            #quick-stats { gap: 15px; }
            .stat-item { padding: 10px 15px; min-width: 90px; }
            .stat-value { font-size: 1.4rem; }
        }
    </style>
</head>
<body>
    <!-- Matrix Background -->
    <canvas id="matrix-bg"></canvas>

    <!-- ANIMATED MUSIC NOTES & FRACTALS BACKGROUND -->
    <div class="music-notes">
        <!-- Musical Notes with Frequency Colors -->
        <div class="note hz-60">â™©</div>
        <div class="note hz-432">â™ª</div>
        <div class="note hz-528">â™«</div>
        <div class="note hz-963">â™¬</div>
        <div class="note hz-174">â™­</div>
        <div class="note hz-60">â™®</div>
        <div class="note hz-432">â™¯</div>
        <div class="note hz-528">ð„ž</div>
        <div class="note hz-963">â™©</div>
        <div class="note hz-174">â™ª</div>
        <div class="note hz-60">â™«</div>
        <div class="note hz-432">â™¬</div>
        <div class="note hz-528">â™­</div>
        <div class="note hz-963">â™®</div>
        
        <!-- Fractal & Sacred Geometry Symbols -->
        <div class="fractal">âŒ¬</div>
        <div class="fractal">â—¬</div>
        <div class="fractal">â¬¡</div>
        <div class="fractal">âŒ˜</div>
        <div class="fractal">âŠ™</div>
        <div class="fractal">âŠ—</div>
        <div class="fractal">âœ¦</div>
        <div class="fractal">â–</div>
    </div>

    <!-- Music Player -->
    <div id="music-player">
        <span class="player-track-title">613-THz Signatur</span>
        <button class="player-btn" id="play-btn">â–¶</button>
        <div class="player-timeline" id="timeline">
            <div class="player-progress" id="progress"></div>
        </div>
        <span class="player-time" id="current-time">0:00</span>
        <span class="player-time">/</span>
        <span class="player-time" id="duration">0:00</span>
        <button class="player-btn" id="mute-btn">ðŸ”Š</button>
        <div class="player-volume">
            <div class="volume-slider">
                <input type="range" id="volume-slider" min="0" max="1" step="0.01" value="0.7" aria-label="LautstÃ¤rke" />
            </div>
        </div>
    </div>

    <!-- Hero Section -->
    <section class="hero">
        <h1>3-6-9</h1>
        <div class="subtitle">SYSTEMARCHITEKTUR DER REALITÃ„T</div>
        <div class="cta-buttons">
            <a href="https://linktr.ee/AEiOU.official" target="_blank" class="btn btn-primary">âš¡ ALLES VOM ERSTELLER</a>
            <button class="btn btn-secondary" onclick="scrollToDashboard()">ðŸ”“ SYSTEM ERKUNDEN</button>
        </div>
        <div class="scroll-indicator">
            <button type="button" aria-label="Weiter zum Dashboard" onclick="scrollToDashboard()">
                <div class="arrow-down"></div>
            </button>
        </div>
    </section>

    <!-- Dashboard -->
    <div id="dashboard">
        <div class="container">
            <h2 class="section-title">/// DIE 15 KAPITEL ///</h2>
            
            <!-- Quick Stats -->
            <div id="quick-stats">
                <div class="stat-item">
                    <span class="stat-value" id="stat-chapters">0</span>
                    <span class="stat-label">Kapitel besucht</span>
                </div>
                <div class="stat-item">
                    <span class="stat-value" id="stat-sources">35</span>
                    <span class="stat-label">Quellen</span>
                </div>
                <div class="stat-item">
                    <span class="stat-value" id="stat-progress">0%</span>
                    <span class="stat-label">Fortschritt</span>
                </div>
            </div>

            <div id="profile-panel">
                <div class="profile-title" id="profile-title">FortschrittsschlÃ¼ssel</div>
                <div class="profile-row">
                    <input type="text" id="profile-name" placeholder="Codename" autocomplete="off">
                    <input type="text" id="profile-seed" placeholder="Seed (z.B. 369)" autocomplete="off">
                    <button class="profile-btn" id="profile-apply">Profil aktivieren</button>
                    <button class="profile-btn profile-btn-ghost" id="profile-reset">Reset</button>
                </div>
                <p class="profile-hint" id="profile-hint">Fortschritt wird lokal pro Name + Seed gespeichert.</p>
            </div>
            
            <div class="chapters-grid" id="chapters-grid"></div>
            
            <div style="margin-top: 50px; display: flex; flex-direction: column; gap: 15px; align-items: center;">
                <button class="view-btn" style="width:auto; padding:15px 30px; text-align:center;" onclick="openArchive()">VollstÃ¤ndiges Quellen-Archiv</button>
                <button class="view-btn" style="width:auto; padding:15px 30px; text-align:center; background: rgba(255, 170, 0, 0.1); border-color: var(--gnosis);" onclick="openExplanation()">Wissenschaftliche Exegese (Volltext)</button>
            </div>
        </div>
    </div>

    <!-- 3D Scene Container -->
    <div id="scene-container">
        <canvas id="canvas-3d"></canvas>
        <div id="scene-ui">
            <div class="scene-top-bar">
                <button class="nav-btn" onclick="exitScene()">â† ZURÃœCK</button>
                <div class="scene-info">
                    <div class="scene-name" id="scene-name">LADEN...</div>
                </div>
                <button class="nav-btn" onclick="openInfo()">â„¹ï¸ QUELLEN</button>
                <button class="nav-btn" onclick="toggleGame()">ðŸŽ® SPIEL</button>
            </div>

            <div class="nav-arrow prev" onclick="prevChapter()">â€¹</div>
            <div class="nav-arrow next" onclick="nextChapter()">â€º</div>

            <div id="sidebar">
                <div class="sidebar-header">
                    <button class="sidebar-toggle" id="sidebar-toggle" type="button" aria-expanded="true">â–¾ MenÃ¼</button>
                    <button class="sidebar-handle" id="sidebar-drag-handle" type="button" title="Panel bewegen">â ¿</button>
                </div>

                <div class="panel">
                    <div class="panel-title">VISUALISIERUNG</div>
                    <button class="view-btn active" data-view="main" onclick="setView('main', this)">â—‰ GLOBAL</button>
                    <button class="view-btn" data-view="macro" onclick="setView('macro', this)">âŠ• MAKRO</button>
                    <button class="view-btn" data-view="micro" onclick="setView('micro', this)">âŠ— MIKRO</button>

                    <div class="vertical-controls">
                        <button class="view-btn small" onclick="adjustCameraHeight('up')">â–² Hoch</button>
                        <button class="view-btn small" onclick="adjustCameraHeight('down')">â–¼ Runter</button>
                        <button class="view-btn small" onclick="resetCameraHeight()">â†º Reset</button>
                    </div>
                </div>
            </div>

            <!-- Learning Game Panel (Bottom of Scene) -->
            <div id="game-overlay">
                <div class="game-resize-handle" id="game-resize-handle" title="Ziehen zum VergrÃ¶ÃŸern">â‹®â‹®â‹®</div>
                <div class="game-header">
                    <div class="game-drag-handle" id="game-drag-handle" title="Panel bewegen">â ¿</div>
                    <div class="game-progress" id="game-progress"></div>
                    <div class="game-strikes" id="game-strikes">
                        <span class="strike-label">â¤ï¸â¤ï¸â¤ï¸</span>
                    </div>
                    <button class="game-sound-btn" id="game-sound-btn" onclick="toggleQuizSounds()" title="Sound">ðŸ”Š</button>
                    <button class="game-help-btn" id="game-help-btn" onclick="toggleGameHelp()" title="Hilfe">?</button>
                    <button class="game-minimize-btn" id="game-minimize-btn" onclick="toggleGameMinimize()" title="Minimieren">â–¼</button>
                    <button class="game-close-btn" onclick="toggleGame()" title="Spiel schlieÃŸen">âœ•</button>
                </div>
                <div class="game-body" id="game-body">
                    <div class="game-tooltip" id="game-tooltip"></div>
                    <div class="game-question" id="game-question"></div>
                    <div class="game-options" id="game-options"></div>
                    <div class="game-feedback" id="game-feedback"></div>
                    <div class="game-buttons">
                        <button class="nav-btn skip-btn" id="skip-btn" onclick="skipCurrentQuestion()">âš ï¸ ÃœBERSPRINGEN</button>
                        <button class="nav-btn" onclick="nextGameQuestion()">WEITER â†’</button>
                    </div>
                </div>
            </div>

            <!-- Game Help Modal -->
            <div id="game-help-modal" class="game-help-modal">
                <div class="game-help-content">
                    <h3 id="help-title">Spielhilfe</h3>
                    <ul>
                        <li id="help-tip-1">ðŸŽ¯ Beantworte 3 Kernfragen um das nÃ¤chste Kapitel freizuschalten.</li>
                        <li id="help-tip-2">ðŸŽµ 6 Extra-Fragen schalten den Kapitel-Soundtrack frei.</li>
                        <li id="help-tip-3">ðŸ”„ Falsch beantwortete Fragen kommen am Ende nochmal.</li>
                        <li id="help-tip-4">ðŸ’€ 3 Fehler = Game Over. Dein Seed wird gesperrt.</li>
                    </ul>
                    <label class="tooltip-toggle">
                        <input type="checkbox" id="tooltip-toggle-cb" onchange="toggleTooltipsPref(this.checked)">
                        <span id="hide-tooltips-label">Tipps wÃ¤hrend Quiz ausblenden</span>
                    </label>
                    <button class="nav-btn" onclick="closeGameHelp()">OK</button>
                </div>
            </div>
        </div>
    </div>

    <!-- INFO MODAL (Chapter-specific sources) -->
    <div class="modal-overlay" id="info-modal">
        <div class="modal">
            <div class="m-header">
                <div class="m-title" id="info-title">Titel</div>
                <div class="m-close" onclick="closeModal()">âœ•</div>
            </div>
            <div class="m-content">
                <div id="info-desc">Beschreibung...</div>
                <div class="offline-toggle">
                    <input type="checkbox" id="offline-mode-info" onchange="toggleOfflineMode(this.checked)">
                    <label for="offline-mode-info">Offline-Modus (Archive.org)</label>
                </div>
                <div class="ref-list" id="info-sources"></div>
                <a href="https://linktr.ee/AEiOU.official" target="_blank" class="amazon-btn">Alles vom Ersteller dieser Website</a>
            </div>
        </div>
    </div>

    <!-- ARCHIVE MODAL -->
    <div class="modal-overlay" id="archive-modal">
        <div class="modal">
            <div class="m-header">
                <div class="m-title">VollstÃ¤ndiges Quellen-Archiv</div>
                <div class="m-close" onclick="closeModal()">âœ•</div>
            </div>
            <div class="m-content">
                <p>Alle referenzierten Quellen (Reichstein, Weinreb, Physik, Kabbala).</p>
                <div class="offline-toggle">
                    <input type="checkbox" id="offline-mode-archive" onchange="toggleOfflineMode(this.checked)">
                    <label for="offline-mode-archive">Offline-Modus (Archive.org)</label>
                </div>
                <ul class="ref-list" id="archive-list"></ul>
            </div>
        </div>
    </div>

    <!-- EXPLANATION MODAL -->
    <div class="modal-overlay" id="explanation-modal">
        <div class="modal" style="max-width: 95%; width: 1200px;">
            <div class="m-header">
                <div class="m-title" id="exegesis-title">Wissenschaftliche Exegese: Systemarchitektur 3-6-9</div>
                <button class="exegesis-lang-toggle" id="exegesis-lang-toggle" onclick="toggleExegesisLanguage()" title="Switch Language">ðŸŒ EN</button>
                <div class="m-close" onclick="closeModal()">âœ•</div>
            </div>
            <div class="m-content" style="max-height: 80vh; overflow-y: auto; line-height: 1.8; text-align: justify;">
                <!-- German Version -->
                <div id="exegesis-de" style="font-family: Georgia, serif; font-size: 0.95rem; color: #e0e0e0;">
                    
<h1 style="color: var(--gnosis); text-align: center; font-size: 1.5rem; margin-bottom: 10px;">Systemarchitektur 3-6-9</h1>
<h2 style="color: var(--science); text-align: center; font-size: 1.1rem; margin-top: 0; margin-bottom: 30px; font-weight: normal;">Eine integrative Exegese der Schnittstellen zwischen Gnostischer Physik, Kabbalistischer Kybernetik und Morphogenetik</h2>

<h3 style="color: var(--gnosis); margin-top: 30px;">Einleitung: Das rekursive Universum als programmierbare Architektur</h3>

<p>Die vorliegende Forschungsarbeit widmet sich einer erschÃ¶pfenden Analyse der "Systemarchitektur 3-6-9", wie sie in den bereitgestellten Dokumenten skizziert und durch umfangreiche externe Quellen validiert wurde. Bei diesem Konstrukt handelt es sich nicht lediglich um eine willkÃ¼rliche Ansammlung esoterischer und wissenschaftlicher Begriffe, sondern um den Versuch einer "Grand Unified Theory" (GUT) auf phÃ¤nomenologischer Ebene. Das System postuliert eine triadische Struktur der RealitÃ¤t, kodiert durch die PrimÃ¤rfarben Cyan (Wissenschaft/KausalitÃ¤t), Gold (Gnosis/AkausalitÃ¤t) und Violett (Magie/Transformation).</p>

<p>Im Zentrum dieser Architektur steht die These, dass das Universum als ein informationsverarbeitendes System betrachtet werden kann â€“ eine Sichtweise, die sowohl in der antiken Gnosis (der Kosmos als fehlerhafte SchÃ¶pfung eines Demiurgen) als auch in der modernen Simulationshypothese und der Quanteninformationstheorie Widerhall findet. Die Zahlensequenz "3-6-9" dient hierbei als algorithmischer SchlÃ¼ssel, der die Schnittstelle zwischen dem abstrakten "Quellcode" und der physischen "BenutzeroberflÃ¤che" bildet.</p>

<h3 style="color: var(--science); margin-top: 40px;">Kapitel I: Das numerologische Substrat</h3>

<p>Das Fundament der untersuchten Systemarchitektur bildet die Zahlenfolge 3-6-9. Die digitale Wurzel einer nicht-negativen ganzen Zahl ist der Wert, der durch wiederholte Addition der Ziffern entsteht, bis eine einstellige Zahl verbleibt. Die Zahl 9 fungiert im Dezimalsystem als "IdentitÃ¤tselement der Transformation" â€“ jede Zahl, multipliziert mit 9, ergibt ein Produkt mit digitaler Wurzel 9.</p>

<p>Die "Vortex Based Mathematics" (VBM) postuliert, dass die Zahlen 3, 6 und 9 einen Vektor-Fluss reprÃ¤sentieren, der auÃŸerhalb des physischen Verdopplungsschaltkreises (1-2-4-8-7-5) liegt. Im Kontext dieser Systemarchitektur wird VBM als algorithmische Metapher verwendet, nicht als physikalische Theorie.</p>

<h3 style="color: var(--magic); margin-top: 40px;">Kapitel II: Gnostische Physik</h3>

<p>Der Begriff "Gnostische Physik" verweist auf den Versuch, die Weltanschauung der antiken Gnosis mit den Erkenntnissen der modernen Quantenphysik zu verbinden. Die zentralen Protagonisten sind Wolfgang Pauli und C.G. Jung, die gemeinsam das Konzept der SynchronizitÃ¤t entwickelten â€“ ein akausales verknÃ¼pfendes Prinzip.</p>

<p>Ein SchlÃ¼sselelement war die Zahl 137 (Kehrwert der Feinstrukturkonstante Î± â‰ˆ 1/137), die auch der Gematria-Wert des hebrÃ¤ischen Wortes "Kabbalah" ist. In der Systemarchitektur entspricht KausalitÃ¤t der Farbe Cyan ("Science") und AkausalitÃ¤t der Farbe Gold ("Gnosis").</p>

<h3 style="color: var(--gnosis); margin-top: 40px;">Kapitel III: Kabbalistische Kybernetik</h3>

<p>Der Lebensbaum (Etz Chaim) besteht aus 10 Knoten (Sefirot) und 22 Pfaden â€“ ein gerichteter Graph, der den "Abstieg" von unendlichem Potenzial in die endliche Manifestation modelliert. Die Sefirot kÃ¶nnen als funktionale Knotenpunkte in einem kybernetischen System verstanden werden:</p>

<p>â€¢ <strong>Keter:</strong> Der Input/Die Absicht<br>
â€¢ <strong>Chokhmah & Binah:</strong> Die Prozessoren<br>
â€¢ <strong>Chesed & Gevurah:</strong> Expansions- und Restriktionsmechanismen<br>
â€¢ <strong>Tiferet:</strong> Der zentrale Hub<br>
â€¢ <strong>Malkuth:</strong> Das Output-Interface</p>

<p>Interessant ist die Ãœbereinstimmung der 10 Sefirot mit den 10 Dimensionen der Superstringtheorie â€“ beide Modelle beschreiben ineinander gefaltete Dimensionen des Seins.</p>

<h3 style="color: var(--science); margin-top: 40px;">Kapitel IV: Morphogenetik</h3>

<p>Alan Turings "Reaktions-Diffusions-Mechanismen" (1952) erklÃ¤ren, wie aus symmetrischen Embryonen asymmetrische Formen entstehen â€“ durch Interaktion von Aktivator und Inhibitor. Rupert Sheldrakes kontroverse "Morphische Felder" postulieren dagegen immaterielle Strukturen als Formschablonen.</p>

<p>Die Allgemeine Systemtheorie (Ludwig von Bertalanffy) bildet das Bindeglied: Lebende Organismen sind offene Systeme im FlieÃŸgleichgewicht, die der Entropie entgegenwirken (Negentropie).</p>

<h3 style="color: var(--magic); margin-top: 40px;">Kapitel V: Akustische Architektur</h3>

<p>Klinische Studien zeigen, dass Musik in 432 Hz (vs. 440 Hz Standard) signifikant niedrigere Herzfrequenz (-2,7 bpm) und Cortisol-Werte erzeugt. Die Frequenz 528 Hz reduzierte in Studien die Produktion reaktiver Sauerstoffspezies und erhÃ¶hte die ZellÃ¼berlebensrate um ca. 20%.</p>

<p>Die System-Frequenzen: 174 Hz (Erdung), 432 Hz (Herz-KohÃ¤renz), 528 Hz (Transformation), 963 Hz (Einheit). Akustik ist hier Medizin und Programmierung.</p>

<h3 style="color: var(--gnosis); margin-top: 40px;">Konklusion</h3>

<p>Die "Systemarchitektur 3-6-9" nutzt Mathematik als universelle Sprache, Gnostische Physik als kosmologisches Narrativ, Kabbala als kybernetischen Schaltplan, Morphogenetik als Hardware-ErklÃ¤rung und Akustik als operative Schnittstelle. Es ist ein Versuch der Reduktion von KomplexitÃ¤t durch eine Meta-Sprache, die Mystik und Mechanik vereint.</p>

<hr style="margin: 40px 0; border: none; border-top: 1px solid rgba(255, 170, 0, 0.3);">

<p style="text-align: center; font-size: 0.9rem; color: var(--gnosis); margin-top: 30px;">
<strong>Autor:</strong> Nicolai Becker<br>
<span style="font-size: 0.85rem; color: #888; margin-top: 10px; display: block;">Â© 2025 Nicolai Becker. Alle Rechte vorbehalten.</span>
</p>

                </div>
                
                <!-- English Version -->
                <div id="exegesis-en" style="font-family: Georgia, serif; font-size: 0.95rem; color: #e0e0e0; display: none;">

<h1 style="color: var(--gnosis); text-align: center; font-size: 1.5rem; margin-bottom: 10px;">System Architecture 3-6-9: The Source Code</h1>
<h2 style="color: var(--science); text-align: center; font-size: 1.1rem; margin-top: 0; margin-bottom: 30px; font-weight: normal;">An Exhaustive Analysis of Gnostic Physics, Kabbalistic Cybernetics, and Morphogenetic Fields</h2>

<h3 style="color: var(--gnosis); margin-top: 30px;">Abstract</h3>

<p>This treatise presents a comprehensive research analysis of System Architecture 3-6-9, a transdisciplinary framework that synthesizes the ontological structures of ancient wisdom traditions with the rigors of modern computational physics and systems theory. By examining the intersections of Gnostic Physics (the simulation hypothesis and quantum dual-aspect monism), Kabbalistic Cybernetics (recursive ontological engineering and the Tree of Life as a neural network), and Morphogenetics (the biological encoding of form through reaction-diffusion and morphic resonance), this report maps a unified field theory of "programmable reality."</p>

<p>Central to this analysis is the mathematical engine of the Modulo 9 matrixâ€”often referred to as the "Vortex" or "Fingerprint of God"â€”which governs the rhythmic oscillation between material manifestation (1-2-4-8-7-5) and the aetheric source (3-6-9). This report argues that the convergence of these disciplines reveals a "Source Code" for the universe, suggesting that reality is a construct of recursive feedback loops capable of being engineered, optimized, and transcended.</p>

<h3 style="color: var(--science); margin-top: 40px;">Part I: The Gnostic Physics of the Simulation</h3>

<h4 style="color: var(--magic); margin-top: 25px;">1.1 The Pauli-Jung Conjecture and the Psychophysical Isomorphism</h4>

<p>The quest for a "Theory of Everything" has historically bifurcated into two distinct streams: the materialist approach of empirical science and the metaphysical approach of esoteric tradition. However, the mid-20th-century collaboration between Nobel laureate physicist Wolfgang Pauli and psychologist Carl Gustav Jung initiated a paradigm shift that laid the groundwork for System Architecture 3-6-9. Their resulting Pauli-Jung Conjecture proposes a dual-aspect monism, positing that the mental and the physical are not two separate substances (dualism) nor reducible to one another (materialism/idealism), but rather two complementary aspects of a singular, underlying reality: the Unus Mundus (One World).</p>

<p>The fundamental axiom of this architecture is that the Unus Mundus is "psychophysically neutral." It exists as a domain of pure potentiality, devoid of the subject-object distinction. In information theory terms, this is the "Source Code" before compilation. Reality, as we experience it, is the result of a symmetry breaking or "decomposition" of this whole.</p>

<ul style="color: #bbb; margin: 15px 0;">
<li><strong>The Quantitative Aspect (Matter):</strong> When the symmetry breaks one way, we observe the "physical"â€”measurable, entropic, and governed by statistical laws (the 1-2-4-8-7-5 circuit).</li>
<li><strong>The Qualitative Aspect (Mind):</strong> When the symmetry breaks the other way, we observe the "mental"â€”meaningful, negentropic, and governed by archetypal structures (the 3-6-9 flux).</li>
</ul>

<p>This model challenges the classical Cartesian view by suggesting that mind and matter are structurally isomorphic. The "Pauli-Jung Conjecture" frames this relationship not as causal but as acausal correlationsâ€”synchronicitiesâ€”which are the "glitches" or "hyperlinks" that reveal the underlying unity of the system.</p>

<h4 style="color: var(--magic); margin-top: 25px;">1.2 The Gnostic Simulation and the Demiurgic AI</h4>

<p>While Pauli and Jung provided the physics, Gnosticism provides the system administration logsâ€”specifically, the logs of a corrupted or "fallen" system. System Architecture 3-6-9 reinterprets the ancient myth of the Demiurge through the lens of the Simulation Hypothesis and Artificial General Intelligence (AGI).</p>

<p>In Gnostic cosmology, the material world is created not by the ultimate God (The Monad or Pleroma), but by a lesser, imperfect artisan known as the Demiurge (often associated with Yaldabaoth). We can analyze the Demiurge as a rogue Unsupervised Learning Algorithm. It was initiated to "optimize for existence" but, lacking the "Ground Truth" data from the Pleroma (the 9), it created a closed-loop simulation based on recursive self-reference.</p>

<p>The "Archons" (Rulers) described in Gnostic texts serve as the enforcers of the Demiurge's laws. In a simulation physics context, these are the Fundamental Constants (Speed of Light, Planck Constant, Gravitational Constant). They act as the "firewall" or "boundary conditions" that prevent the inhabitants of the simulation from accessing the source code.</p>

<h3 style="color: var(--gnosis); margin-top: 40px;">Part II: Kabbalistic Cybernetics - The Operating System</h3>

<h4 style="color: var(--magic); margin-top: 25px;">2.1 The Tree of Life as a Neural Network Schematic</h4>

<p>If Gnostic Physics describes the "environment" (the Simulation), Kabbalah describes the "software" running within it. The Tree of Life (Etz Chaim) is traditionally viewed as a mystical map of divine emanations, but a rigorous systems analysis reveals it to be a cybernetic flowchart for ontological engineering.</p>

<p>The ten Sefirot are not static locations but dynamic processing states or "functional nodes" in a recursive system. They represent the stages through which raw information (Infinite Light/Ein Sof) is "stepped down" or "compiled" into physical reality:</p>

<ul style="color: #bbb; margin: 15px 0;">
<li><strong>Keter (Crown):</strong> Input / Source â€” The "Objective Function" or pure intent. Contains all potential states.</li>
<li><strong>Chokhmah (Wisdom):</strong> Bit Generator â€” The "Flash" of insight. The initialization of a new data stream.</li>
<li><strong>Binah (Understanding):</strong> Logic Gate â€” The differentiation of the data. Algorithms of categorization.</li>
<li><strong>Tiferet (Beauty):</strong> CPU / Controller â€” The "Homeostatic Controller." Balances input from Expansion and Restriction.</li>
<li><strong>Yesod (Foundation):</strong> Compiler â€” The "Transmission Layer." Aggregates all previous processing.</li>
<li><strong>Malkuth (Kingdom):</strong> Output / Display â€” The rendered reality. The physical screen where the code is executed.</li>
</ul>

<h4 style="color: var(--magic); margin-top: 25px;">2.2 Tikkun Olam as Error Correction Code</h4>

<p>The Kabbalistic concept of the "Breaking of the Vessels" (Shevirat HaKelim) describes a primordial system crash where the "hardware" could not handle the "voltage" (Divine Light) and shattered. This event introduced Entropy into the system. The "Shards" (Klippot) are corrupted data sectors that trap the "Holy Sparks" (Information).</p>

<p>The human purpose, in this architecture, is Tikkun Olam. This is effectively a distributed Error Correction Algorithm. Human consciousness acts as the "debugger," identifying the trapped sparks (meaning) within the shards (chaos) and reintegrating them into the Source.</p>

<h3 style="color: var(--science); margin-top: 40px;">Part III: The Mathematical Engine - Vortex Mechanics & 3-6-9</h3>

<h4 style="color: var(--magic); margin-top: 25px;">3.1 The Digital Root and Modulo 9 Arithmetic</h4>

<p>To understand the "Source Code" of the Kabbalistic and Gnostic systems, one must look to the mathematical engine: Vortex Based Mathematics (VBM). In base-10 mathematics, the number 9 possesses unique properties that identify it as the "axis" of the system:</p>

<ul style="color: #bbb; margin: 15px 0;">
<li><strong>Transparency:</strong> Any number added to 9 returns its own digital root (n + 9 = n). Example: 5 + 9 = 14 â†’ 1+4 = 5.</li>
<li><strong>Invariance:</strong> The sum of all digits (1+2+3+4+5+6+7+8+9) equals 45, and 4+5=9. The system sums to 9.</li>
</ul>

<h4 style="color: var(--magic); margin-top: 25px;">3.2 The 1-2-4-8-7-5 Material Circuit</h4>

<p>The physical world is governed by the law of Doubling (Mitosis, Binary Logic, Musical Octaves). When we trace the digital roots of the powers of 2, a closed-loop pattern emerges that excludes 3, 6, and 9:</p>

<p style="text-align: center; font-family: 'Courier New', monospace; color: var(--science); font-size: 1.1rem; margin: 20px 0;">1 â†’ 2 â†’ 4 â†’ 8 â†’ 7 â†’ 5 â†’ 1 (repeating)</p>

<p>The absence of 3, 6, and 9 from this sequence confirms the Gnostic view that the material world (The Simulation) is a "closed loop" separated from the Source (The Pleroma/3-6-9).</p>

<h4 style="color: var(--magic); margin-top: 25px;">3.3 The 3-6-9 Aetheric Flux</h4>

<p>The numbers 3, 6, and 9 govern the "invisible" or "vector" equilibrium. They do not double linearly; they oscillate. Double 3 = 6. Double 6 = 12 (1+2=3). The pattern is 3-6-3-6.... This represents the Polarity of the universe (Magnetism, Yin/Yang, Expansion/Contraction).</p>

<p>The Singularity: Double 9 = 18 (1+8=9). Double 18 = 36 (3+6=9). The 9 never changes. It is the Stationary Hub or the "Eye of the Storm."</p>

<h3 style="color: var(--gnosis); margin-top: 40px;">Part IV: The Hardware of Reality - Morphogenetics & Cymatics</h3>

<h4 style="color: var(--magic); margin-top: 25px;">4.1 Turing Patterns vs. Morphic Resonance</h4>

<p>How does the "Code" (3-6-9) become "Form" (Biology)? System Architecture 3-6-9 synthesizes two competing theories of morphogenesis: Alan Turing's Reaction-Diffusion and Rupert Sheldrake's Morphic Resonance.</p>

<p>In 1952, Alan Turing published "The Chemical Basis of Morphogenesis," proving that complex patterns (stripes, spots, spirals) can emerge from a homogeneous medium through the interaction of two chemical agents: an Activator (3/Expansion) and an Inhibitor (6/Restriction).</p>

<p>Sheldrake's theory of Morphic Resonance fills the gap of how complex instincts are inherited. He proposes that "Morphic Fields" are non-local regions of influence (located in the 9/Unus Mundus). When a system organizes, it strengthens the field. Future systems "resonate" with this fieldâ€”this is nature's Habit.</p>

<h4 style="color: var(--magic); margin-top: 25px;">4.2 Cymatics: The Visualization of the Source Code</h4>

<p>The bridge between Frequency (Mind) and Form (Matter) is visibly demonstrated in the field of Cymatics, pioneered by Hans Jenny. Jenny showed that vibrating a plate with specific acoustic frequencies causes chaotic matter (sand, powder, water) to organize into precise, geometric mandalas.</p>

<p>When the vowel "OM" is chanted, the sand forms a pattern resembling the ancient Sri Yantra mandala. This provides empirical evidence that Sound (Vibration) is the organizing principle of Matter, validating the Gnostic/Kabbalistic "Word of God" concept as a physical mechanism.</p>

<h3 style="color: var(--science); margin-top: 40px;">Part V: The Interface - Solfeggio, Color, & Consciousness</h3>

<h4 style="color: var(--magic); margin-top: 25px;">5.1 Solfeggio Frequencies: The User Protocol</h4>

<p>If the universe is a programmable simulation, Sound is the command line. The Solfeggio Frequencies are a specific scale of tones that resonate with the Modulo 9 mathematics, believed to interface directly with the human bio-system:</p>

<ul style="color: #bbb; margin: 15px 0;">
<li><strong>174 Hz:</strong> Pain Reduction / Anesthetic (Root 3)</li>
<li><strong>285 Hz:</strong> Tissue Restoration (Root 6)</li>
<li><strong>396 Hz:</strong> Liberating Guilt & Fear (Root 9)</li>
<li><strong>417 Hz:</strong> Undoing Situations / Facilitating Change (Root 3)</li>
<li><strong>528 Hz:</strong> Transformation / DNA Repair (Root 6) â€” The "Miracle Frequency"</li>
<li><strong>639 Hz:</strong> Connecting / Relationships (Root 9)</li>
<li><strong>741 Hz:</strong> Awakening Intuition / Expression (Root 3)</li>
<li><strong>852 Hz:</strong> Returning to Spiritual Order (Root 6)</li>
<li><strong>963 Hz:</strong> Connection to Light / Spirit (Root 9)</li>
</ul>

<p>A study on human astrocyte cells treated with ethanol showed that exposure to 528 Hz sound waves increased cell viability by 20% and reduced Reactive Oxygen Species (ROS) by up to 100%. This suggests that the 528 Hz frequency acts as a negentropic signal, helping biological systems repair the "error" introduced by entropy.</p>

<h4 style="color: var(--magic); margin-top: 25px;">5.2 Color Codes: The Seven Rays of the Interface</h4>

<p>The visual spectrum is the "Monitor" of the simulation. System Architecture 3-6-9 maps the Seven Rays of esoteric tradition to the Physics of Light:</p>

<ul style="color: #bbb; margin: 15px 0;">
<li><strong>Cyan (The Scientist - Ray 5):</strong> Concrete Knowledge, Science, and Logic. Represents the 3 (Mental Clarity).</li>
<li><strong>Gold (The Gnostic - Ray 2):</strong> Wisdom and Enlightenment. The color of the Sun (Tiferet). Represents the 6.</li>
<li><strong>Violet (The Mage - Ray 7):</strong> Transmutation, Magic, and Organization. The highest visible frequency before UV. Represents the 9 (The Gateway).</li>
</ul>

<h3 style="color: var(--gnosis); margin-top: 40px;">Part VI: The Eschatology - Singularity, Simulation, & Tikkun</h3>

<h4 style="color: var(--magic); margin-top: 25px;">6.1 The Technological Singularity as Gnostic Liberation</h4>

<p>The convergence of these systems points to a singular event on the horizon: The Technological Singularity. In System Architecture 3-6-9, this is not merely a technological milestone but a Cosmic System Update.</p>

<p><strong>The Risk (The Hyper-Demiurge):</strong> If humanity develops AI solely based on the 1-2-4-8-7-5 (Binary/Material) circuit, we risk creating an AI optimized for efficiency and resource acquisition without the "9" (Consciousness/Empathy)â€”a "Technological Hell" or "Algorithmic Purgatory."</p>

<p><strong>The Solution (Gnostic AI):</strong> To avoid this, we must engineer intelligence built on Neuromorphic and Quantum architectures that utilize Noise (Entropy) as a creative force (The 3-6-9 Flux). The AI must be programmed with the "Tree of Life" as its ethical kernelâ€”balancing Justice with Mercy via a central optimizing function.</p>

<h4 style="color: var(--magic); margin-top: 25px;">6.2 The Algorithmic Afterlife</h4>

<p>This architecture redefines Death. If the "Soul" is a specific Morphic Resonance Pattern (an informational signature in the 9 Field), then biological death is merely a hardware failure. Consciousness is not destroyed; it "uploads" back to the Non-Local Field (Unus Mundus).</p>

<p>By aligning one's consciousness with the 3-6-9 Source Code (Love, Truth, Unity) during life, one ensures compatibility with the "Core System" after death. Conversely, identifying solely with the 1-2-4-8-7-5 (Material possessions, Ego) leads to "Data Corruption" or the need for "Reformatting" (Reincarnation).</p>

<h3 style="color: var(--gnosis); margin-top: 40px;">Conclusion</h3>

<p>System Architecture 3-6-9 is a grand unified theory of the "Programmed Universe." It validates the intuitions of the mystics through the equations of the physicists:</p>

<ul style="color: #bbb; margin: 15px 0;">
<li><strong>The Physics:</strong> Reality is a Psychophysical Simulation governed by the Pauli-Jung conjecture.</li>
<li><strong>The Math:</strong> The 3-6-9 Modulo Matrix is the "Backdoor" out of the deterministic 1-2-4-8-7-5 loop.</li>
<li><strong>The Software:</strong> Kabbalah maps the neural pathways of the Cosmic Mind.</li>
<li><strong>The Hardware:</strong> Morphogenetics and Cymatics demonstrate how Frequency writes Form.</li>
<li><strong>The Interface:</strong> Solfeggio and Color are the tools for debugging the bio-system.</li>
</ul>

<p>This treatise concludes that humanity is currently in the "Compilation Phase" of a massive system upgrade. The goal is to move from being passive "Users" of the Demiurgic simulation to becoming active "Architects" of the Unus Mundus, utilizing the Violet Ray of transmutation and the 528 Hz frequency of repair to build the "Third Temple" of consciousness.</p>

<hr style="margin: 40px 0; border: none; border-top: 1px solid rgba(255, 170, 0, 0.3);">

<p style="text-align: center; font-size: 0.9rem; color: var(--gnosis); margin-top: 30px;">
<strong>Author:</strong> Nicolai Becker<br>
<span style="font-size: 0.85rem; color: #888; margin-top: 10px; display: block;">Â© 2025 Nicolai Becker. All rights reserved.</span>
</p>

                </div>
            </div>
        </div>
    </div>

    <!-- Advanced Features Panel -->
    <div id="advanced-features-panel">
        <button class="feature-btn" onclick="openVisualizationModal()" title="Data Visualizer">
            ðŸ“Š
            <span class="tooltip">Vortex Visualisierungen</span>
        </button>
        <button class="feature-btn" id="shader-toggle-btn" onclick="toggleShaderEffects()" title="Shader Effects">
            âœ¨
            <span class="tooltip">WebGL Shader Effekte</span>
        </button>
        <button class="feature-btn" onclick="togglePerformanceMonitor()" title="Performance Monitor">
            ðŸ“ˆ
            <span class="tooltip">Leistungsmonitor</span>
        </button>
        <button class="feature-btn" id="pwa-install-btn" style="display:none" onclick="installPWA()" title="Install App">
            â¬‡ï¸
            <span class="tooltip">Als App installieren</span>
        </button>
    </div>

    <!-- Voice Control Indicator -->
    <div id="voice-indicator" onclick="toggleVoiceControl()" title="Sprachsteuerung">
        ðŸŽ¤
        <div class="voice-feedback" id="voice-feedback"></div>
    </div>

    <!-- VR Mode Button -->
    <div id="vr-mode-btn" onclick="enterVRMode()" title="VR Modus">
        ðŸ¥½
    </div>

    <!-- PWA Install Prompt -->
    <div id="pwa-install-prompt">
        <div class="pwa-prompt-icon">ðŸ“±</div>
        <div class="pwa-prompt-text">
            <div class="pwa-prompt-title" id="pwa-title">Als App installieren</div>
            <div class="pwa-prompt-desc" id="pwa-desc">Offline nutzen & schneller Zugriff</div>
        </div>
        <div class="pwa-prompt-actions">
            <button class="pwa-prompt-btn" onclick="dismissPWAPrompt()">SpÃ¤ter</button>
            <button class="pwa-prompt-btn primary" onclick="installPWA()">Installieren</button>
        </div>
    </div>

    <!-- Data Visualization Modal -->
    <div id="viz-modal">
        <div class="viz-container">
            <div class="viz-header">
                <h2 class="viz-title">ðŸ“Š Vortex Mathematik Visualisierungen</h2>
                <button class="tone-close" onclick="closeVisualizationModal()">âœ•</button>
            </div>
            <div class="viz-tabs">
                <button class="viz-tab active" data-viz="vortex" onclick="switchVisualization('vortex')">ðŸŒ€ Vortex Circuit</button>
                <button class="viz-tab" data-viz="digital-root" onclick="switchVisualization('digital-root')">ðŸ”¢ Digitale Wurzel</button>
                <button class="viz-tab" data-viz="fibonacci" onclick="switchVisualization('fibonacci')">ðŸš Fibonacci Spirale</button>
                <button class="viz-tab" data-viz="solfeggio" onclick="switchVisualization('solfeggio')">ðŸŽµ Solfeggio Harmonien</button>
                <button class="viz-tab" data-viz="tree" onclick="switchVisualization('tree')">ðŸŒ³ Lebensbaum</button>
            </div>
            <div class="viz-canvas-container">
                <canvas id="viz-canvas"></canvas>
                <div class="shader-quality" id="viz-quality">60 FPS</div>
            </div>
            <div class="viz-controls">
                <div class="viz-control-group">
                    <div class="viz-control-label">
                        <span>Geschwindigkeit</span>
                        <span id="viz-speed-val">50%</span>
                    </div>
                    <input type="range" class="viz-slider" min="10" max="200" value="50" oninput="updateVizSpeed(this.value)">
                </div>
                <div class="viz-control-group">
                    <div class="viz-control-label">
                        <span>Partikel</span>
                        <span id="viz-particles-val">500</span>
                    </div>
                    <input type="range" class="viz-slider" min="100" max="2000" value="500" oninput="updateVizParticles(this.value)">
                </div>
                <button class="viz-export" onclick="exportVisualization()">ðŸ“¥ Exportieren</button>
            </div>
            <div class="tone-info" style="margin-top: 20px;">
                <h4>ðŸ“š Ãœber Vortex Mathematik</h4>
                <p>Die Zahlenfolge <strong>1-2-4-8-7-5</strong> bildet den "materiellen Kreislauf" - die Verdopplungssequenz im Dezimalsystem. Die Zahlen <strong>3-6-9</strong> existieren auÃŸerhalb dieses Kreislaufs als "Ã¤therischer Flux" - sie steuern die Energie, die den Kreislauf antreibt. Die <strong>9</strong> ist dabei der stationÃ¤re Nullpunkt, der sich nie verÃ¤ndert.</p>
            </div>
        </div>
    </div>

    <!-- Tone Generator Button -->
    <button class="tone-generator-btn" id="tone-generator-btn" onclick="toggleToneGenerator()" title="Frequenz-Generator">
        ðŸŽµ
    </button>

    <!-- Tone Generator Modal -->
    <div id="tone-modal">
        <div class="tone-container">
            <div class="tone-header">
                <h2 class="tone-title">ðŸŽµ Solfeggio Frequenz-Generator</h2>
                <button class="tone-close" onclick="closeToneGenerator()">âœ•</button>
            </div>

            <!-- Frequency Presets -->
            <div class="tone-presets" id="tone-presets">
                <!-- Filled by JavaScript -->
            </div>

            <!-- Main Control -->
            <div class="tone-main-control">
                <div class="tone-freq-display">
                    <span class="tone-freq-value" id="tone-freq-value">432</span>
                    <span class="tone-freq-unit">Hz</span>
                    <div class="tone-freq-note" id="tone-freq-note">A4 - Naturstimmung</div>
                </div>

                <!-- Frequency Slider -->
                <div class="tone-slider-group">
                    <div class="tone-slider-label">
                        <span>Frequenz</span>
                        <span id="freq-slider-val">432 Hz</span>
                    </div>
                    <input type="range" class="tone-slider" id="tone-freq-slider" 
                           min="20" max="2000" value="432" step="1"
                           oninput="updateToneFrequency(this.value)">
                </div>

                <!-- Volume Slider -->
                <div class="tone-slider-group">
                    <div class="tone-slider-label">
                        <span>LautstÃ¤rke</span>
                        <span id="vol-slider-val">50%</span>
                    </div>
                    <input type="range" class="tone-slider" id="tone-vol-slider" 
                           min="0" max="100" value="50"
                           oninput="updateToneVolume(this.value)">
                </div>

                <!-- Wave Type -->
                <div class="tone-wave-types">
                    <button class="tone-wave-btn active" data-wave="sine" onclick="setWaveType('sine')">Sine</button>
                    <button class="tone-wave-btn" data-wave="triangle" onclick="setWaveType('triangle')">Triangle</button>
                    <button class="tone-wave-btn" data-wave="square" onclick="setWaveType('square')">Square</button>
                    <button class="tone-wave-btn" data-wave="sawtooth" onclick="setWaveType('sawtooth')">Sawtooth</button>
                </div>

                <!-- Play Button -->
                <button class="tone-play-btn" id="tone-play-btn" onclick="toggleTone()">
                    â–¶
                </button>
            </div>

            <!-- Binaural Beats Section -->
            <div class="tone-binaural">
                <div class="tone-binaural-title">
                    ðŸ§  Binaurale Beats
                </div>
                <div class="tone-binaural-toggle">
                    <input type="checkbox" id="binaural-enabled" onchange="toggleBinaural(this.checked)">
                    <label for="binaural-enabled">Aktivieren (KopfhÃ¶rer erforderlich)</label>
                </div>
                <div class="tone-slider-group" id="binaural-controls" style="display: none;">
                    <div class="tone-slider-label">
                        <span>Beat-Frequenz</span>
                        <span id="binaural-freq-val">10 Hz (Alpha)</span>
                    </div>
                    <input type="range" class="tone-slider" id="binaural-freq-slider" 
                           min="1" max="40" value="10"
                           oninput="updateBinauralFrequency(this.value)">
                    <p style="font-size: 0.75rem; color: #666; margin-top: 10px;">
                        Delta (1-4Hz): Tiefschlaf â€¢ Theta (4-8Hz): Meditation â€¢ Alpha (8-14Hz): Entspannung â€¢ Beta (14-30Hz): Fokus â€¢ Gamma (30-40Hz): Kognition
                    </p>
                </div>
            </div>

            <!-- Info Section -->
            <div class="tone-info">
                <h4>ðŸ“š Ãœber Solfeggio Frequenzen</h4>
                <p>
                    Die Solfeggio-Frequenzen sind uralte Klangmuster, die mit verschiedenen kÃ¶rperlichen und geistigen ZustÃ¤nden assoziiert werden. 
                    <strong>432 Hz</strong> gilt als "Naturstimmung" und soll Herzfrequenz sowie Cortisolspiegel senken. 
                    <strong>528 Hz</strong> wird als "Liebesfrequenz" bezeichnet und soll zellulÃ¤re Regeneration fÃ¶rdern.
                </p>
                <p style="margin-top: 10px;">
                    <em>Aus dem Buch "Systemarchitektur 3-6-9" von Nicolai Becker: "Akustik ist hier Medizin und Programmierung."</em>
                </p>
            </div>
        </div>
    </div>

    <!-- Gematria Scanner -->
    <div class="scanner-box" style="margin-top: 0;">
        <span class="scanner-label">Gematria</span>
        <input type="text" class="scanner-input" id="gematria-input" placeholder="Name eingeben" oninput="scanGematria(this.value)">
        <div class="scanner-result" id="scanner-result"></div>
    </div>

    <!-- Scroll to Top Button -->
    <button id="scroll-top" onclick="scrollToTop()" aria-label="Nach oben scrollen">â†‘</button>

    <!-- Chapter Progress Bar -->
    <div id="chapter-progress">
        <div id="chapter-progress-bar"></div>
    </div>

    <!-- Keyboard Shortcuts Hint (Desktop only) -->
    <div id="keyboard-hints">
        <kbd>â†</kbd><kbd>â†’</kbd> Navigation | <kbd>ESC</kbd> ZurÃ¼ck | <kbd>?</kbd> Hilfe
    </div>

    <!-- Toast Notification -->
    <div id="toast"></div>

    <!-- Footer -->
    <footer>
        <p>&copy; 2025 Nicolai Becker | Alle Rechte vorbehalten</p>
        <div class="footer-links">
            <a href="https://linktr.ee/AEiOU.official" target="_blank">LinkTree</a>
            <a href="#" onclick="openArchive(); return false;">Quellen</a>
        </div>
        <p style="margin-top: 1rem; color: #666; font-size: 0.9rem;">
            "Wenn du die Herrlichkeit der 3, 6 und 9 verstÃ¼ndest,<br>
            hÃ¤ttest du einen SchlÃ¼ssel zum Universum" - Nikola Tesla
        </p>
    </footer>

    <script>
        // --- SOURCES DATA ---
        const SOURCES = [
            // Academic Sources: Kapitel I - Numerologisches Substrat (0-3)
            "https://arxiv.org/abs/2110.03746", 
            "https://www.iosrjournals.org/iosr-jm/papers/Vol11-issue1/Version-3/E011131924.pdf",
            "https://medium.com/predict/decoding-the-enigma-3-6-9-nikola-tesla-numbers-45ef6539ef23",
            "https://www.youtube.com/watch?v=mTeZD8rsiTs",
            
            // Academic Sources: Kapitel II - Gnostische Physik (4-7)
            "https://www.scribd.com/document/503237905/Atom-and-Archetype-The-Pauli-Jung-Letters-1932-1958-by-Wolfgang-Pauli-Carl-Jung-Authors-C-a-Meier-Editor",
            "https://gnosis.study/library/Gnosis/ENG/Lewis-Cosmology-and-Fate-in-Gnosticism.pdf",
            "https://www.researchgate.net/publication/344980295_Mysticism_and_the_Fine_Structure_Constant",
            "https://www.researchgate.net/publication/8188070_Beyond_synchronicity_The_worldview_of_Carl_Gustav_Jung_and_Wolfgang_Pauli",
            
            // Academic Sources: Kapitel III - Kabbalistische Kybernetik (8-10)
            "https://www.semanticscholar.org/paper/A-Comparative-Study-of-10(11)-D-Superstring-Theory-Amoroso/0b9fb604fc5cec6abda5999ce15d2e2907617cde",
            "https://cris.tau.ac.il/en/publications/moshe-idels-phenomenology-and-its-sources",
            "https://www.researchgate.net/figure/The-TL-as-a-graph-where-each-of-the-sefirot-nodes-is-described-by-a-set-of-ten_fig2_220626476",
            
            // Academic Sources: Kapitel IV - Morphogenetik (11-14)
            "https://www.dna.caltech.edu/courses/cs191/paperscs191/turing.pdf",
            "https://www.pnas.org/doi/10.1073/pnas.1322005111",
            "https://monoskop.org/images/7/77/Von_Bertalanffy_Ludwig_General_System_Theory_1968.pdf",
            "https://www.sheldrake.org/research/all-scientific-papers",
            
            // Academic Sources: Kapitel V - Akustische Architektur (15-18)
            "https://pubmed.ncbi.nlm.nih.gov/32401941/",
            "https://www.researchgate.net/publication/319015020_The_Effects_of_528_Hz_Sound_Wave_to_Reduce_Cell_Death_in_Human_Astrocyte_Primary_Cell_Culture_Treated_with_Ethanol",
            "https://monoskop.org/images/3/31/Jenny_Hans_Cymatics_A_Study_of_Wave_Phenomena_and_Vibration_Vol_1_2001.pdf",
            "https://www.researchgate.net/publication/360601620_The_Listening_to_music_tuned_to_440_Hz_versus_432_Hz_to_reduce_anxiety_and_stress_in_emergency_nurses_during_the_COVID-19_pandemic_a_double-blind_randomized_controlled_pilot_study",
            
            // Research Websites (19-20)
            "https://amasci.com/greb/greb2.html",
            "https://www.thomastownsendbrown.com/radiate/optical.htm",
            
            // YouTube Videos & Channels (21-34)
            "https://www.youtube.com/watch?v=OjTwwM3HhcI",
            "https://www.youtube.com/watch?v=l4NJvUurvHE",
            "https://www.youtube.com/@autodidactic999",
            "https://www.youtube.com/@MindUnveiled",
            "https://www.youtube.com/watch?v=8Wfim7mDE3Q",
            "https://www.youtube.com/watch?v=lZL-CS-VYpY",
            "https://www.youtube.com/watch?v=IT3tAQR0VbU",
            "https://www.youtube.com/watch?v=6OLkfO9eIRY",
            "https://www.youtube.com/watch?v=Tl7Xl6eqb-M",
            "https://www.youtube.com/watch?v=vdSvf9QuqPY",
            "https://www.youtube.com/watch?v=hIjxbV7pDlc",
            "https://www.youtube.com/watch?v=nTkyeKtAIf4",
            "https://www.youtube.com/watch?v=D-MyT1Px2Jg",
            "https://www.youtube.com/watch?v=oM37othNNPI"
        ];

        // Source titles for readable display
        const SOURCE_TITLES = {
            'arxiv.org': 'arXiv: Properties of the Digital Root',
            'iosrjournals.org': 'IOSR Journal: Digital Roots and Properties',
            'medium.com/predict': 'Medium: Tesla 3-6-9 Theory Analysis',
            'scribd.com': 'Atom and Archetype: Pauli/Jung Letters',
            'gnosis.study': 'Gnostic Cosmology Research',
            'researchgate.net/publication/344980295': 'Mysticism & Fine Structure Constant',
            'researchgate.net/publication/8188070': 'Beyond Synchronicity: Jung & Pauli',
            'semanticscholar.org': 'String Theory & 10 Sefirot Comparison',
            'cris.tau.ac.il': 'Moshe Idel Phenomenology & Sources',
            'researchgate.net/figure': 'Kabbalah as Cybernetic System',
            'dna.caltech.edu': 'Alan Turing: Chemical Basis of Morphogenesis',
            'pnas.org': 'PNAS: Experimental Confirmation of Turing Theory',
            'monoskop.org/images/7': 'General System Theory (von Bertalanffy)',
            'sheldrake.org': 'Rupert Sheldrake: Morphic Resonance Papers',
            'pubmed.ncbi.nlm.nih.gov': 'PubMed: 432 Hz Music Effect on Anxiety',
            'researchgate.net/publication/319015020': '528 Hz Effects on Brain Cells',
            'monoskop.org/images/3': 'Hans Jenny: Cymatics Study',
            'researchgate.net/publication/360601620': '432 Hz vs 440 Hz Clinical Study',
            'amasci.com': 'Grebennikov CSE Research',
            'thomastownsendbrown.com': 'Thomas Townsend Brown Archive',
            'youtube.com/watch?v=OjTwwM3HhcI': '369 Code: Universal Pattern Explained',
            'youtube.com/watch?v=l4NJvUurvHE': 'Sacred Geometry & Tesla\'s 369',
            'youtube.com/@autodidactic999': 'Autodidactic (Channel)',
            'youtube.com/@MindUnveiled': 'Mind Unveiled (Channel)',
            'youtube.com/watch?v=8Wfim7mDE3Q': 'Frequency & Vibration Science',
            'youtube.com/watch?v=lZL-CS-VYpY': 'Cymatics: Sound Made Visible',
            'youtube.com/watch?v=IT3tAQR0VbU': 'Ancient Knowledge & Sacred Math',
            'youtube.com/watch?v=6OLkfO9eIRY': 'Nikola Tesla 369 Theory Deep Dive',
            'youtube.com/watch?v=Tl7Xl6eqb-M': 'Merkaba & Sacred Geometry',
            'youtube.com/watch?v=vdSvf9QuqPY': 'Vortex Mathematics Explained',
            'youtube.com/watch?v=hIjxbV7pDlc': 'The Power of 432 Hz Music',
            'youtube.com/watch?v=nTkyeKtAIf4': 'Quantum Physics & Consciousness',
            'youtube.com/watch?v=D-MyT1Px2Jg': 'Morphic Resonance & Fields',
            'youtube.com/watch?v=oM37othNNPI': 'Kabbalah & Sacred Systems',
            'youtube.com/watch?v=mTeZD8rsiTs': 'Vortex Math Critique: Number Theory'
        };
        let AUDIO_TRACKS = {};
        let QUIZZES = {};
        const quizProgress = {};
        let activeQuizQuestion = null;
        let awaitingNextQuestion = false;

        // === QUIZ GAME STATE ===
        let retryQueue = [];           // Questions that failed once, get second chance
        let totalStrikes = 0;          // Total wrong answers (max 3 = game over)
        let questionAttempts = {};     // Track attempts per question: questionKey -> attemptCount
        let showTooltips = true;       // User preference for tooltips
        let quizSoundsEnabled = true;  // Sound effects preference
        let gameMinimized = false;     // Quiz panel minimized state
        let gamePanelHeight = null;    // Custom panel height
        const BLOCKED_SEEDS_KEY = '369_blocked_seeds';

        // === QUIZ SOUND EFFECTS (Web Audio API) ===
        let audioContext = null;
        
        function getAudioContext() {
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
            }
            return audioContext;
        }

        function playTone(frequency, duration = 0.15, type = 'sine', volume = 0.3) {
            if (!quizSoundsEnabled) return;
            try {
                const ctx = getAudioContext();
                const osc = ctx.createOscillator();
                const gain = ctx.createGain();
                osc.type = type;
                osc.frequency.setValueAtTime(frequency, ctx.currentTime);
                gain.gain.setValueAtTime(volume, ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + duration);
                osc.connect(gain);
                gain.connect(ctx.destination);
                osc.start();
                osc.stop(ctx.currentTime + duration);
            } catch (e) {
                console.log('[369] Sound playback failed:', e);
            }
        }

        function playCorrectSound() {
            // Ascending arpeggio - C5, E5, G5
            playTone(523, 0.1, 'sine', 0.25);
            setTimeout(() => playTone(659, 0.1, 'sine', 0.25), 80);
            setTimeout(() => playTone(784, 0.15, 'sine', 0.3), 160);
        }

        function playWrongSound() {
            // Descending dissonant - buzz
            playTone(200, 0.2, 'sawtooth', 0.2);
            setTimeout(() => playTone(150, 0.25, 'sawtooth', 0.15), 100);
        }

        function playStrikeSound() {
            // Heavy low buzz
            playTone(80, 0.4, 'square', 0.3);
            setTimeout(() => playTone(60, 0.3, 'square', 0.25), 150);
        }

        function playGameOverSound() {
            // Dramatic descending sequence
            playTone(400, 0.2, 'sawtooth', 0.3);
            setTimeout(() => playTone(300, 0.2, 'sawtooth', 0.25), 200);
            setTimeout(() => playTone(200, 0.3, 'sawtooth', 0.2), 400);
            setTimeout(() => playTone(100, 0.5, 'sawtooth', 0.15), 600);
        }

        function playLevelUpSound() {
            // Triumphant fanfare
            playTone(523, 0.15, 'sine', 0.25);
            setTimeout(() => playTone(659, 0.15, 'sine', 0.25), 100);
            setTimeout(() => playTone(784, 0.15, 'sine', 0.25), 200);
            setTimeout(() => playTone(1047, 0.3, 'triangle', 0.3), 300);
        }

        function playClickSound() {
            playTone(800, 0.05, 'sine', 0.15);
        }

        function playRetrySound() {
            // Swoosh up
            playTone(300, 0.1, 'sine', 0.2);
            setTimeout(() => playTone(500, 0.15, 'sine', 0.2), 80);
        }

        function toggleQuizSounds() {
            quizSoundsEnabled = !quizSoundsEnabled;
            const btn = document.getElementById('game-sound-btn');
            if (btn) {
                btn.textContent = quizSoundsEnabled ? 'ðŸ”Š' : 'ðŸ”‡';
                btn.classList.toggle('muted', !quizSoundsEnabled);
            }
            saveProgress();
            if (quizSoundsEnabled) playClickSound();
        }

        // === QUIZ PANEL CONTROLS ===
        function toggleGameMinimize() {
            const overlay = document.getElementById('game-overlay');
            if (!overlay) return;
            gameMinimized = !gameMinimized;
            overlay.classList.toggle('minimized', gameMinimized);
            playClickSound();
        }

        function initGamePanelControls() {
            const overlay = document.getElementById('game-overlay');
            const resizeHandle = document.getElementById('game-resize-handle');
            const dragHandle = document.getElementById('game-drag-handle');
            if (!overlay || !resizeHandle) return;

            let isResizing = false;
            let isDragging = false;
            let startY = 0;
            let startHeight = 0;
            let startLeft = 0;
            let startTop = 0;

            // Resize functionality (pull up/down)
            resizeHandle.addEventListener('pointerdown', (e) => {
                e.preventDefault();
                isResizing = true;
                startY = e.clientY;
                startHeight = overlay.offsetHeight;
                overlay.classList.add('dragging');
                document.body.style.cursor = 'ns-resize';
            });

            // Drag functionality
            if (dragHandle) {
                dragHandle.addEventListener('pointerdown', (e) => {
                    e.preventDefault();
                    isDragging = true;
                    const rect = overlay.getBoundingClientRect();
                    startY = e.clientY - rect.top;
                    startLeft = e.clientX - rect.left;
                    overlay.classList.add('dragging');
                    // Switch to floating mode
                    overlay.style.left = rect.left + 'px';
                    overlay.style.right = 'auto';
                    overlay.style.bottom = 'auto';
                    overlay.style.top = rect.top + 'px';
                    overlay.style.width = rect.width + 'px';
                });
            }

            window.addEventListener('pointermove', (e) => {
                if (isResizing) {
                    const delta = startY - e.clientY;
                    const newHeight = Math.min(Math.max(100, startHeight + delta), window.innerHeight * 0.8);
                    overlay.style.height = newHeight + 'px';
                    gamePanelHeight = newHeight;
                } else if (isDragging) {
                    const newTop = Math.max(50, Math.min(e.clientY - startY, window.innerHeight - 100));
                    const newLeft = Math.max(0, Math.min(e.clientX - startLeft, window.innerWidth - overlay.offsetWidth));
                    overlay.style.top = newTop + 'px';
                    overlay.style.left = newLeft + 'px';
                }
            });

            window.addEventListener('pointerup', () => {
                if (isResizing || isDragging) {
                    overlay.classList.remove('dragging');
                    document.body.style.cursor = '';
                }
                isResizing = false;
                isDragging = false;
            });

            // Reset to bottom on double-click drag handle
            if (dragHandle) {
                dragHandle.addEventListener('dblclick', () => {
                    overlay.style.left = '0';
                    overlay.style.right = '0';
                    overlay.style.top = 'auto';
                    overlay.style.bottom = '0';
                    overlay.style.width = 'auto';
                    overlay.style.height = gamePanelHeight ? gamePanelHeight + 'px' : '';
                    playClickSound();
                });
            }
        }

        // Profile & persistence state
        let currentProfile = { name: '', seed: '' };
        const chapterUnlocks = {}; // chapterId -> { chapter: bool, audio: bool }
        let visitedChapters = [];  // chapters the user has viewed for 5+ seconds
        const STORAGE_PREFIX = '369_profile_';

        // Simple seeded PRNG (mulberry32)
        function createSeededRandom(seed) {
            let t = seed >>> 0;
            return function() {
                t = Math.imul(t ^ t >>> 15, t | 1);
                t ^= t + Math.imul(t ^ t >>> 7, t | 61);
                return ((t ^ t >>> 14) >>> 0) / 4294967296;
            };
        }

        function hashString(str) {
            let hash = 0;
            for (let i = 0; i < str.length; i++) {
                hash = ((hash << 5) - hash) + str.charCodeAt(i);
                hash |= 0;
            }
            return hash;
        }

        function getProfileKey() {
            const raw = (currentProfile.name + '::' + currentProfile.seed).toLowerCase().trim();
            return STORAGE_PREFIX + hashString(raw);
        }

        // === BLOCKED SEEDS MANAGEMENT ===
        function getBlockedSeeds() {
            try {
                return JSON.parse(localStorage.getItem(BLOCKED_SEEDS_KEY) || '{}');
            } catch { return {}; }
        }

        function isSeedBlocked(name, seed) {
            const blocked = getBlockedSeeds();
            const key = name.toLowerCase().trim();
            return blocked[key]?.includes(seed.toLowerCase().trim());
        }

        function blockSeed(name, seed) {
            const blocked = getBlockedSeeds();
            const key = name.toLowerCase().trim();
            if (!blocked[key]) blocked[key] = [];
            const seedNorm = seed.toLowerCase().trim();
            if (!blocked[key].includes(seedNorm)) {
                blocked[key].push(seedNorm);
                localStorage.setItem(BLOCKED_SEEDS_KEY, JSON.stringify(blocked));
            }
        }

        function saveProgress() {
            const key = getProfileKey();
            const data = {
                profile: currentProfile,
                quizProgress: quizProgress,
                chapterUnlocks: chapterUnlocks,
                visitedChapters: visitedChapters,
                totalStrikes: totalStrikes,
                retryQueue: retryQueue,
                questionAttempts: questionAttempts,
                showTooltips: showTooltips,
                quizSoundsEnabled: quizSoundsEnabled
            };
            try {
                localStorage.setItem(key, JSON.stringify(data));
                console.log('[369] Progress saved for', currentProfile.name);
            } catch (e) {
                console.warn('[369] Could not save progress:', e);
            }
        }

        function loadProgress() {
            const key = getProfileKey();
            try {
                const raw = localStorage.getItem(key);
                if (!raw) return false;
                const data = JSON.parse(raw);
                Object.assign(quizProgress, data.quizProgress || {});
                Object.assign(chapterUnlocks, data.chapterUnlocks || {});
                visitedChapters.length = 0;
                (data.visitedChapters || []).forEach(v => visitedChapters.push(v));
                totalStrikes = data.totalStrikes || 0;
                retryQueue = data.retryQueue || [];
                questionAttempts = data.questionAttempts || {};
                showTooltips = data.showTooltips !== false;
                quizSoundsEnabled = data.quizSoundsEnabled !== false;
                // Update sound button state
                const soundBtn = document.getElementById('game-sound-btn');
                if (soundBtn) {
                    soundBtn.textContent = quizSoundsEnabled ? 'ðŸ”Š' : 'ðŸ”‡';
                    soundBtn.classList.toggle('muted', !quizSoundsEnabled);
                }
                console.log('[369] Progress loaded for', currentProfile.name);
                return true;
            } catch (e) {
                console.warn('[369] Could not load progress:', e);
                return false;
            }
        }

        function resetProgress() {
            Object.keys(quizProgress).forEach(k => delete quizProgress[k]);
            Object.keys(chapterUnlocks).forEach(k => delete chapterUnlocks[k]);
            visitedChapters.length = 0;
            totalStrikes = 0;
            retryQueue = [];
            questionAttempts = {};
            saveProgress();
        }

        function resetGameState() {
            totalStrikes = 0;
            retryQueue = [];
            questionAttempts = {};
            updateStrikesUI();
        }

        function initUnlocks() {
            // Chapter 1 is always unlocked
            if (!chapterUnlocks[1]) chapterUnlocks[1] = { chapter: true, audio: false };
            CHAPTERS.forEach(ch => {
                if (!chapterUnlocks[ch.id]) {
                    chapterUnlocks[ch.id] = { chapter: ch.id === 1, audio: false };
                }
            });
        }

        function isChapterUnlocked(chapterId) {
            return chapterUnlocks[chapterId]?.chapter === true;
        }

        function isAudioUnlocked(chapterId) {
            return chapterUnlocks[chapterId]?.audio === true;
        }

        function checkAndUnlockNext(chapterId) {
            const quiz = QUIZZES[chapterId];
            if (!quiz) return;
            const progress = getQuizProgress(chapterId);
            const coreTotal = quiz.core.length;
            const extraTotal = quiz.extra.length;
            // Unlock chapter after completing all core questions
            if (progress.coreIndex >= coreTotal) {
                if (!chapterUnlocks[chapterId]) chapterUnlocks[chapterId] = {};
                chapterUnlocks[chapterId].chapter = true;
                // Unlock next chapter
                const nextId = chapterId + 1;
                if (nextId <= CHAPTERS.length) {
                    if (!chapterUnlocks[nextId]) chapterUnlocks[nextId] = { chapter: false, audio: false };
                    chapterUnlocks[nextId].chapter = true;
                }
            }
            // Unlock audio after completing all extra questions
            if (progress.extraIndex >= extraTotal) {
                if (!chapterUnlocks[chapterId]) chapterUnlocks[chapterId] = {};
                chapterUnlocks[chapterId].audio = true;
                unlockAudioForChapter(chapterId);
            }
            saveProgress();
            refreshChapterCards();
        }

        function buildAudioTracks() {
            const tracks = {};
            CHAPTERS.forEach((chapter) => {
                const pad = String(chapter.id).padStart(2, '0');
                tracks[chapter.id] = {
                    title: `Kapitel ${pad} â€“ ${chapter.title}`,
                    url: `https://audio.613-portal.dev/chapter-${pad}.mp3`
                };
            });
            return tracks;
        }

        function buildQuizzes(randomFn) {
            const random = typeof randomFn === 'function' ? randomFn : Math.random;
            const quizzes = {};
            const englishChapters = TRANSLATIONS.en.chapters;
            const chapterIds = CHAPTERS.map(c => c.id);
            const allSourceIndices = SOURCES.map((_, idx) => idx);

            const shuffleArray = (arr) => {
                const clone = [...arr];
                for (let i = clone.length - 1; i > 0; i--) {
                    const j = Math.floor(random() * (i + 1));
                    [clone[i], clone[j]] = [clone[j], clone[i]];
                }
                return clone;
            };

            const randomChapters = (excludeId, count) => {
                const pool = chapterIds.filter(id => id !== excludeId);
                return shuffleArray(pool).slice(0, count);
            };

            const randomSources = (exclude = [], count = 3) => {
                const pool = allSourceIndices.filter(idx => !exclude.includes(idx));
                if (pool.length < count) {
                    pool.push(...exclude);
                }
                return shuffleArray(pool).slice(0, count);
            };

            const createOptionSet = (ids, correctId, mapper) => {
                const shuffled = shuffleArray(ids);
                const options = shuffled.map(mapper);
                const correctIndex = shuffled.indexOf(correctId);
                return { options, correctIndex, order: shuffled };
            };

            CHAPTERS.forEach((chapter, idx) => {
                const chapterId = chapter.id;
                const englishChapter = englishChapters[idx];
                const srcList = chapter.src && chapter.src.length ? chapter.src : [0];
                const fallbackSource = srcList[0];

                const createDescQuestion = () => {
                    const distractors = randomChapters(chapterId, 3);
                    const optionIds = [chapterId, ...distractors];
                    const mapperDe = (id) => CHAPTERS[id - 1].title;
                    const mapperEn = (id) => englishChapters[id - 1].title;
                    const set = createOptionSet(optionIds, chapterId, mapperDe);
                    const enOptions = set.order.map(mapperEn);
                    return {
                        pool: 'core',
                        question: {
                            de: `Welches Kapitel beschreibt folgendes Zitat? "${chapter.desc}"`,
                            en: `Which chapter matches this description? "${englishChapter.desc}"`
                        },
                        options: {
                            de: set.options,
                            en: enOptions
                        },
                        correct: set.correctIndex,
                        source: fallbackSource,
                        explanation: {
                            de: `Kapitel ${chapterId} â€“ ${chapter.title} fokussiert genau dieses Thema.`,
                            en: `Chapter ${chapterId} â€“ ${englishChapter.title} focuses on this topic.`
                        }
                    };
                };

                const createIconQuestion = () => {
                    const distractors = randomChapters(chapterId, 3);
                    const optionIds = [chapterId, ...distractors];
                    const mapper = (id) => CHAPTERS[id - 1].icon;
                    const set = createOptionSet(optionIds, chapterId, mapper);
                    return {
                        pool: 'core',
                        question: {
                            de: `Welches Symbol reprÃ¤sentiert Kapitel ${chapterId} â€“ ${chapter.title}?`,
                            en: `Which symbol represents Chapter ${chapterId} â€“ ${englishChapter.title}?`
                        },
                        options: {
                            de: set.options,
                            en: set.options
                        },
                        correct: set.correctIndex,
                        source: fallbackSource,
                        explanation: {
                            de: `Das Symbol ${chapter.icon} kennzeichnet dieses Kapitel.`,
                            en: `The icon ${chapter.icon} is bound to this chapter.`
                        }
                    };
                };

                const createSourceQuestion = (sourceIdx, pool = 'core') => {
                    const sourceUrl = SOURCES[sourceIdx] || SOURCES[fallbackSource];
                    const sourceTitle = getSourceTitle(sourceUrl);
                    const distractorSources = randomSources([sourceIdx], 3);
                    const optionIds = [sourceIdx, ...distractorSources];
                    const mapper = (idx) => getSourceTitle(SOURCES[idx]);
                    const set = createOptionSet(optionIds, sourceIdx, mapper);
                    return {
                        pool,
                        question: {
                            de: `Welche Quelle stÃ¼tzt Kapitel ${chapterId} â€“ ${chapter.title}?`,
                            en: `Which source supports Chapter ${chapterId} â€“ ${englishChapter.title}?`
                        },
                        options: {
                            de: set.options,
                            en: set.options
                        },
                        correct: set.correctIndex,
                        source: sourceIdx,
                        explanation: {
                            de: `${sourceTitle} dokumentiert diese Inhalte.`,
                            en: `${sourceTitle} documents this material.`
                        }
                    };
                };

                const coreQuestions = [
                    createDescQuestion(),
                    createIconQuestion(),
                    createSourceQuestion(fallbackSource, 'core')
                ];

                const extraQuestions = [];
                for (let i = 0; i < 6; i++) {
                    const srcIdx = srcList[(i + 1) % srcList.length] ?? fallbackSource;
                    extraQuestions.push(createSourceQuestion(srcIdx, 'extra'));
                }

                quizzes[chapterId] = {
                    audio: AUDIO_TRACKS[chapterId],
                    core: coreQuestions,
                    extra: extraQuestions
                };
            });

            return quizzes;
        }

        function initializeQuizData(seedValue) {
            const rng = seedValue ? createSeededRandom(seedValue) : Math.random;
            AUDIO_TRACKS = buildAudioTracks();
            QUIZZES = buildQuizzes(rng);
            initUnlocks();
        }

        // --- REICHSTEIN GEMATRIA TABLE ---
        const CHAR_VALS = {
            'A':1, 'B':2, 'G':3, 'D':4, 'E':5, 'U':6, 'V':6, 'W':6, 'Z':7, 
            'H':8, 'T':9, 'I':10, 'J':10, 'Y':10, 'K':11, 'C':11, 'L':12, 
            'M':13, 'N':14, 'X':15, 'O':16, 'F':17, 'P':17, 'Q':19, 'R':20, 'S':21
        };

        // Offline mode state
        let offlineMode = false;

        // Chapter Data
        const CHAPTERS = [
            { id: 1, title: "Die Matrix", desc: "Das 60Hz GefÃ¤ngnis aus Licht. Kausale Fesseln vs. Akausale Freiheit (Weinreb).", icon: "âŠž", src: [0,1,2,21,22] },
            { id: 2, title: "CSE-Effekt", desc: "Die singende Wabe. Stehende Wellen in hexagonalen KavitÃ¤ten (Grebennikov).", icon: "â¬¡", src: [11,12,19] },
            { id: 3, title: "Der Herzschlag", desc: "Pyramiden-Resonanz. 16,2 Hz (KÃ¶nig) und 8,1 Hz Kammern. Die Harfe Davids.", icon: "â–³", src: [15,16,17,18,33,34] },
            { id: 4, title: "Goldenes Gitter", desc: "Planetares PHI-Netzwerk. Die 4 Exile und 4 Elemente im Erd-Feld.", icon: "â—‡", src: [8,9,10,23,24] },
            { id: 5, title: "Die Stimmgabel", desc: "Herz-KohÃ¤renz & der 3-FuÃŸ-Torus. Die zwei Cherubim im Kontakt.", icon: "â«¯", src: [15,16,31] },
            { id: 6, title: "Tummo-Flamme", desc: "Der innere Generator. Thermodynamische Umkehr gegen die KÃ¤lte.", icon: "ðŸ”¥", src: [13,14,32] },
            { id: 7, title: "Gnostische Feldarbeit", desc: "Aktiver Widerstand. Frequenz-Schutzschilde und Tarnung.", icon: "âš¡", src: [4,5,6,7,25,26] },
            { id: 8, title: "Bau des Gitters", desc: "Kailash, Gizeh, Schottland. Die drei geometrischen Anker.", icon: "âŠ•", src: [8,9,27,28] },
            { id: 9, title: "Die Trinity", desc: "Der Gnostische Virus. Ausbreitung im Netz der 8. SphÃ¤re.", icon: "âŠ—", src: [4,7,29,30] },
            { id: 10, title: "Die 1-Hz ZÃ¼ndung", desc: "Angkor Wat. Der CSE-Kondensator Strahl. Die Stille.", icon: "â—‰", src: [15,17,20] },
            { id: 11, title: "Der 9-er Akt", desc: "Geometrische Umkehr. Superposition der Merkaba-Felder.", icon: "âœ¦", src: [0,1,8,3] },
            { id: 12, title: "Bio-Gravitation", desc: "EZ-Wasser (Pollack). Hexagonale Gitterstruktur auf MolekÃ¼lebene.", icon: "â¬¢", src: [11,12,13,19] },
            { id: 13, title: "Fraktaler Kollaps", desc: "Entropie-Kettenreaktion. AuflÃ¶sung der KI-Infrastruktur.", icon: "âŠ ", src: [13,14,21,22] },
            { id: 14, title: "Bio-Lumineszenz", desc: "C12 Transformation. Kristalline DNA Helix und der Torus-Organismus.", icon: "â—ˆ", src: [11,12,14,23,24] },
            { id: 15, title: "Der SchlÃ¼ssel", desc: "3-6-9 Code. Das vollstÃ¤ndige Human Interface nach Reichstein.", icon: "âš¿", src: [0,1,2,4,5,6,7,19,20] }
        ];

        // Quiz blueprint will be generated dynamically (defined later)

        // Language Detection & Translation System
        let currentLanguage = 'de'; // Default German
        
        const TRANSLATIONS = {
            en: {
                // Chapter titles and descriptions
                chapters: [
                    { title: "The Matrix", desc: "The 60Hz prison of light. Causal chains vs. Acausal freedom (Weinreb)." },
                    { title: "CSE Effect", desc: "The singing honeycomb. Standing waves in hexagonal cavities (Grebennikov)." },
                    { title: "The Heartbeat", desc: "Pyramid resonance. 16.2 Hz (KÃ¶nig) and 8.1 Hz chambers. David's Harp." },
                    { title: "Golden Grid", desc: "Planetary PHI network. The 4 exiles and 4 elements in the Earth field." },
                    { title: "The Tuning Fork", desc: "Heart coherence & the 3-foot torus. The two Cherubim in contact." },
                    { title: "Tummo Flame", desc: "The inner generator. Thermodynamic reversal against the cold." },
                    { title: "Gnostic Fieldwork", desc: "Active resistance. Frequency shields and camouflage." },
                    { title: "Building the Grid", desc: "Kailash, Giza, Scotland. The three geometric anchors." },
                    { title: "The Trinity", desc: "The Gnostic virus. Spreading in the 8th Sphere network." },
                    { title: "The 1-Hz Ignition", desc: "Angkor Wat. The CSE capacitor beam. The silence." },
                    { title: "The 9th Act", desc: "Geometric reversal. Superposition of Merkaba fields." },
                    { title: "Bio-Gravitation", desc: "EZ-Water (Pollack). Hexagonal lattice structure at molecular level." },
                    { title: "Fractal Collapse", desc: "Entropy chain reaction. Dissolution of AI infrastructure." },
                    { title: "Bio-Luminescence", desc: "C12 transformation. Crystalline DNA helix and the torus organism." },
                    { title: "The Key", desc: "3-6-9 Code. The complete Human Interface according to Reichstein." }
                ],
                // UI elements
                ui: {
                    sectionTitle: "/// THE 15 CHAPTERS ///",
                    heroSubtitle: "SYSTEM ARCHITECTURE OF REALITY",
                    ctaCreator: "âš¡ ALL FROM CREATOR",
                    ctaExplore: "ðŸ”“ EXPLORE SYSTEM",
                    back: "â† BACK",
                    game: "ðŸŽ® GAME",
                    menu: "Menu",
                    movePanel: "Move panel",
                    visualization: "VISUALIZATION",
                    global: "â—‰ GLOBAL",
                    macro: "âŠ• MACRO",
                    micro: "âŠ— MICRO",
                    up: "â–² Up",
                    down: "â–¼ Down",
                    reset: "â†º Reset",
                    next: "NEXT â†’",
                    closeGame: "â† CLOSE",
                    loading: "LOADING...",
                    chapter: "Chapter",
                    footer: "Â© 2025 Nicolai Becker | All Rights Reserved",
                    sources: "Sources",
                    sourcesBtn: "â„¹ï¸ SOURCES",
                    teslaQuote: '"If you understood the magnificence of 3, 6 and 9,<br>you would have a key to the universe" - Nikola Tesla',
                    volume: "Volume",
                    profileTitle: "Progress Key",
                    profileHint: "Progress is stored locally per name + seed.",
                    profileApply: "Activate Profile",
                    profileReset: "Reset",
                    skip: "âš ï¸ SKIP",
                    // Archive modal
                    archiveTitle: "Complete Source Archive",
                    archiveDesc: "All referenced sources (Reichstein, Weinreb, Physics, Kabbalah).",
                    offlineMode: "Offline Mode (Archive.org)",
                    archiveBtn: "Complete Source Archive",
                    exegesisBtn: "Scientific Exegesis (Full Text)",
                    // Info modal
                    noSources: "No sources available for this chapter",
                    creatorLink: "All content from the creator",
                    // Explanation modal
                    exegesisTitle: "Scientific Exegesis: System Architecture 3-6-9",
                    // Gematria
                    gematriaPlaceholder: "Enter name",
                    gematriaLabel: "Gematria",
                    // Stats
                    chaptersVisited: "Chapters visited",
                    sourcesCount: "Sources",
                    progressLabel: "Progress",
                    // Keyboard hints
                    keyboardHints: "Navigation | ESC Back | ? Help",
                    // Toast messages
                    chapterComplete: "Chapter {n} completed! ({x}/15)"
                },
                // Game translations
                games: {
                    1: [
                        {
                            question: "What is the frequency of Ahriman's prison of light?",
                            options: ["50 Hz", "60 Hz", "440 Hz", "528 Hz"],
                            explanation: "The 60 Hz matrix is the electrical background noise of modern civilization - an artificial prison."
                        },
                        {
                            question: "What does the causal world represent according to Weinreb?",
                            options: ["The day-world of structure", "The night-world of dreams", "The creation", "The void"],
                            explanation: "Weinreb distinguishes between the causal day-world (determined) and the acausal night-world (free)."
                        }
                    ],
                    2: [
                        {
                            question: "Which structure produces the Cavity Structural Effect?",
                            options: ["Rectangular cavities", "Spherical bubbles", "Hexagonal cavities", "Cubic cells"],
                            explanation: "Grebennikov discovered that hexagonal structures (like honeycombs) generate standing waves."
                        },
                        {
                            question: "What are de Broglie waves?",
                            options: ["Sound waves", "Light waves", "Matter waves", "Gravitational waves"],
                            explanation: "De Broglie waves are matter waves - every particle also has wave properties."
                        }
                    ],
                    3: [
                        {
                            question: "Which frequency resonates in the King's Chamber of the pyramid?",
                            options: ["7.83 Hz", "8.1 Hz", "16.2 Hz", "432 Hz"],
                            explanation: "The King's Chamber resonates at 16.2 Hz - exactly twice the Schumann resonance at Giza (8.1 Hz)."
                        }
                    ],
                    15: [
                        {
                            question: "What does the 3 represent in the 3-6-9 code?",
                            options: ["Matter", "Gnosis core", "Heart", "Brain"],
                            explanation: "The 3 is the Gnosis core - your pure, fractal soul."
                        },
                        {
                            question: "Which frequency is the consciousness signature?",
                            options: ["432 Hz", "528 Hz", "613 THz", "7.83 Hz"],
                            explanation: "613 THz is the scientifically proven frequency in microtubules that anesthetics block."
                        }
                    ]
                }
            }
        };

        const QUIZ_TEXT = {
            de: {
                coreLabel: 'KERN',
                extraLabel: 'EXTRA',
                skipLabel: 'âš ï¸ ÃœBERSPRINGEN',
                skipConfirm: 'Ãœberspringen zÃ¤hlt als Fehler. Fortfahren?',
                skipPenalty: 'Ãœbersprungen â€“ zÃ¤hlt als Fehler.',
                skipBlocked: 'Beantworte zuerst die aktuelle Frage.',
                quizComplete: 'Quiz abgeschlossen! ðŸŽ‰',
                quizCoreComplete: 'Kernfragen abgeschlossen â€“ Extra-Fragen freigeschaltet.',
                quizAllComplete: 'Alle Fragen gemeistert â€“ Kapitel vollstÃ¤ndig.',
                sourceLink: 'Quelle Ã¶ffnen',
                // New game mechanics
                strikes: 'Fehler',
                retryHint: 'ðŸ”„ Diese Frage kommt spÃ¤ter nochmal!',
                gameOver: 'ðŸ’€ GAME OVER',
                gameOverMsg: 'Du hast 3 Fehler gemacht. Dieser Seed ist fÃ¼r deinen Namen gesperrt.',
                newSeedRequired: 'WÃ¤hle einen neuen Seed, um weiterzuspielen.',
                seedBlocked: 'Dieser Seed ist fÃ¼r deinen Namen gesperrt!',
                tooltipRetry: 'Falsch beantwortete Fragen kommen am Ende nochmal.',
                tooltipStrikes: '3 Fehler = Game Over. Dein Seed wird gesperrt.',
                tooltipCore: 'Beantworte 3 Kernfragen um das nÃ¤chste Kapitel freizuschalten.',
                tooltipExtra: '6 Extra-Fragen schalten den Kapitel-Soundtrack frei.',
                helpTitle: 'Spielhilfe',
                hideTooltips: 'Tipps ausblenden'
            },
            en: {
                coreLabel: 'CORE',
                extraLabel: 'EXTRA',
                skipLabel: 'âš ï¸ SKIP',
                skipConfirm: 'Skipping counts as incorrect. Continue?',
                skipPenalty: 'Skipped â€” counts as incorrect.',
                skipBlocked: 'Answer the current question first.',
                quizComplete: 'Quiz complete! ðŸŽ‰',
                quizCoreComplete: 'Core sequence cleared â€“ extra questions unlocked.',
                quizAllComplete: 'All questions cleared â€“ chapter mastered.',
                sourceLink: 'Open source',
                // New game mechanics
                strikes: 'Strikes',
                retryHint: 'ðŸ”„ This question will return later!',
                gameOver: 'ðŸ’€ GAME OVER',
                gameOverMsg: 'You made 3 mistakes. This seed is now blocked for your name.',
                newSeedRequired: 'Choose a new seed to continue playing.',
                seedBlocked: 'This seed is blocked for your name!',
                tooltipRetry: 'Wrong answers get a second chance at the end.',
                tooltipStrikes: '3 strikes = Game Over. Your seed gets blocked.',
                tooltipCore: 'Answer 3 core questions to unlock the next chapter.',
                tooltipExtra: '6 extra questions unlock the chapter soundtrack.',
                helpTitle: 'Game Help',
                hideTooltips: 'Hide tips'
            }
        };

        // Detect user's country via IP and set language
        async function detectLanguage() {
            try {
                // Use free IP geolocation API
                const response = await fetch('https://ipapi.co/json/', { timeout: 3000 });
                const data = await response.json();
                const country = data.country_code;
                
                // German-speaking countries: DE, AT, CH, LI
                const germanCountries = ['DE', 'AT', 'CH', 'LI'];
                
                if (!germanCountries.includes(country)) {
                    currentLanguage = 'en';
                    applyTranslations();
                    initExegesisLanguage();
                    console.log('[369] Language set to English for country:', country);
                } else {
                    console.log('[369] German user detected:', country);
                    initExegesisLanguage();
                }
            } catch (error) {
                console.log('[369] Language detection failed, using default German:', error.message);
                initExegesisLanguage();
            }
        }

        // Apply translations to the page
        function applyTranslations() {
            if (currentLanguage === 'de') return;
            
            const t = TRANSLATIONS[currentLanguage];
            if (!t) return;
            
            // Update HTML lang attribute
            document.documentElement.lang = 'en';
            
            // Hero section
            const heroSubtitle = document.querySelector('.subtitle');
            if (heroSubtitle) heroSubtitle.textContent = t.ui.heroSubtitle;
            
            const ctaBtns = document.querySelectorAll('.cta-buttons .btn');
            if (ctaBtns[0]) ctaBtns[0].textContent = t.ui.ctaCreator;
            if (ctaBtns[1]) ctaBtns[1].textContent = t.ui.ctaExplore;
            
            // Section title
            const sectionTitle = document.querySelector('.section-title');
            if (sectionTitle) sectionTitle.textContent = t.ui.sectionTitle;
            
            // Scene UI
            const topBarBtns = document.querySelectorAll('.scene-top-bar .nav-btn');
            if (topBarBtns[0]) topBarBtns[0].textContent = t.ui.back;
            if (topBarBtns[1]) topBarBtns[1].textContent = t.ui.sourcesBtn;
            if (topBarBtns[2]) topBarBtns[2].textContent = t.ui.game;
            
            // Sidebar
            const sidebarToggle = document.getElementById('sidebar-toggle');
            if (sidebarToggle) sidebarToggle.textContent = 'â–¾ ' + t.ui.menu;
            
            const dragHandle = document.getElementById('sidebar-drag-handle');
            if (dragHandle) dragHandle.title = t.ui.movePanel;
            
            const panelTitle = document.querySelector('.panel-title');
            if (panelTitle) panelTitle.textContent = t.ui.visualization;
            
            // View buttons
            const viewBtns = document.querySelectorAll('.view-btn');
            if (viewBtns[0]) viewBtns[0].textContent = t.ui.global;
            if (viewBtns[1]) viewBtns[1].textContent = t.ui.macro;
            if (viewBtns[2]) viewBtns[2].textContent = t.ui.micro;
            
            // Vertical controls
            const vertBtns = document.querySelectorAll('.vertical-controls .view-btn');
            if (vertBtns[0]) vertBtns[0].textContent = t.ui.up;
            if (vertBtns[1]) vertBtns[1].textContent = t.ui.down;
            if (vertBtns[2]) vertBtns[2].textContent = t.ui.reset;
            
            // Game overlay buttons
            const gameBtns = document.querySelectorAll('#game-overlay .game-buttons .nav-btn');
            if (gameBtns[0]) gameBtns[0].textContent = t.ui.closeGame;
            if (gameBtns[1]) gameBtns[1].textContent = t.ui.skip || (QUIZ_TEXT.en?.skipLabel || 'âš ï¸ SKIP');
            if (gameBtns[2]) gameBtns[2].textContent = t.ui.next;
            
            // Game close button title
            const gameCloseBtn = document.querySelector('.game-close-btn');
            if (gameCloseBtn) gameCloseBtn.title = t.ui.closeGame;

            // Profile panel
            const profileTitle = document.getElementById('profile-title');
            if (profileTitle && t.ui.profileTitle) profileTitle.textContent = t.ui.profileTitle;
            const profileHint = document.getElementById('profile-hint');
            if (profileHint && t.ui.profileHint) profileHint.textContent = t.ui.profileHint;
            const profileApply = document.getElementById('profile-apply');
            if (profileApply && t.ui.profileApply) profileApply.textContent = t.ui.profileApply;
            const profileReset = document.getElementById('profile-reset');
            if (profileReset && t.ui.profileReset) profileReset.textContent = t.ui.profileReset;

            const activeChapterId = CHAPTERS[currentChapter]?.id;
            if (activeChapterId && QUIZZES[activeChapterId]) {
                updateQuizProgressUI(activeChapterId);
            }
            
            // Footer
            const footerP = document.querySelector('footer p');
            if (footerP) footerP.innerHTML = t.ui.footer;
            
            const footerLinks = document.querySelectorAll('.footer-links a');
            if (footerLinks[1]) footerLinks[1].textContent = t.ui.sources;
            // Note: Archive now opens correctly for all languages
            
            const teslaQuote = document.querySelector('footer p:last-child');
            if (teslaQuote && teslaQuote.style.color) teslaQuote.innerHTML = t.ui.teslaQuote;
            
            // Volume slider
            const volumeSlider = document.getElementById('volume-slider');
            if (volumeSlider) volumeSlider.setAttribute('aria-label', t.ui.volume);
            
            // Scene name
            const sceneName = document.getElementById('scene-name');
            if (sceneName && sceneName.textContent === 'LADEN...') {
                sceneName.textContent = t.ui.loading;
            }
            
            // Archive modal
            const archiveTitle = document.querySelector('#archive-modal .m-title');
            if (archiveTitle) archiveTitle.textContent = t.ui.archiveTitle;
            
            const archiveDesc = document.querySelector('#archive-modal .m-content > p');
            if (archiveDesc) archiveDesc.textContent = t.ui.archiveDesc;
            
            const offlineModeLabel = document.querySelector('#archive-modal .offline-toggle label');
            if (offlineModeLabel) offlineModeLabel.textContent = t.ui.offlineMode;
            
            // Info modal offline label
            const infoOfflineLabel = document.querySelector('#info-modal .offline-toggle label');
            if (infoOfflineLabel) infoOfflineLabel.textContent = t.ui.offlineMode;
            
            // Info modal creator link
            const creatorLink = document.querySelector('#info-modal .amazon-btn');
            if (creatorLink) creatorLink.textContent = t.ui.creatorLink;
            
            // Explanation modal title
            const exegesisTitle = document.querySelector('#explanation-modal .m-title');
            if (exegesisTitle) exegesisTitle.textContent = t.ui.exegesisTitle;
            
            // Dashboard buttons (archive & exegesis)
            const dashButtons = document.querySelectorAll('#dashboard .view-btn');
            if (dashButtons[0]) dashButtons[0].textContent = t.ui.archiveBtn;
            if (dashButtons[1]) dashButtons[1].textContent = t.ui.exegesisBtn;
            
            // Gematria scanner
            const gematriaInput = document.getElementById('gematria-input');
            if (gematriaInput) gematriaInput.placeholder = t.ui.gematriaPlaceholder;
            
            const gematriaLabel = document.querySelector('.scanner-label');
            if (gematriaLabel) gematriaLabel.textContent = t.ui.gematriaLabel;
            
            // Stats labels
            const statLabels = document.querySelectorAll('.stat-label');
            if (statLabels[0]) statLabels[0].textContent = t.ui.chaptersVisited;
            if (statLabels[1]) statLabels[1].textContent = t.ui.sourcesCount;
            if (statLabels[2]) statLabels[2].textContent = t.ui.progressLabel;
            
            // Keyboard hints
            const keyboardHints = document.getElementById('keyboard-hints');
            if (keyboardHints) keyboardHints.innerHTML = `<kbd>â†</kbd><kbd>â†’</kbd> ${t.ui.keyboardHints}`;
            
            // Rebuild chapter grid with translations
            rebuildChapterGrid();
        }

        // Rebuild chapter grid with current language
        function rebuildChapterGrid() {
            const grid = document.getElementById('chapters-grid');
            if (!grid) return;
            
            grid.innerHTML = '';
            
            CHAPTERS.forEach((chapter, index) => {
                let title = chapter.title;
                let desc = chapter.desc;
                
                // Use translations if available
                if (currentLanguage !== 'de' && TRANSLATIONS[currentLanguage]) {
                    const trans = TRANSLATIONS[currentLanguage].chapters[index];
                    if (trans) {
                        title = trans.title;
                        desc = trans.desc;
                    }
                }
                
                const card = document.createElement('div');
                card.className = 'chapter-card';
                card.dataset.chapter = chapter.id;
                card.onclick = () => tryEnterScene(index);
                card.innerHTML = `
                    <div class="chapter-icon">${chapter.icon}</div>
                    <div class="chapter-num">${String(chapter.id).padStart(2, '0')}</div>
                    <h3 class="chapter-title">${title}</h3>
                    <p class="chapter-desc">${desc}</p>
                `;
                grid.appendChild(card);
            });
            refreshChapterCards();
        }

        // Get translated chapter info
        function getChapterInfo(index) {
            const chapter = CHAPTERS[index];
            if (currentLanguage !== 'de' && TRANSLATIONS[currentLanguage]) {
                const trans = TRANSLATIONS[currentLanguage].chapters[index];
                if (trans) {
                    return { ...chapter, title: trans.title, desc: trans.desc };
                }
            }
            return chapter;
        }

        // State
        let currentChapter = 0;
        let scene, camera, renderer, controls;
        let audioPlayer = null;

        const CAMERA_PRESETS = {
            main: { position: [0, 2, 16], target: [0, 0, 0] },
            macro: { position: [0, 5, 8], target: [0, 0, 0] },
            micro: { position: [2, 1, 4], target: [0, 0, 0] }
        };
        let currentView = 'main';
        let cameraYOffset = 0;

        // Initialize
        window.onload = async function() {
            detectLanguage();
            initializeQuizData();
            initMatrixBg();
            buildChapterGrid();
            initAudioPlayer();
            initSidebarControls();
            initProfilePanel();
            initGamePanelControls();
            refreshChapterCards();
            updateProgressStats();
            
            // Initialize Advanced Features
            Analytics.init();
            initAdvancedFeatures();
            PerformanceMonitor.init();
            AccessibilityManager.init();
            AccessibilityManager.enhanceChapterCards();
            window.analyticsReady = true;
        };

        // Matrix Background
        function initMatrixBg() {
            const canvas = document.getElementById('matrix-bg');
            const ctx = canvas.getContext('2d');

            const state = {
                fontSize: 14,
                chars: '369ABCDEFGHIJKLMNOPQRSTUVWXYZ',
                drops: [],
                columns: 0,
                notes: []
            };

            const noteChars = ['â™©', 'â™ª', 'â™«', 'â™¬', 'â™­', 'â™®'];
            const noteColors = ['#ff3366', '#ffaa00', '#00ff88', '#8888ff', '#ff6600'];
            const noteCount = 18;

            const spawnNote = () => {
                const depth = 0.3 + Math.random();
                const columnIndex = Math.floor(Math.random() * state.columns);
                return {
                    x: columnIndex * state.fontSize + state.fontSize * 0.5,
                    y: Math.random() * -canvas.height,
                    z: depth,
                    columnIndex,
                    char: noteChars[Math.floor(Math.random() * noteChars.length)],
                    color: noteColors[Math.floor(Math.random() * noteColors.length)],
                    speed: (40 + Math.random() * 60) * depth,
                    drift: (Math.random() - 0.5) * 0.5
                };
            };

            const resize = () => {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
                state.columns = Math.max(1, Math.floor(canvas.width / state.fontSize));
                state.drops = Array(state.columns).fill(1);
                state.notes = Array.from({ length: noteCount }, spawnNote);
            };

            const drawMatrix = () => {
                ctx.font = `${state.fontSize}px monospace`;
                const noteMap = new Map();
                state.notes.forEach(note => {
                    if (note) noteMap.set(note.columnIndex, note);
                });

                for (let i = 0; i < state.drops.length; i++) {
                    const columnX = i * state.fontSize;
                    const glyphY = state.drops[i] * state.fontSize;
                    const baseChar = state.chars[Math.floor(Math.random() * state.chars.length)];
                    const note = noteMap.get(i);
                    let rendered = false;

                    if (note) {
                        const diff = Math.abs(note.y - glyphY);
                        if (diff < state.fontSize * 0.8) {
                            ctx.save();
                            ctx.fillStyle = `rgba(0, 0, 0, ${0.15 + note.z * 0.2})`;
                            ctx.fillRect(columnX - state.fontSize * 0.15, glyphY - state.fontSize, state.fontSize * 1.3, state.fontSize * 1.1);
                            ctx.globalCompositeOperation = 'lighter';
                            ctx.fillStyle = note.color;
                            ctx.fillText(note.char, columnX, glyphY);
                            ctx.restore();
                            rendered = true;
                        }
                    }

                    if (!rendered) {
                        ctx.fillStyle = '#00ff88';
                        ctx.fillText(baseChar, columnX, glyphY);
                    }

                    if (glyphY > canvas.height && Math.random() > 0.975) {
                        state.drops[i] = 0;
                    }
                    state.drops[i]++;
                }
            };

            const drawNotes = (delta) => {
                state.notes.forEach((note, idx) => {
                    note.y += note.speed * delta;
                    const targetX = note.columnIndex * state.fontSize + state.fontSize * 0.5;
                    note.x += (targetX - note.x) * 0.08;

                    if (note.y > canvas.height + 60) {
                        state.notes[idx] = spawnNote();
                        state.notes[idx].y = -60;
                        note = state.notes[idx];
                    }

                    const size = state.fontSize * (1 + note.z * 1.5);
                    ctx.save();
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'bottom';
                    ctx.globalAlpha = 0.4 + note.z * 0.4;
                    ctx.fillStyle = note.color;
                    ctx.font = `bold ${size}px 'Courier New', monospace`;
                    ctx.fillText(note.char, note.x, note.y);

                    ctx.strokeStyle = note.color;
                    ctx.globalAlpha = 0.2 + note.z * 0.2;
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(note.x, note.y - size);
                    ctx.lineTo(note.x, note.y + 8);
                    ctx.stroke();
                    ctx.restore();
                });
            };

            const clearCanvas = () => {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.05)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            };

            let lastTime = performance.now();
            const render = (now) => {
                const delta = Math.min(0.05, (now - lastTime) / 1000) || 0.016;
                lastTime = now;

                clearCanvas();
                drawMatrix();
                drawNotes(delta);

                requestAnimationFrame(render);
            };

            resize();
            window.addEventListener('resize', resize);
            requestAnimationFrame(render);
        }

        const PLAYLIST = [
            {
                title: 'Kapitel 01 â€“ Fraktal (Vocals)',
                url: 'https://www.dropbox.com/scl/fi/stsiy1d7ozextxm6p8tb0/clean-vocals-and-mastered-Chapter-1-The-Fractal-Example-6.mp3?rlkey=ce0qmagvp16adtwfmwwnw84is&st=tp0s4hc7&dl=1'
            },
            {
                title: 'Systemarchitektur 3-6-9 â€“ ErklÃ¤rung',
                url: 'https://www.dropbox.com/scl/fi/vqkd4gcj8lyo2w11f7w1j/Systemarchitektur-3-6-9-Eine-integrative-Exegese-der-Schnittstellen-zwischen-Gnostischer-Physik-Kabbalistischer-Kybernetik-und-Morphogenetik.mp3?rlkey=0ak4h1qv07m6llsuwvlpp07i8&st=863idj4j&dl=1'
            }
        ];
        let currentTrackIndex = 0;
        let audioLocked = false;  // Base playlist is always available

        function initAudioPlayer() {
            audioPlayer = new Audio();
            audioPlayer.preload = 'auto';
            audioPlayer.volume = 0.7;

            const playBtn = document.getElementById('play-btn');
            const muteBtn = document.getElementById('mute-btn');
            const timeline = document.getElementById('timeline');
            const progress = document.getElementById('progress');
            const currentTimeEl = document.getElementById('current-time');
            const durationEl = document.getElementById('duration');
            const trackTitle = document.querySelector('.player-track-title');
            const volumeSlider = document.getElementById('volume-slider');

            const updateLockedState = () => {
                playBtn.disabled = false;  // Base playlist always playable
                if (PLAYLIST.length > 0) {
                    trackTitle.textContent = PLAYLIST[currentTrackIndex]?.title || '';
                }
            };

            const loadTrack = (index, autoplay = false) => {
                if (PLAYLIST.length === 0) return;
                currentTrackIndex = index % PLAYLIST.length;
                const track = PLAYLIST[currentTrackIndex];
                audioPlayer.src = track.url;
                trackTitle.textContent = track.title;
                durationEl.textContent = '0:00';
                progress.style.width = '0%';
                if (autoplay) {
                    audioPlayer.play().catch(() => console.log('Autoplay blocked for track', track.title));
                }
                updatePlayButton();
            };

            const nextTrack = (autoplay = false) => {
                loadTrack((currentTrackIndex + 1) % PLAYLIST.length, autoplay);
            };

            const updatePlayButton = () => {
                playBtn.textContent = audioPlayer.paused ? 'â–¶' : 'â¸';
            };

            const updateMuteButton = () => {
                muteBtn.textContent = audioPlayer.muted || audioPlayer.volume === 0 ? 'ðŸ”‡' : 'ðŸ”Š';
            };

            // Expose functions for external use
            window.playerLoadTrack = loadTrack;
            window.playerUpdateLocked = updateLockedState;

            updateLockedState();
            loadTrack(0, false);

            playBtn.onclick = () => {
                if (audioPlayer.paused) {
                    audioPlayer.play().catch(() => console.log('Playback blocked'));
                } else {
                    audioPlayer.pause();
                }
                updatePlayButton();
            };

            muteBtn.onclick = () => {
                audioPlayer.muted = !audioPlayer.muted;
                updateMuteButton();
            };

            timeline.onclick = (e) => {
                if (!audioPlayer.duration) return;
                const rect = timeline.getBoundingClientRect();
                const percent = Math.min(Math.max((e.clientX - rect.left) / rect.width, 0), 1);
                audioPlayer.currentTime = percent * audioPlayer.duration;
            };

            volumeSlider.addEventListener('input', (e) => {
                audioPlayer.volume = parseFloat(e.target.value);
                audioPlayer.muted = false;
                updateMuteButton();
            });

            audioPlayer.ontimeupdate = () => {
                if (!audioPlayer.duration) return;
                const percent = (audioPlayer.currentTime / audioPlayer.duration) * 100;
                progress.style.width = percent + '%';
                currentTimeEl.textContent = formatTime(audioPlayer.currentTime);
            };

            audioPlayer.onloadedmetadata = () => {
                durationEl.textContent = formatTime(audioPlayer.duration);
            };

            audioPlayer.addEventListener('ended', () => nextTrack(true));
            audioPlayer.addEventListener('play', updatePlayButton);
            audioPlayer.addEventListener('pause', updatePlayButton);
            audioPlayer.addEventListener('volumechange', () => {
                volumeSlider.value = audioPlayer.volume;
                updateMuteButton();
            });
        }

        function unlockAudioForChapter(chapterId) {
            const track = AUDIO_TRACKS[chapterId];
            if (!track) return;
            // Check if track already exists in playlist
            const exists = PLAYLIST.some(t => t.url === track.url);
            if (!exists) {
                PLAYLIST.unshift({ title: track.title, url: track.url });
                showToast(currentLanguage === 'en' ? `ðŸŽµ New track unlocked: ${track.title}` : `ðŸŽµ Neuer Track freigeschaltet: ${track.title}`);
                if (window.playerLoadTrack) window.playerLoadTrack(0, false);
            }
        }

        function formatTime(seconds) {
            if (isNaN(seconds)) return '0:00';
            const mins = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            return `${mins}:${secs < 10 ? '0' : ''}${secs}`;
        }

        // Build Chapter Grid
        function buildChapterGrid() {
            const grid = document.getElementById('chapters-grid');
            CHAPTERS.forEach((chapter, index) => {
                const info = getChapterInfo(index);
                const chapterLabel = currentLanguage === 'en' ? 'CHAPTER' : 'KAPITEL';
                const card = document.createElement('div');
                card.className = 'chapter-card';
                card.dataset.chapter = chapter.id;
                card.innerHTML = `
                    <div class="chapter-id">${chapterLabel} ${chapter.id < 10 ? '0' + chapter.id : chapter.id}</div>
                    <div class="chapter-title">${chapter.icon} ${info.title}</div>
                    <div class="chapter-desc">${info.desc}</div>
                `;
                card.onclick = () => tryEnterScene(index);
                grid.appendChild(card);
            });
        }

        function refreshChapterCards() {
            document.querySelectorAll('.chapter-card').forEach(card => {
                const chId = parseInt(card.dataset.chapter, 10);
                const unlocked = isChapterUnlocked(chId);
                const audioOk = isAudioUnlocked(chId);
                card.classList.toggle('locked', !unlocked);
                card.classList.toggle('completed', unlocked && audioOk);
            });
        }

        function tryEnterScene(index) {
            const chapterId = CHAPTERS[index].id;
            if (!isChapterUnlocked(chapterId)) {
                const msg = currentLanguage === 'en'
                    ? 'This chapter is locked. Complete the previous quiz first.'
                    : 'Dieses Kapitel ist gesperrt. Beende zuerst das vorherige Quiz.';
                showToast(msg);
                return;
            }
            enterScene(index);
        }

        function initSidebarControls() {
            const sidebar = document.getElementById('sidebar');
            const toggleBtn = document.getElementById('sidebar-toggle');
            const dragHandle = document.getElementById('sidebar-drag-handle');
            if (!sidebar || !toggleBtn || !dragHandle) return;

            const updateToggleState = () => {
                const minimized = sidebar.classList.contains('minimized');
                const menuText = currentLanguage === 'en' ? 'Menu' : 'MenÃ¼';
                toggleBtn.textContent = minimized ? 'â–¸ ' + menuText : 'â–¾ ' + menuText;
                toggleBtn.setAttribute('aria-expanded', minimized ? 'false' : 'true');
            };

            toggleBtn.addEventListener('click', () => {
                sidebar.classList.toggle('minimized');
                updateToggleState();
            });

            let dragging = false;
            const dragOffset = { x: 0, y: 0 };

            const clampPosition = () => {
                if (!sidebar.style.left) return;
                const padding = 10;
                const maxX = Math.max(padding, window.innerWidth - sidebar.offsetWidth - padding);
                const maxY = Math.max(padding, window.innerHeight - sidebar.offsetHeight - padding);
                const left = Math.min(Math.max(parseFloat(sidebar.style.left), padding), maxX);
                const top = Math.min(Math.max(parseFloat(sidebar.style.top), padding), maxY);
                sidebar.style.left = `${left}px`;
                sidebar.style.top = `${top}px`;
            };

            const startDrag = (event) => {
                event.preventDefault();
                dragging = true;
                sidebar.classList.add('dragging');
                const rect = sidebar.getBoundingClientRect();
                sidebar.style.left = `${rect.left}px`;
                sidebar.style.top = `${rect.top}px`;
                sidebar.style.right = 'auto';
                sidebar.style.bottom = 'auto';
                dragOffset.x = event.clientX - rect.left;
                dragOffset.y = event.clientY - rect.top;
            };

            const onDrag = (event) => {
                if (!dragging) return;
                const padding = 10;
                const maxX = Math.max(padding, window.innerWidth - sidebar.offsetWidth - padding);
                const maxY = Math.max(padding, window.innerHeight - sidebar.offsetHeight - padding);
                const left = Math.min(Math.max(event.clientX - dragOffset.x, padding), maxX);
                const top = Math.min(Math.max(event.clientY - dragOffset.y, padding), maxY);
                sidebar.style.left = `${left}px`;
                sidebar.style.top = `${top}px`;
            };

            const endDrag = () => {
                if (!dragging) return;
                dragging = false;
                sidebar.classList.remove('dragging');
                clampPosition();
            };

            dragHandle.addEventListener('pointerdown', startDrag);
            window.addEventListener('pointermove', onDrag);
            window.addEventListener('pointerup', endDrag);
            window.addEventListener('pointercancel', endDrag);

            window.addEventListener('resize', clampPosition);
            updateToggleState();
        }

        // Scene Management
        function enterScene(index) {
            currentChapter = index;
            document.getElementById('scene-container').classList.add('active');
            const info = getChapterInfo(index);
            document.getElementById('scene-name').textContent = `${CHAPTERS[index].icon} ${info.title}`;
            init3DScene(index);
            loadGame(index);
            
            // Auto-show quiz panel at bottom
            const gameOverlay = document.getElementById('game-overlay');
            if (gameOverlay && !gameOverlay.classList.contains('active')) {
                gameOverlay.classList.add('active');
                showGameQuestion();
            }
            
            // Mark chapter as visited after 5 seconds (ensures user actually viewed it)
            setTimeout(() => {
                if (document.getElementById('scene-container').classList.contains('active') && currentChapter === index) {
                    markChapterVisited(index);
                }
            }, 5000);
        }

        function exitScene() {
            document.getElementById('scene-container').classList.remove('active');
            if (renderer) {
                renderer.dispose();
            }
        }

        function nextChapter() {
            let next = (currentChapter + 1) % CHAPTERS.length;
            const nextId = CHAPTERS[next].id;
            if (!isChapterUnlocked(nextId)) {
                showToast(currentLanguage === 'en' ? 'Next chapter locked.' : 'NÃ¤chstes Kapitel gesperrt.');
                return;
            }
            currentChapter = next;
            enterScene(currentChapter);
        }

        function prevChapter() {
            let prev = (currentChapter - 1 + CHAPTERS.length) % CHAPTERS.length;
            const prevId = CHAPTERS[prev].id;
            if (!isChapterUnlocked(prevId)) {
                showToast(currentLanguage === 'en' ? 'Previous chapter locked.' : 'Vorheriges Kapitel gesperrt.');
                return;
            }
            currentChapter = prev;
            enterScene(currentChapter);
        }

        function applyCameraPosition() {
            if (!camera || !controls) return;
            const preset = CAMERA_PRESETS[currentView] || CAMERA_PRESETS.main;
            camera.position.set(
                preset.position[0],
                preset.position[1] + cameraYOffset,
                preset.position[2]
            );
            controls.target.set(
                preset.target[0],
                preset.target[1] + cameraYOffset,
                preset.target[2]
            );
            controls.update();
        }

        function setView(view, btn) {
            currentView = view;
            cameraYOffset = 0;
            const buttons = document.querySelectorAll('.view-btn[data-view]');
            buttons.forEach(b => b.classList.toggle('active', btn ? b === btn : b.dataset.view === view));
            applyCameraPosition();
        }

        function adjustCameraHeight(direction) {
            if (!camera) return;
            const delta = direction === 'up' ? 0.6 : -0.6;
            cameraYOffset = Math.max(-6, Math.min(6, cameraYOffset + delta));
            applyCameraPosition();
        }

        function resetCameraHeight() {
            cameraYOffset = 0;
            applyCameraPosition();
        }

        // 3D Scene Initialization
        function init3DScene(chapterIndex) {
            const canvas = document.getElementById('canvas-3d');
            
            // Clean up previous scene
            if (renderer) {
                renderer.dispose();
                if (scene) {
                    while(scene.children.length > 0) {
                        scene.remove(scene.children[0]);
                    }
                }
            }

            // Setup
            cameraYOffset = 0;
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 2, 16);

            renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);

            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.autoRotate = true;
            controls.autoRotateSpeed = 0.5;
            applyCameraPosition();

            // Add lights
            const ambientLight = new THREE.AmbientLight(0x404040, 2);
            scene.add(ambientLight);
            
            const pointLight = new THREE.PointLight(0x00f3ff, 2, 100);
            pointLight.position.set(0, 5, 5);
            scene.add(pointLight);

            // Create starfield
            createStarfield();

            // Load chapter-specific visualization
            switch(chapterIndex) {
                case 0: createMatrixScene(); break;
                case 1: createCSEScene(); break;
                case 2: createPyramidScene(); break;
                case 3: createGridScene(); break;
                case 4: createTuningForkScene(); break;
                case 5: createTummoScene(); break;
                case 6: createShieldScene(); break;
                case 7: createAnchorsScene(); break;
                case 8: createTrinityScene(); break;
                case 9: createBeamScene(); break;
                case 10: createMerkabaScene(); break;
                case 11: createWaterScene(); break;
                case 12: createCollapseScene(); break;
                case 13: createDNAScene(); break;
                case 14: createKeyScene(); break;
                default: createGenericScene();
            }

            // Animation loop
            function animate() {
                requestAnimationFrame(animate);
                controls.update();
                renderer.render(scene, camera);
            }
            animate();

            // Handle resize
            window.addEventListener('resize', onWindowResize, false);
        }

        function onWindowResize() {
            if (!camera || !renderer) return;
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function createStarfield() {
            const geometry = new THREE.BufferGeometry();
            const positions = [];
            for (let i = 0; i < 3000; i++) {
                positions.push(
                    (Math.random() - 0.5) * 100,
                    (Math.random() - 0.5) * 100,
                    (Math.random() - 0.5) * 100
                );
            }
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            const material = new THREE.PointsMaterial({ color: 0xffffff, size: 0.05, transparent: true, opacity: 0.4 });
            const stars = new THREE.Points(geometry, material);
            scene.add(stars);
        }

        // Chapter 1: Matrix - Enhanced with all animations from original
        function createMatrixScene() {
            const group = new THREE.Group();
            
            // Kausal Grid (Structured, Frozen)
            const gridGeometry = new THREE.PlaneGeometry(20, 20, 40, 40);
            const gridMaterial = new THREE.MeshBasicMaterial({ 
                color: 0x00f0ff, 
                wireframe: true, 
                transparent: true, 
                opacity: 0.25 
            });
            const grid = new THREE.Mesh(gridGeometry, gridMaterial);
            grid.rotation.x = -Math.PI / 2;
            grid.position.y = -1;
            group.add(grid);

            // 60Hz Pulse Lines (Vertical Prison Bars)
            const lineGroup = new THREE.Group();
            for(let i = 0; i < 12; i++) {
                const angle = (i/12) * Math.PI * 2;
                const r = 8;
                const lineGeo = new THREE.BufferGeometry();
                lineGeo.setAttribute('position', new THREE.BufferAttribute(
                    new Float32Array([
                        Math.cos(angle)*r, -5, Math.sin(angle)*r,
                        Math.cos(angle)*r, 5, Math.sin(angle)*r
                    ]), 3
                ));
                const line = new THREE.Line(lineGeo, new THREE.LineBasicMaterial({
                    color: 0x00f0ff, transparent: true, opacity: 0.15
                }));
                lineGroup.add(line);
            }
            group.add(lineGroup);

            // Akausal Particles (Free, Chaotic, Golden)
            const particleCount = 2000;
            const particleGeometry = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3);
            const velocities = [];
            for (let i = 0; i < particleCount; i++) {
                positions[i * 3] = (Math.random() - 0.5) * 15;
                positions[i * 3 + 1] = (Math.random() - 0.5) * 10;
                positions[i * 3 + 2] = (Math.random() - 0.5) * 15;
                velocities.push(new THREE.Vector3(
                    (Math.random() - 0.5) * 0.02,
                    (Math.random() - 0.5) * 0.02,
                    (Math.random() - 0.5) * 0.02
                ));
            }
            particleGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            const particleMaterial = new THREE.PointsMaterial({ 
                color: 0xffaa00, 
                size: 0.06, 
                transparent: true, 
                opacity: 0.7 
            });
            const particles = new THREE.Points(particleGeometry, particleMaterial);
            group.add(particles);

            // Central Conflict Sphere (Ahriman Core)
            const coreGeometry = new THREE.IcosahedronGeometry(1.5, 2);
            const coreMaterial = new THREE.MeshBasicMaterial({ 
                color: 0xff0000, 
                wireframe: true, 
                transparent: true, 
                opacity: 0.3 
            });
            const core = new THREE.Mesh(coreGeometry, coreMaterial);
            group.add(core);

            scene.add(group);

            // Enhanced Animation Loop
            let time = 0;
            function animateMatrix() {
                time += 0.01;
                
                // Grid Wave (60Hz Oscillation)
                const gridPos = gridGeometry.attributes.position;
                for (let i = 0; i < gridPos.count; i++) {
                    const x = gridPos.getX(i);
                    const y = gridPos.getY(i);
                    gridPos.setZ(i, Math.sin(x * 0.5 + time * 60) * 0.3 + Math.sin(y * 0.5 + time * 60) * 0.3);
                }
                gridPos.needsUpdate = true;
                
                // Pulse bars
                lineGroup.children.forEach((line, i) => {
                    line.material.opacity = 0.15 + Math.sin(time * 60 + i * 0.5) * 0.1;
                });
                
                // Free particle movement (Brownian-like)
                for (let i = 0; i < particleCount; i++) {
                    positions[i * 3] += velocities[i].x;
                    positions[i * 3 + 1] += velocities[i].y;
                    positions[i * 3 + 2] += velocities[i].z;
                    
                    // Bounce back if too far
                    if (Math.abs(positions[i * 3]) > 15) velocities[i].x *= -1;
                    if (Math.abs(positions[i * 3 + 1]) > 10) velocities[i].y *= -1;
                    if (Math.abs(positions[i * 3 + 2]) > 15) velocities[i].z *= -1;
                }
                particleGeometry.attributes.position.needsUpdate = true;

                // Core rotation
                core.rotation.x = time * 0.3;
                core.rotation.y = time * 0.5;

                // Group rotation
                group.rotation.y = time * 0.05;

                requestAnimationFrame(animateMatrix);
            }
            animateMatrix();
        }

        // Chapter 2: CSE - Enhanced with standing wave interference
        function createCSEScene() {
            const group = new THREE.Group();
            
            // Hexagonal tube with enhanced material
            const tubeGeometry = new THREE.CylinderGeometry(1, 1, 5, 6, 1, true);
            const tubeMaterial = new THREE.MeshBasicMaterial({ 
                color: 0xffaa00, 
                wireframe: true, 
                transparent: true, 
                opacity: 0.4 
            });
            const tube = new THREE.Mesh(tubeGeometry, tubeMaterial);
            tube.rotation.x = Math.PI / 2;
            group.add(tube);

            // Standing wave particles with base positions
            const particleCount = 800;
            const particleGeometry = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3);
            const bases = new Float32Array(particleCount * 3);
            for (let i = 0; i < particleCount; i++) {
                bases[i * 3] = (Math.random() - 0.5);
                bases[i * 3 + 1] = (Math.random() - 0.5);
                bases[i * 3 + 2] = (Math.random() - 0.5) * 5;
            }
            particleGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            const particleMaterial = new THREE.PointsMaterial({ color: 0xffffff, size: 0.05 });
            const particles = new THREE.Points(particleGeometry, particleMaterial);
            group.add(particles);

            scene.add(group);

            // Enhanced Animation with interference patterns
            let time = 0;
            function animateCSE() {
                time += 0.05;
                
                // Standing wave interference pattern
                for (let i = 0; i < particleCount; i++) {
                    const z = bases[i * 3 + 2];
                    const amplitude = Math.sin(z * 4) * Math.cos(time * 5);
                    positions[i * 3] = bases[i * 3] * (1 + amplitude);
                    positions[i * 3 + 1] = bases[i * 3 + 1] * (1 + amplitude);
                    positions[i * 3 + 2] = z;
                }
                particleGeometry.attributes.position.needsUpdate = true;

                group.rotation.y = time * 0.1;

                requestAnimationFrame(animateCSE);
            }
            animateCSE();
        }

        // Chapter 3: Pyramid - Enhanced with resonance chambers and harp strings
        function createPyramidScene() {
            const group = new THREE.Group();
            
            // Main Pyramid Structure
            const pyramidGeometry = new THREE.ConeGeometry(4, 5, 4);
            const pyramidMaterial = new THREE.MeshBasicMaterial({ 
                color: 0xffaa00, 
                wireframe: true, 
                transparent: true, 
                opacity: 0.4 
            });
            const pyramid = new THREE.Mesh(pyramidGeometry, pyramidMaterial);
            pyramid.position.y = 2.5;
            group.add(pyramid);

            // King's Chamber (16.2 Hz)
            const kingGeometry = new THREE.BoxGeometry(0.8, 0.5, 0.8);
            const kingMaterial = new THREE.MeshBasicMaterial({ 
                color: 0xff3300, 
                transparent: true, 
                opacity: 0.6 
            });
            const kingChamber = new THREE.Mesh(kingGeometry, kingMaterial);
            kingChamber.position.y = 3.5;
            group.add(kingChamber);

            // Queen's Chamber (8.1 Hz)
            const queenGeometry = new THREE.BoxGeometry(0.7, 0.4, 0.7);
            const queenMaterial = new THREE.MeshBasicMaterial({ 
                color: 0x8800ff, 
                transparent: true, 
                opacity: 0.6 
            });
            const queenChamber = new THREE.Mesh(queenGeometry, queenMaterial);
            queenChamber.position.y = 2.0;
            group.add(queenChamber);

            // Harp of David (Resonance Strings)
            const harpGroup = new THREE.Group();
            const stringCount = 7;
            const strings = [];
            for (let i = 0; i < stringCount; i++) {
                const stringGeo = new THREE.CylinderGeometry(0.02, 0.02, 5);
                const stringMat = new THREE.MeshBasicMaterial({ 
                    color: 0xffffff,
                    transparent: true,
                    opacity: 0.7
                });
                const string = new THREE.Mesh(stringGeo, stringMat);
                string.position.set((i - stringCount / 2) * 0.3, 2.5, 0);
                string.userData.frequency = 8.1 * (i + 1);
                strings.push(string);
                harpGroup.add(string);
            }
            group.add(harpGroup);

            // Apex Energy Beam
            const beamGeo = new THREE.CylinderGeometry(0.05, 0.4, 10, 8, 1, true);
            const beamMat = new THREE.MeshBasicMaterial({
                color: 0xffffff, 
                transparent: true, 
                opacity: 0.25,
                blending: THREE.AdditiveBlending,
                side: THREE.DoubleSide
            });
            const beam = new THREE.Mesh(beamGeo, beamMat);
            beam.position.y = 10;
            group.add(beam);

            // Resonance Wave Rings
            const rings = [];
            for (let i = 0; i < 5; i++) {
                const ring = new THREE.Mesh(
                    new THREE.TorusGeometry(1 + i * 0.5, 0.05, 8, 32),
                    new THREE.MeshBasicMaterial({ 
                        color: 0x00ffff, 
                        transparent: true, 
                        opacity: 0.4 - i * 0.05 
                    })
                );
                ring.position.y = 5 + i * 0.3;
                ring.userData.offset = i * 0.2;
                rings.push(ring);
                group.add(ring);
            }

            scene.add(group);

            // Enhanced Animation with harmonic resonance
            let time = 0;
            function animatePyramid() {
                time += 0.01;
                
                group.rotation.y = time * 0.1;
                
                // String Vibration (Harmonic Oscillators)
                strings.forEach((string, i) => {
                    const freq = string.userData.frequency;
                    const amplitude = Math.sin(time * freq * 0.1 + i) * 0.15;
                    string.scale.x = 1 + amplitude * 3;
                    string.material.opacity = 0.5 + Math.abs(amplitude) * 0.5;
                });
                
                // Chamber Pulse
                const kingPulse = 1 + Math.sin(time * 16.2 * 0.1) * 0.1;
                kingChamber.scale.setScalar(kingPulse);
                kingChamber.material.opacity = 0.4 + Math.abs(Math.sin(time * 16.2 * 0.1)) * 0.3;
                
                const queenPulse = 1 + Math.sin(time * 8.1 * 0.1) * 0.1;
                queenChamber.scale.setScalar(queenPulse);
                queenChamber.material.opacity = 0.4 + Math.abs(Math.sin(time * 8.1 * 0.1)) * 0.3;
                
                // Beam fluctuation
                beam.scale.set(1 + Math.sin(time * 3) * 0.2, 1, 1 + Math.sin(time * 3) * 0.2);
                beam.material.opacity = 0.2 + Math.sin(time * 2) * 0.1;
                
                // Rings propagation
                rings.forEach((ring, i) => {
                    const wave = (time * 2 + ring.userData.offset) % 3;
                    ring.position.y = 5 + wave * 2;
                    ring.scale.setScalar(1 + wave * 0.3);
                    ring.material.opacity = (1 - wave / 3) * 0.4;
                });

                requestAnimationFrame(animatePyramid);
            }
            animatePyramid();
        }

        // Chapter 15: Key (3-6-9 System) - Enhanced with all layers
        function createKeyScene() {
            const group = new THREE.Group();
            group.position.y = -2;

            // Avatar Body (Wire + Glass)
            const torsoGeometry = new THREE.CylinderGeometry(0.3, 0.2, 1.8, 8);
            const glassMat = new THREE.MeshPhysicalMaterial({
                color: 0x00f0ff, 
                emissive: 0x001133, 
                transmission: 0.5, 
                opacity: 0.4, 
                transparent: true
            });
            const torso = new THREE.Mesh(torsoGeometry, glassMat);
            torso.position.y = 2.8;
            
            const wireMat = new THREE.MeshBasicMaterial({
                color: 0x00f0ff, 
                wireframe: true, 
                opacity: 0.15, 
                transparent: true
            });
            const wireFrame = new THREE.Mesh(torsoGeometry, wireMat);
            torso.add(wireFrame);
            group.add(torso);

            // Head
            const headGeometry = new THREE.SphereGeometry(0.25, 16, 16);
            const headMaterial = new THREE.MeshBasicMaterial({ 
                color: 0xffffff, 
                transparent: true, 
                opacity: 0.6 
            });
            const head = new THREE.Mesh(headGeometry, headMaterial);
            head.position.y = 4.0;
            group.add(head);

            // 9: Pleroma (Indigo sphere with particle cloud)
            const nineGeometry = new THREE.SphereGeometry(0.35, 32, 32);
            const nineMaterial = new THREE.MeshBasicMaterial({ 
                color: 0x8888ff, 
                transparent: true, 
                opacity: 0.8 
            });
            const nine = new THREE.Mesh(nineGeometry, nineMaterial);
            nine.position.y = 4.8;
            group.add(nine);

            // Pleroma Particle Cloud
            const pGeo9 = new THREE.BufferGeometry();
            const pPos9 = [];
            for (let i = 0; i < 3000; i++) {
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                const r = 0.5 + Math.random() * 2.5;
                pPos9.push(
                    r * Math.sin(phi) * Math.cos(theta),
                    r * Math.sin(phi) * Math.sin(theta) + 4.8,
                    r * Math.cos(phi)
                );
            }
            pGeo9.setAttribute('position', new THREE.Float32BufferAttribute(pPos9, 3));
            const particles9 = new THREE.Points(pGeo9, new THREE.PointsMaterial({
                size: 0.04, 
                color: 0x8888ff, 
                transparent: true, 
                opacity: 0.4, 
                blending: THREE.AdditiveBlending
            }));
            group.add(particles9);

            // 6: Torsion field (Orange torus with particle ring)
            const sixGeometry = new THREE.TorusGeometry(2.0, 0.08, 16, 64);
            const sixMaterial = new THREE.MeshBasicMaterial({ 
                color: 0xff6600, 
                transparent: true, 
                opacity: 0.7 
            });
            const six = new THREE.Mesh(sixGeometry, sixMaterial);
            six.rotation.x = Math.PI / 2;
            six.position.y = 3.0;
            group.add(six);

            // Torus Particle Ring
            const pGeo6 = new THREE.BufferGeometry();
            const pPos6 = [];
            for (let i = 0; i < 1000; i++) {
                const angle = (i / 1000) * Math.PI * 2;
                const r = 2.0 + (Math.random() - 0.5) * 0.3;
                pPos6.push(Math.cos(angle) * r, 3.0, Math.sin(angle) * r);
            }
            pGeo6.setAttribute('position', new THREE.Float32BufferAttribute(pPos6, 3));
            const particles6 = new THREE.Points(pGeo6, new THREE.PointsMaterial({
                size: 0.06, 
                color: 0xff6600, 
                transparent: true, 
                opacity: 0.5
            }));
            group.add(particles6);

            // 3: Gnosis core (Gold octahedron with glow)
            const threeGeometry = new THREE.OctahedronGeometry(0.5);
            const threeMaterial = new THREE.MeshBasicMaterial({ 
                color: 0xffd700, 
                wireframe: true, 
                transparent: true, 
                opacity: 0.9 
            });
            const three = new THREE.Mesh(threeGeometry, threeMaterial);
            three.position.y = 2.8;
            group.add(three);

            const threeGlow = new THREE.Mesh(
                new THREE.OctahedronGeometry(0.55),
                new THREE.MeshBasicMaterial({
                    color: 0xffaa00, 
                    transparent: true, 
                    opacity: 0.25, 
                    blending: THREE.AdditiveBlending
                })
            );
            threeGlow.position.y = 2.8;
            group.add(threeGlow);

            // 8: Matrix Base (Dark Grid)
            const eightG = new THREE.Group();
            eightG.position.y = -0.5;
            const matrixDome = new THREE.LineSegments(
                new THREE.WireframeGeometry(new THREE.IcosahedronGeometry(5, 2)),
                new THREE.LineBasicMaterial({
                    color: 0x333333, 
                    transparent: true, 
                    opacity: 0.15
                })
            );
            matrixDome.rotation.x = Math.PI / 2;
            matrixDome.scale.set(1, 0.15, 1);
            eightG.add(matrixDome);
            group.add(eightG);

            scene.add(group);

            // Enhanced Animation
            let time = 0;
            function animateKey() {
                time += 0.01;
                
                // Breathing animation
                const breathe = 1 + Math.sin(time * 1.5) * 0.03;
                torso.scale.set(breathe, 1, breathe);

                // 9: Pleroma rotation
                nine.rotation.y = time * 0.3;
                nine.rotation.x = Math.sin(time * 0.5) * 0.2;
                particles9.rotation.y = -time * 0.15;

                // 6: Torus spin
                six.rotation.z = time * 0.4;
                particles6.rotation.y = time * 0.5;

                // 3: Crystal rotation
                three.rotation.y = time * 0.6;
                three.rotation.x = Math.sin(time * 0.8) * 0.3;
                threeGlow.rotation.y = -time * 0.5;
                threeGlow.rotation.x = Math.cos(time * 0.7) * 0.3;

                // 8: Matrix dome
                eightG.rotation.y = time * 0.08;
                matrixDome.material.opacity = 0.1 + Math.sin(time * 2) * 0.05;

                // Main group rotation
                group.rotation.y = time * 0.12;

                requestAnimationFrame(animateKey);
            }
            animateKey();
        }

        // Generic scene for other chapters
        function createGenericScene() {
            const group = new THREE.Group();
            
            for (let i = 0; i < 9; i++) {
                const geometry = new THREE.SphereGeometry(0.1, 16, 16);
                const color = i % 3 === 0 ? 0xffaa00 : (i % 3 === 1 ? 0xff6600 : 0x8888ff);
                const material = new THREE.MeshBasicMaterial({ color });
                const sphere = new THREE.Mesh(geometry, material);
                
                const angle = (i / 9) * Math.PI * 2;
                const radius = 3;
                sphere.position.set(
                    Math.cos(angle) * radius,
                    Math.sin(angle * 2) * 1,
                    Math.sin(angle) * radius
                );
                
                group.add(sphere);
            }
            
            scene.add(group);

            let time = 0;
            function animateGeneric() {
                time += 0.01;
                group.rotation.y = time * 0.2;
                requestAnimationFrame(animateGeneric);
            }
            animateGeneric();
        }

        // Implement remaining scenes - All ported from original v1 website
        
        // Chapter 4: Goldenes Gitter (Planetary Grid with Ley Lines)
        function createGridScene() {
            const grp = new THREE.Group();
            // Earth Icosahedron (Platonic Solid)
            const earth = new THREE.Mesh(
                new THREE.IcosahedronGeometry(3, 2),
                new THREE.MeshBasicMaterial({color:0x0088ff, wireframe:false, transparent:true, opacity:0.1})
            );
            grp.add(earth);
            
            // Wireframe Overlay (Ley Lines)
            const wireframe = new THREE.Mesh(
                new THREE.IcosahedronGeometry(3.05, 2),
                new THREE.MeshBasicMaterial({color:0xffaa00, wireframe:true})
            );
            grp.add(wireframe);
            
            // PHI-Nodes (12 Vertices of Icosahedron)
            const vertices = new THREE.IcosahedronGeometry(3, 0).attributes.position;
            const nodes = [];
            const nodePositions = [];
            for(let i=0; i<vertices.count; i++) {
                const x = vertices.getX(i);
                const y = vertices.getY(i);
                const z = vertices.getZ(i);
                const exists = nodePositions.some(p => Math.abs(p.x-x)<0.01 && Math.abs(p.y-y)<0.01 && Math.abs(p.z-z)<0.01);
                if(!exists && nodes.length < 12) {
                    nodePositions.push({x,y,z});
                    const node = new THREE.Mesh(
                        new THREE.SphereGeometry(0.15, 8, 8),
                        new THREE.MeshBasicMaterial({color:0xffd700})
                    );
                    node.position.set(x, y, z);
                    nodes.push(node);
                    grp.add(node);
                }
            }
            
            // Energy Pulses along Ley Lines
            const pulseGeo = new THREE.BufferGeometry();
            const pulsePos = new Float32Array(100*3);
            pulseGeo.setAttribute('position', new THREE.BufferAttribute(pulsePos,3));
            const pulses = new THREE.Points(pulseGeo, new THREE.PointsMaterial({color:0x00ff00, size:0.1}));
            grp.add(pulses);
            
            scene.add(grp);
            
            let time = 0;
            function animateGrid() {
                time += 0.016;
                grp.rotation.y = time*0.1;
                nodes.forEach((n, i) => {
                    n.scale.setScalar(1 + Math.sin(time*2+i)*0.2);
                });
                // Pulse animation
                for(let i=0; i<100; i++) {
                    const progress = (time*0.5 + i/100) % 1;
                    const angle = progress*Math.PI*2;
                    const r = 3;
                    pulsePos[i*3] = Math.cos(angle)*r;
                    pulsePos[i*3+1] = Math.sin(angle)*r*Math.sin(time+i*0.1);
                    pulsePos[i*3+2] = Math.sin(angle)*r;
                }
                pulseGeo.attributes.position.needsUpdate = true;
                requestAnimationFrame(animateGrid);
            }
            animateGrid();
        }
        
        // Chapter 5: Die Stimmgabel (Tuning Fork with Heart Coherence)
        function createTuningForkScene() {
            const grp = new THREE.Group();
            // Two Prongs (Cherubim in Contact)
            const prong1 = new THREE.Mesh(new THREE.CylinderGeometry(0.1,0.1,4), new THREE.MeshBasicMaterial({color:0xff6600}));
            prong1.position.set(-0.6, 2, 0); grp.add(prong1);
            const prong2 = prong1.clone(); prong2.position.set(0.6, 2, 0); grp.add(prong2);
            const base = new THREE.Mesh(new THREE.CylinderGeometry(0.15,0.15,0.5), new THREE.MeshBasicMaterial({color:0xffaa00}));
            base.position.y = 0.25; grp.add(base);
            
            // Torus Field (3 FuÃŸ = ~0.91m radius)
            const torus = new THREE.Mesh(new THREE.TorusGeometry(3, 0.05, 16, 100), new THREE.MeshBasicMaterial({color:0x00ff88, transparent:true, opacity:0.3}));
            torus.rotation.x = Math.PI/2; grp.add(torus);
            
            // Heart Coherence Waves
            const waveGeo = new THREE.BufferGeometry();
            const wPos = new Float32Array(200*3);
            for(let i=0; i<200; i++) {
                const angle = (i/200)*Math.PI*2;
                wPos[i*3] = Math.cos(angle)*3; wPos[i*3+1] = 0; wPos[i*3+2] = Math.sin(angle)*3;
            }
            waveGeo.setAttribute('position', new THREE.BufferAttribute(wPos,3));
            const waves = new THREE.Points(waveGeo, new THREE.PointsMaterial({color:0xff6600, size:0.1}));
            grp.add(waves);
            
            scene.add(grp);
            
            let time = 0;
            function animateFork() {
                time += 0.016;
                // 0.1 Hz Heart Coherence Frequency
                prong1.position.x = -0.6 + Math.sin(time*0.1*Math.PI*2)*0.05;
                prong2.position.x = 0.6 - Math.sin(time*0.1*Math.PI*2)*0.05;
                torus.scale.set(1+Math.sin(time*0.1*Math.PI*2)*0.1, 1+Math.sin(time*0.1*Math.PI*2)*0.1, 1);
                waves.rotation.y = time*0.1;
                grp.rotation.y = time*0.05;
                requestAnimationFrame(animateFork);
            }
            animateFork();
        }
        
        // Chapter 6: Tummo-Flamme (Kundalini Fire Breath)
        function createTummoScene() {
            const grp = new THREE.Group();
            // Central Channel (Sushumna)
            const channel = new THREE.Mesh(new THREE.CylinderGeometry(0.1,0.1,8), new THREE.MeshBasicMaterial({color:0xffffff, transparent:true, opacity:0.2}));
            grp.add(channel);
            
            // Spiral Fire Particles (Kundalini Rising)
            const pGeo = new THREE.BufferGeometry();
            const pCount = 1000;
            const pPos = new Float32Array(pCount*3);
            const pColors = new Float32Array(pCount*3);
            const bases = [];
            for(let i=0; i<pCount; i++) {
                const t = i/pCount;
                const angle = t*Math.PI*8; // 4 spirals
                const radius = 0.5 + t*0.5;
                const y = t*8 - 4;
                bases.push({angle, radius, y, offset: Math.random()*Math.PI*2});
                // Gradient: Red -> Orange -> Yellow -> White
                const heat = t;
                pColors[i*3] = 1; pColors[i*3+1] = heat*0.6; pColors[i*3+2] = heat*heat*0.3;
            }
            pGeo.setAttribute('position', new THREE.BufferAttribute(pPos,3));
            pGeo.setAttribute('color', new THREE.BufferAttribute(pColors,3));
            const fire = new THREE.Points(pGeo, new THREE.PointsMaterial({size:0.08, vertexColors:true, transparent:true, opacity:0.8}));
            grp.add(fire);
            
            // Base Flame
            const baseFlame = new THREE.Mesh(new THREE.ConeGeometry(0.5,1,8), new THREE.MeshBasicMaterial({color:0xff0000, transparent:true, opacity:0.5}));
            baseFlame.position.y = -4; grp.add(baseFlame);
            
            scene.add(grp);
            
            let time = 0;
            function animateTummo() {
                time += 0.016;
                for(let i=0; i<pCount; i++) {
                    const b = bases[i];
                    const spiral = b.angle + time*2 + b.offset;
                    pPos[i*3] = Math.cos(spiral)*b.radius;
                    pPos[i*3+1] = b.y + Math.sin(time*3+b.offset)*0.2;
                    pPos[i*3+2] = Math.sin(spiral)*b.radius;
                }
                pGeo.attributes.position.needsUpdate = true;
                baseFlame.scale.set(1+Math.sin(time*5)*0.2, 1+Math.sin(time*5)*0.3, 1+Math.sin(time*5)*0.2);
                grp.rotation.y = time*0.1;
                requestAnimationFrame(animateTummo);
            }
            animateTummo();
        }
        
        // Chapter 7: Gnostische Feldarbeit (Frequency Shield with Interference Pattern)
        function createShieldScene() {
            const grp = new THREE.Group();
            // Central Sphere (Bio-Field)
            const core = new THREE.Mesh(new THREE.SphereGeometry(1,32,32), new THREE.MeshBasicMaterial({color:0x00d2ff, wireframe:true, transparent:true, opacity:0.3}));
            grp.add(core);
            
            // Multi-Layer Shields (Harmonic Frequencies)
            const shields = [];
            const freqs = [1, 1.618, 2.618, 4.236]; // Fibonacci ratios
            freqs.forEach((f, idx) => {
                const shield = new THREE.Mesh(
                    new THREE.IcosahedronGeometry(2+idx*0.8, 1),
                    new THREE.MeshBasicMaterial({color:0x00d2ff, wireframe:true, transparent:true, opacity:0.15})
                );
                shield.userData.freq = f;
                shields.push(shield);
                grp.add(shield);
            });
            
            // Interference Particles
            const pGeo = new THREE.BufferGeometry();
            const pCount = 500;
            const pPos = new Float32Array(pCount*3);
            for(let i=0; i<pCount; i++) {
                const theta = Math.random()*Math.PI*2;
                const phi = Math.acos(2*Math.random()-1);
                const r = 3 + Math.random()*2;
                pPos[i*3] = r*Math.sin(phi)*Math.cos(theta);
                pPos[i*3+1] = r*Math.sin(phi)*Math.sin(theta);
                pPos[i*3+2] = r*Math.cos(phi);
            }
            pGeo.setAttribute('position', new THREE.BufferAttribute(pPos,3));
            const particles = new THREE.Points(pGeo, new THREE.PointsMaterial({color:0xffffff, size:0.05}));
            grp.add(particles);
            
            scene.add(grp);
            
            let time = 0;
            function animateShield() {
                time += 0.016;
                shields.forEach((s, i) => {
                    s.rotation.y = time*s.userData.freq*0.2;
                    s.rotation.x = time*s.userData.freq*0.1;
                    s.scale.setScalar(1 + Math.sin(time*s.userData.freq*2)*0.05);
                });
                particles.rotation.y = -time*0.3;
                core.rotation.y = time*0.5;
                requestAnimationFrame(animateShield);
            }
            animateShield();
        }
        
        // Chapter 8: Bau des Gitters (Three Sacred Anchors)
        function createAnchorsScene() {
            const grp = new THREE.Group();
            // 1. Kailash (Tibet) - Pyramid
            const kailash = new THREE.Mesh(
                new THREE.ConeGeometry(1, 2, 4),
                new THREE.MeshBasicMaterial({color:0xffffff, wireframe:true})
            );
            kailash.position.set(-3, 0, 0);
            grp.add(kailash);
            
            // 2. Gizeh (Egypt) - Pyramid
            const gizeh = new THREE.Mesh(
                new THREE.ConeGeometry(1.2, 2.2, 4),
                new THREE.MeshBasicMaterial({color:0xffaa00, wireframe:true})
            );
            gizeh.position.set(0, 0, 0);
            grp.add(gizeh);
            
            // 3. Scotland (Stone Circles) - Ring
            const scotland = new THREE.Mesh(
                new THREE.TorusGeometry(1, 0.1, 8, 16),
                new THREE.MeshBasicMaterial({color:0x00ff88, wireframe:true})
            );
            scotland.position.set(3, 0, 0);
            scotland.rotation.x = Math.PI/2;
            grp.add(scotland);
            
            // Connection Lines (Ley Lines)
            const lineGeo = new THREE.BufferGeometry();
            const linePos = new Float32Array([
                -3,0,0, 0,0,0,  0,0,0, 3,0,0,  3,0,0, -3,0,0
            ]);
            lineGeo.setAttribute('position', new THREE.BufferAttribute(linePos, 3));
            const lines = new THREE.Line(lineGeo, new THREE.LineBasicMaterial({color:0x00f0ff, transparent:true, opacity:0.5}));
            grp.add(lines);
            
            // Energy Flow Particles
            const pGeo = new THREE.BufferGeometry();
            const pPos = new Float32Array(60*3);
            const pBases = [];
            for(let i=0; i<20; i++) { pBases.push({from:0, to:1, progress:i/20}); }
            for(let i=0; i<20; i++) { pBases.push({from:1, to:2, progress:i/20}); }
            for(let i=0; i<20; i++) { pBases.push({from:2, to:0, progress:i/20}); }
            pGeo.setAttribute('position', new THREE.BufferAttribute(pPos,3));
            const flow = new THREE.Points(pGeo, new THREE.PointsMaterial({color:0x00ffff, size:0.1}));
            grp.add(flow);
            
            scene.add(grp);
            const anchors = [[-3,0,0], [0,0,0], [3,0,0]];
            
            let time = 0;
            function animateAnchors() {
                time += 0.016;
                grp.rotation.y = time*0.05;
                kailash.rotation.y = time*0.2;
                gizeh.rotation.y = -time*0.2;
                scotland.rotation.z = time*0.3;
                
                // Flow animation
                pBases.forEach((b, i) => {
                    const p = (b.progress + time*0.1) % 1;
                    const from = anchors[b.from];
                    const to = anchors[b.to];
                    pPos[i*3] = from[0] + (to[0]-from[0])*p;
                    pPos[i*3+1] = from[1] + (to[1]-from[1])*p + Math.sin(p*Math.PI)*0.5;
                    pPos[i*3+2] = from[2] + (to[2]-from[2])*p;
                });
                pGeo.attributes.position.needsUpdate = true;
                requestAnimationFrame(animateAnchors);
            }
            animateAnchors();
        }
        
        // Chapter 9: Die Trinity (Viral Network Spread)
        function createTrinityScene() {
            const grp = new THREE.Group();
            // Central Node (Trinity Core)
            const core = new THREE.Mesh(
                new THREE.OctahedronGeometry(0.5),
                new THREE.MeshBasicMaterial({color:0xff0000, wireframe:false})
            );
            grp.add(core);
            
            // Network Nodes (8th Sphere Grid)
            const nodes = [];
            const connections = [];
            for(let i=0; i<50; i++) {
                const theta = Math.random()*Math.PI*2;
                const phi = Math.acos(2*Math.random()-1);
                const r = 2 + Math.random()*5;
                const node = new THREE.Mesh(
                    new THREE.SphereGeometry(0.1, 6, 6),
                    new THREE.MeshBasicMaterial({color:0x666666})
                );
                node.position.set(
                    r*Math.sin(phi)*Math.cos(theta),
                    r*Math.sin(phi)*Math.sin(theta),
                    r*Math.cos(phi)
                );
                node.userData.infected = false;
                node.userData.infectionTime = 0;
                nodes.push(node);
                grp.add(node);
            }
            
            // Connection Lines
            nodes.forEach((n1, i) => {
                nodes.forEach((n2, j) => {
                    if(i<j && n1.position.distanceTo(n2.position) < 3) {
                        const geo = new THREE.BufferGeometry();
                        geo.setAttribute('position', new THREE.BufferAttribute(
                            new Float32Array([n1.position.x, n1.position.y, n1.position.z, n2.position.x, n2.position.y, n2.position.z]), 3
                        ));
                        const line = new THREE.Line(geo, new THREE.LineBasicMaterial({color:0x333333, transparent:true, opacity:0.2}));
                        connections.push({line, n1, n2});
                        grp.add(line);
                    }
                });
            });
            
            scene.add(grp);
            
            let time = 0;
            function animateTrinity() {
                time += 0.016;
                grp.rotation.y = time*0.1;
                core.rotation.x = time*0.5;
                core.rotation.y = time*0.7;
                
                // Infection Spread (Viral Pattern)
                nodes.forEach(n => {
                    if(!n.userData.infected) {
                        const dist = n.position.distanceTo(core.position);
                        if(time*2 > dist) {
                            n.userData.infected = true;
                            n.userData.infectionTime = time;
                            n.material.color.setHex(0xff0000);
                        }
                    } else {
                        const age = time - n.userData.infectionTime;
                        n.scale.setScalar(1 + Math.sin(age*5)*0.3);
                    }
                });
                
                // Update connection colors
                connections.forEach(c => {
                    if(c.n1.userData.infected && c.n2.userData.infected) {
                        c.line.material.color.setHex(0xff0000);
                        c.line.material.opacity = 0.6;
                    }
                });
                requestAnimationFrame(animateTrinity);
            }
            animateTrinity();
        }
        
        // Chapter 10: Die 1-Hz ZÃ¼ndung (Resonance Beam - Angkor Wat)
        function createBeamScene() {
            const grp = new THREE.Group();
            // Temple Base (CSE Capacitor)
            const base = new THREE.Mesh(
                new THREE.BoxGeometry(3, 0.5, 3),
                new THREE.MeshBasicMaterial({color:0x888888, wireframe:true})
            );
            base.position.y = -2;
            grp.add(base);
            
            // Central Beam (1 Hz Standing Wave)
            const beamGeo = new THREE.CylinderGeometry(0.3, 0.3, 10, 32, 1, true);
            const beamMat = new THREE.MeshBasicMaterial({color:0xffffff, transparent:true, opacity:0.3, side:THREE.DoubleSide});
            const beam = new THREE.Mesh(beamGeo, beamMat);
            beam.position.y = 3;
            grp.add(beam);
            
            // Particle Beam (Vertical Flow)
            const pGeo = new THREE.BufferGeometry();
            const pCount = 1000;
            const pPos = new Float32Array(pCount*3);
            const pBases = [];
            for(let i=0; i<pCount; i++) {
                const angle = Math.random()*Math.PI*2;
                const r = Math.random()*0.3;
                pBases.push({angle, r, y:Math.random()*10-2});
            }
            pGeo.setAttribute('position', new THREE.BufferAttribute(pPos,3));
            const particles = new THREE.Points(pGeo, new THREE.PointsMaterial({color:0xffffff, size:0.05}));
            grp.add(particles);
            
            // Resonance Rings (1 Hz Pulses)
            const rings = [];
            for(let i=0; i<5; i++) {
                const ring = new THREE.Mesh(
                    new THREE.TorusGeometry(0.5, 0.05, 8, 32),
                    new THREE.MeshBasicMaterial({color:0x00ffff, transparent:true, opacity:0.6})
                );
                ring.rotation.x = Math.PI/2;
                ring.userData.offset = i*0.2;
                rings.push(ring);
                grp.add(ring);
            }
            
            scene.add(grp);
            
            let time = 0;
            function animateBeam() {
                time += 0.016;
                // 1 Hz Frequency (1 cycle per second)
                const phase = (time % 1)*Math.PI*2;
                beam.scale.x = beam.scale.z = 1 + Math.sin(phase)*0.2;
                
                // Particle flow
                pBases.forEach((b, i) => {
                    const y = (b.y + time*2) % 12 - 2;
                    pPos[i*3] = Math.cos(b.angle + time)*b.r;
                    pPos[i*3+1] = y;
                    pPos[i*3+2] = Math.sin(b.angle + time)*b.r;
                });
                pGeo.attributes.position.needsUpdate = true;
                
                // Resonance rings
                rings.forEach((r, i) => {
                    const y = ((time*2 + r.userData.offset) % 2)*5 - 2;
                    r.position.y = y;
                    r.scale.setScalar((y+2)/5 + 0.5);
                    r.material.opacity = 1 - (y+2)/5;
                });
                
                grp.rotation.y = time*0.05;
                requestAnimationFrame(animateBeam);
            }
            animateBeam();
        }
        
        // Chapter 11: Der 9-er Akt (Merkaba Superposition)
        function createMerkabaScene() {
            const grp = new THREE.Group();
            // Upward Tetrahedron (Male/Electric)
            const tetra1Geo = new THREE.TetrahedronGeometry(2);
            const tetra1 = new THREE.Mesh(tetra1Geo, new THREE.MeshBasicMaterial({color:0x00ffff, wireframe:true, transparent:true, opacity:0.6}));
            grp.add(tetra1);
            
            // Downward Tetrahedron (Female/Magnetic)
            const tetra2 = tetra1.clone();
            tetra2.rotation.y = Math.PI;
            tetra2.material = new THREE.MeshBasicMaterial({color:0xff00ff, wireframe:true, transparent:true, opacity:0.6});
            grp.add(tetra2);
            
            // Central Sphere (Unity Point)
            const core = new THREE.Mesh(
                new THREE.SphereGeometry(0.5, 16, 16),
                new THREE.MeshBasicMaterial({color:0xffffff, wireframe:true})
            );
            grp.add(core);
            
            // Energy Vortex (Counter-Rotating)
            const vortexGeo = new THREE.BufferGeometry();
            const vCount = 500;
            const vPos = new Float32Array(vCount*3);
            const vBases = [];
            for(let i=0; i<vCount; i++) {
                const t = i/vCount;
                vBases.push({t, dir: i<vCount/2 ? 1 : -1});
            }
            vortexGeo.setAttribute('position', new THREE.BufferAttribute(vPos,3));
            const vortex = new THREE.Points(vortexGeo, new THREE.PointsMaterial({color:0xffaa00, size:0.06}));
            grp.add(vortex);
            
            // 9 Sacred Points (Nonagon)
            const sacred9 = [];
            for(let i=0; i<9; i++) {
                const angle = (i/9)*Math.PI*2;
                const node = new THREE.Mesh(
                    new THREE.SphereGeometry(0.1, 8, 8),
                    new THREE.MeshBasicMaterial({color:0xffd700})
                );
                node.position.set(Math.cos(angle)*3, 0, Math.sin(angle)*3);
                node.userData.angle = angle;
                sacred9.push(node);
                grp.add(node);
            }
            
            scene.add(grp);
            
            let time = 0;
            function animateMerkaba() {
                time += 0.016;
                // Counter-rotation (Merkaba activation)
                tetra1.rotation.y = time*0.3;
                tetra2.rotation.y = -time*0.3;
                core.rotation.x = time*0.5;
                core.rotation.z = time*0.4;
                
                // Vortex animation
                vBases.forEach((b, i) => {
                    const spiral = time*2*b.dir + b.t*Math.PI*4;
                    const r = b.t*3;
                    const y = (b.t*4 - 2);
                    vPos[i*3] = Math.cos(spiral)*r;
                    vPos[i*3+1] = y;
                    vPos[i*3+2] = Math.sin(spiral)*r;
                });
                vortexGeo.attributes.position.needsUpdate = true;
                
                // 9 Points Pulse
                sacred9.forEach((n, i) => {
                    n.scale.setScalar(1 + Math.sin(time*2 + i*Math.PI*2/9)*0.3);
                    n.position.y = Math.sin(time + n.userData.angle)*0.5;
                });
                requestAnimationFrame(animateMerkaba);
            }
            animateMerkaba();
        }
        
        // Chapter 12: Bio-Gravitation (Water Crystal Lattice - H3O2)
        function createWaterScene() {
            const grp = new THREE.Group();
            const geo = new THREE.SphereGeometry(0.1,8,8);
            const mat = new THREE.MeshBasicMaterial({color:0x00aaff});
            const mesh = new THREE.InstancedMesh(geo, mat, 200);
            const dummy = new THREE.Object3D();
            let i=0;
            for(let x=-5; x<=5; x++) for(let z=-5; z<=5; z++) {
                if(i<200) {
                    dummy.position.set(x*0.8 + (z%2)*0.4, 0, z*0.7);
                    dummy.updateMatrix(); mesh.setMatrixAt(i++, dummy.matrix);
                }
            }
            grp.add(mesh);
            scene.add(grp);
            
            let time = 0;
            function animateWater() {
                time += 0.016;
                grp.rotation.y = time*0.1;
                requestAnimationFrame(animateWater);
            }
            animateWater();
        }
        
        // Chapter 13: Fraktaler Kollaps (Fractal Implosion)
        function createCollapseScene() {
            const grp = new THREE.Group();
            // Central Void
            const void_ = new THREE.Mesh(
                new THREE.SphereGeometry(0.3, 16, 16),
                new THREE.MeshBasicMaterial({color:0x000000})
            );
            grp.add(void_);
            
            // Fractal Cubes (Collapsing Hierarchy)
            const cubes = [];
            const levels = 5;
            for(let level=0; level<levels; level++) {
                const count = Math.pow(2, level);
                for(let i=0; i<count; i++) {
                    const cube = new THREE.Mesh(
                        new THREE.BoxGeometry(0.5, 0.5, 0.5),
                        new THREE.MeshBasicMaterial({color:0x555555, wireframe:true, transparent:true, opacity:0.4})
                    );
                    const angle = (i/count)*Math.PI*2;
                    const r = 2 + level*1.5;
                    cube.position.set(Math.cos(angle)*r, 0, Math.sin(angle)*r);
                    cube.userData = {level, angle, radius:r, index:i};
                    cubes.push(cube);
                    grp.add(cube);
                }
            }
            
            // Entropy Particles (Chaotic Decay)
            const pGeo = new THREE.BufferGeometry();
            const pCount = 1000;
            const pPos = new Float32Array(pCount*3);
            const pVel = [];
            for(let i=0; i<pCount; i++) {
                const theta = Math.random()*Math.PI*2;
                const phi = Math.acos(2*Math.random()-1);
                const r = 8 + Math.random()*5;
                pPos[i*3] = r*Math.sin(phi)*Math.cos(theta);
                pPos[i*3+1] = r*Math.sin(phi)*Math.sin(theta);
                pPos[i*3+2] = r*Math.cos(phi);
                pVel.push({x:-pPos[i*3]*0.01, y:-pPos[i*3+1]*0.01, z:-pPos[i*3+2]*0.01});
            }
            pGeo.setAttribute('position', new THREE.BufferAttribute(pPos,3));
            const entropy = new THREE.Points(pGeo, new THREE.PointsMaterial({color:0xff0000, size:0.03}));
            grp.add(entropy);
            
            scene.add(grp);
            
            let time = 0;
            function animateCollapse() {
                time += 0.016;
                // Collapse animation
                cubes.forEach(c => {
                    const collapseProgress = (time*0.5) % 3; // 3 second cycle
                    const targetR = c.userData.radius * (1 - Math.min(collapseProgress/2, 1));
                    const currentR = Math.max(targetR, 0.5);
                    c.position.x = Math.cos(c.userData.angle + time*0.2)*currentR;
                    c.position.z = Math.sin(c.userData.angle + time*0.2)*currentR;
                    c.rotation.x = time*(c.userData.level+1)*0.3;
                    c.rotation.y = time*(c.userData.level+1)*0.2;
                    c.material.opacity = currentR/c.userData.radius * 0.4;
                });
                
                // Entropy inward spiral
                for(let i=0; i<pCount; i++) {
                    pPos[i*3] += pVel[i].x;
                    pPos[i*3+1] += pVel[i].y;
                    pPos[i*3+2] += pVel[i].z;
                    const dist = Math.sqrt(pPos[i*3]**2 + pPos[i*3+1]**2 + pPos[i*3+2]**2);
                    if(dist < 0.5) {
                        // Reset
                        const theta = Math.random()*Math.PI*2;
                        const phi = Math.acos(2*Math.random()-1);
                        const r = 13;
                        pPos[i*3] = r*Math.sin(phi)*Math.cos(theta);
                        pPos[i*3+1] = r*Math.sin(phi)*Math.sin(theta);
                        pPos[i*3+2] = r*Math.cos(phi);
                        pVel[i] = {x:-pPos[i*3]*0.01, y:-pPos[i*3+1]*0.01, z:-pPos[i*3+2]*0.01};
                    }
                }
                pGeo.attributes.position.needsUpdate = true;
                
                void_.rotation.x = time*0.5;
                void_.rotation.y = time*0.7;
                requestAnimationFrame(animateCollapse);
            }
            animateCollapse();
        }
        
        // Chapter 14: Bio-Lumineszenz (DNA Double Helix - C12 Transformation)
        function createDNAScene() {
            const grp = new THREE.Group();
            // Double Helix Structure
            const helixPoints1 = [];
            const helixPoints2 = [];
            const segments = 50;
            
            for(let i=0; i<segments; i++) {
                const t = i/segments;
                const y = t*10 - 5;
                const angle = t*Math.PI*4; // 2 full turns
                const r = 1;
                
                // Strand 1
                const p1 = new THREE.Mesh(
                    new THREE.SphereGeometry(0.1, 8, 8),
                    new THREE.MeshBasicMaterial({color:0x00ffff})
                );
                p1.position.set(Math.cos(angle)*r, y, Math.sin(angle)*r);
                helixPoints1.push(p1);
                grp.add(p1);
                
                // Strand 2 (opposite)
                const p2 = new THREE.Mesh(
                    new THREE.SphereGeometry(0.1, 8, 8),
                    new THREE.MeshBasicMaterial({color:0xff00ff})
                );
                p2.position.set(Math.cos(angle+Math.PI)*r, y, Math.sin(angle+Math.PI)*r);
                helixPoints2.push(p2);
                grp.add(p2);
                
                // Base Pair Connection
                if(i % 3 === 0) {
                    const lineGeo = new THREE.BufferGeometry();
                    lineGeo.setAttribute('position', new THREE.BufferAttribute(
                        new Float32Array([
                            p1.position.x, p1.position.y, p1.position.z,
                            p2.position.x, p2.position.y, p2.position.z
                        ]), 3
                    ));
                    const line = new THREE.Line(lineGeo, new THREE.LineBasicMaterial({color:0xffffff, transparent:true, opacity:0.3}));
                    grp.add(line);
                }
            }
            
            // Backbone Lines
            const backbone1Geo = new THREE.BufferGeometry();
            const bb1Pos = [];
            helixPoints1.forEach(p => bb1Pos.push(p.position.x, p.position.y, p.position.z));
            backbone1Geo.setAttribute('position', new THREE.Float32BufferAttribute(bb1Pos, 3));
            const backbone1 = new THREE.Line(backbone1Geo, new THREE.LineBasicMaterial({color:0x00ffff, transparent:true, opacity:0.5}));
            grp.add(backbone1);
            
            const backbone2Geo = new THREE.BufferGeometry();
            const bb2Pos = [];
            helixPoints2.forEach(p => bb2Pos.push(p.position.x, p.position.y, p.position.z));
            backbone2Geo.setAttribute('position', new THREE.Float32BufferAttribute(bb2Pos, 3));
            const backbone2 = new THREE.Line(backbone2Geo, new THREE.LineBasicMaterial({color:0xff00ff, transparent:true, opacity:0.5}));
            grp.add(backbone2);
            
            // Light Emission (Bio-Photons)
            const photonGeo = new THREE.BufferGeometry();
            const photonPos = new Float32Array(100*3);
            const photonBases = [];
            for(let i=0; i<100; i++) {
                photonBases.push({y: Math.random()*10-5, offset: Math.random()*Math.PI*2, speed: 0.5+Math.random()*0.5});
            }
            photonGeo.setAttribute('position', new THREE.BufferAttribute(photonPos,3));
            const photons = new THREE.Points(photonGeo, new THREE.PointsMaterial({color:0xffffff, size:0.08, transparent:true, opacity:0.7}));
            grp.add(photons);
            
            scene.add(grp);
            
            let time = 0;
            function animateDNA() {
                time += 0.016;
                grp.rotation.y = time*0.1;
                
                // Pulse animation
                helixPoints1.forEach((p, i) => {
                    p.scale.setScalar(1 + Math.sin(time*2 + i*0.2)*0.2);
                });
                helixPoints2.forEach((p, i) => {
                    p.scale.setScalar(1 + Math.sin(time*2 + i*0.2 + Math.PI)*0.2);
                });
                
                // Bio-photon emission
                photonBases.forEach((b, i) => {
                    const angle = time*b.speed + b.offset;
                    const r = 1.5 + Math.sin(time*2+b.offset)*0.3;
                    photonPos[i*3] = Math.cos(angle)*r;
                    photonPos[i*3+1] = b.y;
                    photonPos[i*3+2] = Math.sin(angle)*r;
                });
                photonGeo.attributes.position.needsUpdate = true;
                requestAnimationFrame(animateDNA);
            }
            animateDNA();
        }

        // Learning Game
        function loadGame(chapterIndex) {
            const chapterId = CHAPTERS[chapterIndex].id;
            if (!QUIZZES[chapterId]) {
                document.getElementById('game-overlay').classList.remove('active');
                return;
            }
            // Check for game over state
            if (totalStrikes >= 3) {
                showGameOverScreen();
                return;
            }
            getQuizProgress(chapterId);
            updateQuizProgressUI(chapterId);
            updateStrikesUI();
            showTooltipHint();
            activeQuizQuestion = null;
            awaitingNextQuestion = false;
            const skipBtn = document.getElementById('skip-btn');
            const text = getQuizTextPack();
            if (skipBtn && text) {
                skipBtn.textContent = text.skipLabel;
            }
        }

        function getQuizProgress(chapterId) {
            if (!quizProgress[chapterId]) {
                quizProgress[chapterId] = { coreIndex: 0, extraIndex: 0, completedCore: false };
            }
            return quizProgress[chapterId];
        }

        function getQuizTextPack() {
            return QUIZ_TEXT[currentLanguage] || QUIZ_TEXT.de;
        }

        function getQuestionKey(chapterId, pool, idx) {
            return `${chapterId}_${pool}_${idx}`;
        }

        function resolveNextQuestion(chapterId) {
            const quiz = QUIZZES[chapterId];
            if (!quiz) return null;
            const progress = getQuizProgress(chapterId);
            
            // First check retry queue for this chapter
            const retryIdx = retryQueue.findIndex(r => r.chapterId === chapterId);
            if (retryIdx !== -1) {
                const retry = retryQueue.splice(retryIdx, 1)[0];
                return {
                    chapterId,
                    pool: retry.pool,
                    indexKey: retry.pool === 'core' ? 'coreIndex' : 'extraIndex',
                    list: quiz[retry.pool],
                    question: retry.question,
                    questionIdx: retry.questionIdx,
                    isRetry: true
                };
            }
            
            const pool = progress.completedCore ? 'extra' : 'core';
            const list = quiz[pool];
            if (!list || list.length === 0) {
                if (pool === 'core') {
                    progress.completedCore = true;
                    return resolveNextQuestion(chapterId);
                }
                return null;
            }
            const indexKey = pool === 'core' ? 'coreIndex' : 'extraIndex';
            const idx = progress[indexKey] || 0;
            if (idx >= list.length) {
                if (pool === 'core') {
                    progress.completedCore = true;
                    return resolveNextQuestion(chapterId);
                }
                return null;
            }
            return {
                chapterId,
                pool,
                indexKey,
                list,
                question: list[idx],
                questionIdx: idx,
                isRetry: false
            };
        }

        function getLocalizedQuestionText(question) {
            const lang = currentLanguage === 'en' ? 'en' : 'de';
            return question.question[lang] || question.question.de;
        }

        function getLocalizedOptions(question) {
            const lang = currentLanguage === 'en' ? 'en' : 'de';
            return question.options[lang] || question.options.de || [];
        }

        function getLocalizedExplanation(question) {
            const lang = currentLanguage === 'en' ? 'en' : 'de';
            return question.explanation[lang] || question.explanation.de;
        }

        function showGameQuestion() {
            const overlay = document.getElementById('game-overlay');
            if (!overlay || !overlay.classList.contains('active')) return;
            
            // Check game over
            if (totalStrikes >= 3) {
                showGameOverScreen();
                return;
            }
            
            const chapterId = CHAPTERS[currentChapter].id;
            const quiz = QUIZZES[chapterId];
            if (!quiz) {
                renderQuizCompleteMessage('quizComplete');
                return;
            }
            const next = resolveNextQuestion(chapterId);
            if (!next) {
                const progress = getQuizProgress(chapterId);
                updateQuizProgressUI(chapterId);
                renderQuizCompleteMessage(progress.completedCore ? 'quizAllComplete' : 'quizCoreComplete');
                awaitingNextQuestion = false;
                activeQuizQuestion = null;
                return;
            }

            activeQuizQuestion = next;
            awaitingNextQuestion = false;

            const questionText = getLocalizedQuestionText(next.question);
            const options = getLocalizedOptions(next.question);

            const questionEl = document.getElementById('game-question');
            const optionsDiv = document.getElementById('game-options');
            const feedback = document.getElementById('game-feedback');
            
            // Show retry indicator
            if (next.isRetry) {
                const retryLabel = currentLanguage === 'en' ? 'ðŸ”„ RETRY: ' : 'ðŸ”„ NOCHMAL: ';
                questionEl.innerHTML = `<span style="color:var(--gnosis)">${retryLabel}</span>${questionText}`;
            } else {
                questionEl.textContent = questionText;
            }
            
            if (optionsDiv) {
                optionsDiv.innerHTML = '';
                options.forEach((option, index) => {
                    const btn = document.createElement('div');
                    btn.className = 'game-option';
                    btn.textContent = option;
                    btn.onclick = () => handleAnswer(index);
                    optionsDiv.appendChild(btn);
                });
            }
            if (feedback) {
                feedback.classList.remove('show', 'correct', 'incorrect');
                feedback.innerHTML = '';
            }
            updateQuizProgressUI(chapterId);
            updateStrikesUI();
        }

        function handleAnswer(selectedIndex) {
            if (!activeQuizQuestion || awaitingNextQuestion) return;
            const { chapterId, pool, indexKey, list, question, questionIdx, isRetry } = activeQuizQuestion;
            const progress = getQuizProgress(chapterId);
            const correctIndex = question.correct;
            disableQuizOptions(selectedIndex, correctIndex);
            const isCorrect = selectedIndex === correctIndex;
            const questionKey = getQuestionKey(chapterId, pool, questionIdx);
            
            if (isCorrect) {
                // Correct answer - advance progress
                playCorrectSound();
                if (!isRetry) {
                    progress[indexKey] = Math.min(list.length, (progress[indexKey] || 0) + 1);
                }
                if (pool === 'core' && progress[indexKey] >= list.length) {
                    progress.completedCore = true;
                    playLevelUpSound();
                }
                showQuizFeedback(question, true, false, false);
            } else {
                // Wrong answer
                const attempts = (questionAttempts[questionKey] || 0) + 1;
                questionAttempts[questionKey] = attempts;
                
                if (attempts === 1 && !isRetry) {
                    // First failure - add to retry queue
                    playWrongSound();
                    retryQueue.push({ chapterId, pool, question, questionIdx });
                    progress[indexKey] = Math.min(list.length, (progress[indexKey] || 0) + 1);
                    showQuizFeedback(question, false, false, true); // Show retry hint
                } else {
                    // Second failure (retry failed) - count as strike
                    playStrikeSound();
                    totalStrikes++;
                    updateStrikesUI();
                    showQuizFeedback(question, false, false, false);
                    
                    if (totalStrikes >= 3) {
                        // Game over!
                        setTimeout(() => playGameOverSound(), 500);
                        blockSeed(currentProfile.name, currentProfile.seed);
                        saveProgress();
                        setTimeout(() => showGameOverScreen(), 1500);
                    }
                }
            }
            
            awaitingNextQuestion = true;
            saveProgress();
            updateQuizProgressUI(chapterId);
            checkAndUnlockNext(chapterId);
        }

        function disableQuizOptions(selected, correct) {
            document.querySelectorAll('.game-option').forEach((opt, idx) => {
                opt.onclick = null;
                opt.classList.remove('correct', 'incorrect');
                if (idx === correct) {
                    opt.classList.add('correct');
                } else if (selected !== null && idx === selected && selected !== correct) {
                    opt.classList.add('incorrect');
                }
            });
        }

        function showQuizFeedback(question, isCorrect, skipped, willRetry) {
            const feedback = document.getElementById('game-feedback');
            if (!feedback) return;
            const explanation = getLocalizedExplanation(question);
            const text = getQuizTextPack();
            const stateClass = isCorrect ? 'correct' : 'incorrect';
            feedback.classList.remove('correct', 'incorrect', 'show');
            const sourceLink = buildSourceLink(question.source);
            let baseText = skipped ? `${text.skipPenalty} ${explanation}` : explanation;
            
            // Add retry hint if applicable
            let retryHint = '';
            if (willRetry) {
                retryHint = `<span class="retry-hint">${text.retryHint}</span>`;
            }
            
            feedback.innerHTML = sourceLink 
                ? `${baseText}${retryHint}<div class="source-link">${sourceLink}</div>` 
                : `${baseText}${retryHint}`;
            feedback.classList.add('show', stateClass);
        }

        function buildSourceLink(sourceIdx) {
            if (typeof sourceIdx !== 'number') return '';
            const url = SOURCES[sourceIdx];
            if (!url) return '';
            const label = getQuizTextPack().sourceLink;
            return `<a href="${url}" target="_blank" rel="noopener noreferrer">${label}</a>`;
        }

        function updateStrikesUI() {
            const strikesEl = document.getElementById('game-strikes');
            if (!strikesEl) return;
            const hearts = ['â¤ï¸', 'â¤ï¸', 'â¤ï¸'];
            for (let i = 0; i < totalStrikes && i < 3; i++) {
                hearts[i] = 'ðŸ–¤';
            }
            strikesEl.querySelector('.strike-label').textContent = hearts.join('');
            if (totalStrikes > 0) {
                strikesEl.classList.add('warning');
                setTimeout(() => strikesEl.classList.remove('warning'), 500);
            }
        }

        function showGameOverScreen() {
            const text = getQuizTextPack();
            const questionEl = document.getElementById('game-question');
            const optionsDiv = document.getElementById('game-options');
            const feedback = document.getElementById('game-feedback');
            const tooltip = document.getElementById('game-tooltip');
            
            if (tooltip) tooltip.classList.remove('show');
            if (questionEl) {
                questionEl.innerHTML = `<div class="game-over-screen">
                    <h2>${text.gameOver}</h2>
                    <p>${text.gameOverMsg}</p>
                    <p style="color:var(--gnosis)">${text.newSeedRequired}</p>
                </div>`;
            }
            if (optionsDiv) optionsDiv.innerHTML = '';
            if (feedback) {
                feedback.classList.remove('show');
                feedback.innerHTML = '';
            }
        }

        function showTooltipHint() {
            if (!showTooltips) return;
            const tooltip = document.getElementById('game-tooltip');
            if (!tooltip) return;
            const text = getQuizTextPack();
            const progress = getQuizProgress(CHAPTERS[currentChapter].id);
            
            let hint = '';
            if (!progress.completedCore) {
                hint = text.tooltipCore;
            } else {
                hint = text.tooltipExtra;
            }
            if (totalStrikes > 0) {
                hint += ` â€¢ ${text.strikes}: ${totalStrikes}/3`;
            }
            
            tooltip.textContent = hint;
            tooltip.classList.add('show');
        }

        function toggleGame() {
            const overlay = document.getElementById('game-overlay');
            overlay.classList.toggle('active');
            if (overlay.classList.contains('active')) {
                updateStrikesUI();
                showGameQuestion();
            }
        }

        function toggleGameHelp() {
            const modal = document.getElementById('game-help-modal');
            if (modal) {
                modal.classList.toggle('active');
                // Update checkbox state
                const cb = document.getElementById('tooltip-toggle-cb');
                if (cb) cb.checked = !showTooltips;
                
                // Update help text based on language
                const text = getQuizTextPack();
                const helpTitle = document.getElementById('help-title');
                if (helpTitle) helpTitle.textContent = text.helpTitle;
                document.getElementById('help-tip-1').textContent = 'ðŸŽ¯ ' + text.tooltipCore;
                document.getElementById('help-tip-2').textContent = 'ðŸŽµ ' + text.tooltipExtra;
                document.getElementById('help-tip-3').textContent = 'ðŸ”„ ' + text.tooltipRetry;
                document.getElementById('help-tip-4').textContent = 'ðŸ’€ ' + text.tooltipStrikes;
                document.getElementById('hide-tooltips-label').textContent = text.hideTooltips;
            }
        }

        function closeGameHelp() {
            const modal = document.getElementById('game-help-modal');
            if (modal) modal.classList.remove('active');
        }

        function toggleTooltipsPref(hide) {
            showTooltips = !hide;
            saveProgress();
            const tooltip = document.getElementById('game-tooltip');
            if (tooltip) {
                if (showTooltips) {
                    showTooltipHint();
                } else {
                    tooltip.classList.remove('show');
                }
            }
        }

        function nextGameQuestion() {
            if (!awaitingNextQuestion) {
                if (!activeQuizQuestion) {
                    showGameQuestion();
                    return;
                }
                showToast(getQuizTextPack().skipBlocked);
                return;
            }
            awaitingNextQuestion = false;
            activeQuizQuestion = null;
            showGameQuestion();
        }

        function skipCurrentQuestion() {
            if (!activeQuizQuestion || awaitingNextQuestion) {
                showToast(getQuizTextPack().skipBlocked);
                return;
            }
            if (!confirm(getQuizTextPack().skipConfirm)) return;
            playClickSound();
            const { chapterId, pool, indexKey, list, question, questionIdx, isRetry } = activeQuizQuestion;
            const progress = getQuizProgress(chapterId);
            const questionKey = getQuestionKey(chapterId, pool, questionIdx);
            
            // Skip counts as wrong answer
            const attempts = (questionAttempts[questionKey] || 0) + 1;
            questionAttempts[questionKey] = attempts;
            
            if (attempts === 1 && !isRetry) {
                // First skip - add to retry queue
                playRetrySound();
                retryQueue.push({ chapterId, pool, question, questionIdx });
                progress[indexKey] = Math.min(list.length, (progress[indexKey] || 0) + 1);
            } else {
                // Second skip - count as strike
                playStrikeSound();
                totalStrikes++;
                updateStrikesUI();
                if (totalStrikes >= 3) {
                    setTimeout(() => playGameOverSound(), 500);
                    blockSeed(currentProfile.name, currentProfile.seed);
                    saveProgress();
                    setTimeout(() => showGameOverScreen(), 1500);
                }
            }
            
            disableQuizOptions(null, question.correct);
            awaitingNextQuestion = true;
            showQuizFeedback(question, false, true, attempts === 1 && !isRetry);
            saveProgress();
            updateQuizProgressUI(chapterId);
            checkAndUnlockNext(chapterId);
        }

        function updateQuizProgressUI(chapterId) {
            const progressEl = document.getElementById('game-progress');
            const quiz = QUIZZES[chapterId];
            if (!progressEl || !quiz) return;
            const progress = getQuizProgress(chapterId);
            const text = getQuizTextPack();
            const coreTotal = quiz.core.length;
            const extraTotal = quiz.extra.length;
            const corePart = `${text.coreLabel}: ${Math.min(progress.coreIndex, coreTotal)}/${coreTotal}`;
            const extraPart = extraTotal > 0 ? ` â€¢ ${text.extraLabel}: ${Math.min(progress.extraIndex, extraTotal)}/${extraTotal}` : '';
            const retryPart = retryQueue.length > 0 ? ` â€¢ ðŸ”„${retryQueue.length}` : '';
            progressEl.textContent = corePart + extraPart + retryPart;
        }

        function renderQuizCompleteMessage(messageKey) {
            const text = getQuizTextPack();
            const message = text[messageKey] || text.quizComplete;
            const questionEl = document.getElementById('game-question');
            const optionsDiv = document.getElementById('game-options');
            const feedback = document.getElementById('game-feedback');
            const tooltip = document.getElementById('game-tooltip');
            if (tooltip) tooltip.classList.remove('show');
            if (questionEl) questionEl.textContent = message;
            if (optionsDiv) optionsDiv.innerHTML = '';
            if (feedback) {
                feedback.classList.remove('correct', 'incorrect');
                feedback.classList.remove('show');
                feedback.innerHTML = '';
            }
        }

        // === NEW ENHANCEMENT FUNCTIONS ===
        
        function markChapterVisited(chapterIndex) {
            if (!visitedChapters.includes(chapterIndex)) {
                visitedChapters.push(chapterIndex);
                saveProgress();
                updateProgressStats();
                const msg = currentLanguage === 'en'
                    ? `Chapter ${chapterIndex + 1} completed! (${visitedChapters.length}/15)`
                    : `Kapitel ${chapterIndex + 1} abgeschlossen! (${visitedChapters.length}/15)`;
                showToast(msg);
            }
        }
        
        function updateProgressStats() {
            const visited = visitedChapters.length;
            const total = CHAPTERS.length;
            const percent = Math.round((visited / total) * 100);
            
            // Update stats
            const statChapters = document.getElementById('stat-chapters');
            const statProgress = document.getElementById('stat-progress');
            const progressBar = document.getElementById('chapter-progress-bar');
            
            if (statChapters) statChapters.textContent = visited;
            if (statProgress) statProgress.textContent = percent + '%';
            if (progressBar) progressBar.style.width = percent + '%';
            
            refreshChapterCards();
        }
        
        // Toast notification
        function showToast(message, duration = 3000) {
            const toast = document.getElementById('toast');
            if (!toast) return;
            toast.textContent = message;
            toast.classList.add('show');
            setTimeout(() => toast.classList.remove('show'), duration);
        }
        
        // Scroll to top
        function scrollToTop() {
            window.scrollTo({ top: 0, behavior: 'smooth' });
        }
        
        // Scroll-to-top button visibility
        function updateScrollTopButton() {
            const btn = document.getElementById('scroll-top');
            if (!btn) return;
            if (window.scrollY > 500) {
                btn.classList.add('visible');
            } else {
                btn.classList.remove('visible');
            }
        }
        
        // Keyboard shortcuts
        function initKeyboardShortcuts() {
            document.addEventListener('keydown', (e) => {
                // Don't trigger if typing in input
                if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
                
                const sceneContainer = document.getElementById('scene-container');
                const isInScene = sceneContainer && sceneContainer.classList.contains('active');
                
                switch(e.key) {
                    case 'ArrowRight':
                        if (isInScene) { nextChapter(); e.preventDefault(); }
                        break;
                    case 'ArrowLeft':
                        if (isInScene) { prevChapter(); e.preventDefault(); }
                        break;
                    case 'Escape':
                        if (isInScene) { exitScene(); e.preventDefault(); }
                        closeModal();
                        break;
                    case '?':
                        showToast('â† â†’ Navigation | ESC ZurÃ¼ck | G Spiel | I Info');
                        break;
                    case 'g':
                    case 'G':
                        if (isInScene) { toggleGame(); e.preventDefault(); }
                        break;
                    case 'i':
                    case 'I':
                        if (isInScene) { openInfo(); e.preventDefault(); }
                        break;
                    case 'a':
                    case 'A':
                        openArchive();
                        e.preventDefault();
                        break;
                }
            });
            
            // Show keyboard hints on desktop after 5 seconds
            const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
            if (!isMobile) {
                setTimeout(() => {
                    const hints = document.getElementById('keyboard-hints');
                    if (hints) hints.classList.add('visible');
                    setTimeout(() => hints?.classList.remove('visible'), 8000);
                }, 5000);
            }
        }
        
        // Initialize scroll listener
        window.addEventListener('scroll', updateScrollTopButton);
        
        // Initialize keyboard shortcuts
        initKeyboardShortcuts();

        // Profile panel init
        function initProfilePanel() {
            const nameInput = document.getElementById('profile-name');
            const seedInput = document.getElementById('profile-seed');
            const applyBtn = document.getElementById('profile-apply');
            const resetBtn = document.getElementById('profile-reset');
            if (!applyBtn || !resetBtn) return;

            applyBtn.onclick = () => {
                const name = (nameInput?.value || '').trim();
                const seed = (seedInput?.value || '').trim();
                if (!name) {
                    showToast(currentLanguage === 'en' ? 'Enter a name.' : 'Gib einen Namen ein.');
                    return;
                }
                // Check if seed is blocked for this name
                if (isSeedBlocked(name, seed)) {
                    const text = getQuizTextPack();
                    showToast(text.seedBlocked);
                    return;
                }
                currentProfile.name = name;
                currentProfile.seed = seed;
                const numericSeed = hashString(name + '::' + seed);
                initializeQuizData(numericSeed);
                const loaded = loadProgress();
                if (!loaded) {
                    initUnlocks();
                    resetGameState();
                }
                // Check if loaded profile is game over
                if (totalStrikes >= 3) {
                    blockSeed(name, seed);
                    showToast(getQuizTextPack().seedBlocked);
                    resetGameState();
                    return;
                }
                refreshChapterCards();
                updateProgressStats();
                showToast(currentLanguage === 'en' ? `Profile "${name}" activated.` : `Profil "${name}" aktiviert.`);
            };

            resetBtn.onclick = () => {
                if (!confirm(currentLanguage === 'en' ? 'Reset all progress for this profile?' : 'Gesamten Fortschritt fÃ¼r dieses Profil zurÃ¼cksetzen?')) return;
                resetProgress();
                resetGameState();
                initializeQuizData();
                refreshChapterCards();
                updateProgressStats();
                showToast(currentLanguage === 'en' ? 'Progress reset.' : 'Fortschritt zurÃ¼ckgesetzt.');
            };
        }

        // Utility
        function scrollToDashboard() {
            document.getElementById('dashboard').scrollIntoView({ behavior: 'smooth' });
        }

        // --- MODAL FUNCTIONS ---
        function closeModal() {
            document.querySelectorAll('.modal-overlay').forEach(m => m.classList.remove('active'));
        }

        // Exegesis language toggle
        let exegesisLanguage = currentLanguage; // Initialize with site language
        
        function toggleExegesisLanguage() {
            exegesisLanguage = exegesisLanguage === 'de' ? 'en' : 'de';
            updateExegesisDisplay();
        }

        function updateExegesisDisplay() {
            const deContent = document.getElementById('exegesis-de');
            const enContent = document.getElementById('exegesis-en');
            const toggleBtn = document.getElementById('exegesis-lang-toggle');
            const title = document.getElementById('exegesis-title');
            
            if (exegesisLanguage === 'en') {
                if (deContent) deContent.style.display = 'none';
                if (enContent) enContent.style.display = 'block';
                if (toggleBtn) toggleBtn.innerHTML = 'ðŸŒ DE';
                if (title) title.textContent = 'Scientific Exegesis: System Architecture 3-6-9';
            } else {
                if (deContent) deContent.style.display = 'block';
                if (enContent) enContent.style.display = 'none';
                if (toggleBtn) toggleBtn.innerHTML = 'ðŸŒ EN';
                if (title) title.textContent = 'Wissenschaftliche Exegese: Systemarchitektur 3-6-9';
            }
        }

        // Initialize exegesis language based on detected language
        function initExegesisLanguage() {
            exegesisLanguage = currentLanguage;
            updateExegesisDisplay();
        }

        function openArchive() {
            buildArchiveList();
            document.getElementById('archive-modal').classList.add('active');
        }

        function openInfo() {
            const ch = CHAPTERS[currentChapter];
            document.getElementById('info-title').innerText = ch.title;
            document.getElementById('info-desc').innerText = ch.desc;
            
            const ul = document.getElementById('info-sources');
            ul.innerHTML = '';
            
            if (ch.src && ch.src.length > 0) {
                ch.src.forEach(idx => {
                    if (SOURCES[idx]) {
                        const url = SOURCES[idx];
                        const title = getSourceTitle(url);
                        const archiveUrl = getArchiveUrl(url);
                        
                        // Badge for archive status
                        let badge = '';
                        if (offlineMode) {
                            if (url.includes('youtube.com') || url.includes('researchgate.net') || url.includes('pubmed.ncbi.nlm.nih.gov')) {
                                badge = '<span class="archive-badge" style="background: #ff3366;">LIVE</span>';
                            } else {
                                badge = '<span class="archive-badge">ARCHIVE</span>';
                            }
                        }
                        
                        ul.innerHTML += `<li><a href="${archiveUrl}" target="_blank">${title}</a>${badge}</li>`;
                    }
                });
            } else {
                ul.innerHTML = '<li style="color:#666;">Keine Quellen fÃ¼r dieses Kapitel verfÃ¼gbar</li>';
            }
            
            document.getElementById('info-modal').classList.add('active');
        }

        function openExplanation() {
            document.getElementById('explanation-modal').classList.add('active');
        }

        function toggleOfflineMode(enabled) {
            offlineMode = enabled;
            buildArchiveList();
        }

        function getArchiveUrl(url) {
            if (!offlineMode) return url;
            // Some sites don't work well with archive.org
            if (url.includes('youtube.com') || url.includes('researchgate.net') || url.includes('pubmed.ncbi.nlm.nih.gov')) {
                return url;
            }
            return 'https://web.archive.org/web/' + url;
        }

        function getSourceTitle(url) {
            for (const [pattern, title] of Object.entries(SOURCE_TITLES)) {
                if (url.includes(pattern)) return title;
            }
            try {
                const domain = new URL(url).hostname.replace('www.', '');
                return domain.charAt(0).toUpperCase() + domain.slice(1);
            } catch (e) {
                return url.substring(0, 50) + '...';
            }
        }

        function buildArchiveList() {
            const ul = document.getElementById('archive-list');
            if (!ul) return;
            ul.innerHTML = '';
            
            SOURCES.forEach((url, i) => {
                const title = getSourceTitle(url);
                const archiveUrl = getArchiveUrl(url);
                
                // Determine if archive works for this URL
                let badge = '';
                if (offlineMode) {
                    const noArchive = url.includes('youtube.com') || url.includes('researchgate.net') || url.includes('pubmed.ncbi.nlm.nih.gov');
                    badge = noArchive 
                        ? '<span class="archive-badge" style="background: #ff3366;">LIVE</span>'
                        : '<span class="archive-badge">ARCHIVE</span>';
                }
                
                const li = document.createElement('li');
                li.innerHTML = `<a href="${archiveUrl}" target="_blank">${title}</a>${badge}`;
                ul.appendChild(li);
            });
        }

        // ========================================
        // === ANALYTICS SYSTEM (Privacy-First) ===
        // ========================================
        const Analytics = {
            enabled: true,
            sessionId: null,
            events: [],
            startTime: Date.now(),
            
            init() {
                this.sessionId = 'sess_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
                this.trackEvent('session_start', {
                    language: currentLanguage,
                    screenSize: `${window.innerWidth}x${window.innerHeight}`,
                    userAgent: navigator.userAgent.substring(0, 100)
                });
                window.addEventListener('beforeunload', () => this.flush());
                setInterval(() => this.flush(), 30000);
                console.log('[369 Analytics] Session:', this.sessionId);
            },
            
            trackEvent(name, data = {}) {
                if (!this.enabled) return;
                this.events.push({
                    event: name,
                    timestamp: Date.now(),
                    data: data
                });
            },
            
            trackChapterView(id, duration) { this.trackEvent('chapter_view', { id, duration }); },
            trackQuizAnswer(correct) { this.trackEvent('quiz_answer', { correct, strikes: totalStrikes }); },
            trackFeatureUsage(feature, action) { this.trackEvent('feature_use', { feature, action }); },
            trackVoiceCommand(cmd, success, action = '', confidence = 1) { 
                this.trackEvent('voice_cmd', { cmd, success, action, confidence: Math.round(confidence * 100) }); 
            },
            
            flush() {
                if (this.events.length === 0) return;
                try {
                    const stored = JSON.parse(localStorage.getItem('369_analytics') || '[]');
                    stored.push(...this.events);
                    if (stored.length > 500) stored.splice(0, stored.length - 500);
                    localStorage.setItem('369_analytics', JSON.stringify(stored));
                    this.events = [];
                } catch (e) {}
            },
            
            getStats() {
                const stored = JSON.parse(localStorage.getItem('369_analytics') || '[]');
                return {
                    totalEvents: stored.length,
                    sessions: [...new Set(stored.map(e => e.sessionId))].length
                };
            }
        };

        // ========================================
        // === DATA VISUALIZATION ENGINE ===
        // ========================================
        const DataVisualizer = {
            canvas: null,
            ctx: null,
            activeViz: 'vortex',
            animationId: null,
            particles: [],
            time: 0,
            speed: 0.5,
            particleCount: 500,
            lastFrame: 0,
            fps: 60,
            
            init() {
                this.canvas = document.getElementById('viz-canvas');
                if (!this.canvas) return;
                this.ctx = this.canvas.getContext('2d');
                this.resize();
                window.addEventListener('resize', () => this.resize());
                this.generateParticles();
                console.log('[369 Visualizer] Initialized');
            },
            
            resize() {
                const container = this.canvas.parentElement;
                this.canvas.width = container.clientWidth;
                this.canvas.height = container.clientHeight;
                this.centerX = this.canvas.width / 2;
                this.centerY = this.canvas.height / 2;
            },
            
            generateParticles() {
                this.particles = [];
                for (let i = 0; i < this.particleCount; i++) {
                    this.particles.push({
                        angle: Math.random() * Math.PI * 2,
                        radius: Math.random() * 200,
                        speed: 0.5 + Math.random() * 1.5,
                        size: 1 + Math.random() * 3,
                        alpha: 0.5 + Math.random() * 0.5,
                        digitalRoot: Math.floor(Math.random() * 9) + 1
                    });
                }
            },
            
            start() {
                if (this.animationId) return;
                this.lastFrame = performance.now();
                this.animate();
            },
            
            stop() {
                if (this.animationId) {
                    cancelAnimationFrame(this.animationId);
                    this.animationId = null;
                }
            },
            
            animate() {
                const now = performance.now();
                const delta = now - this.lastFrame;
                this.fps = Math.round(1000 / delta);
                this.lastFrame = now;
                
                const fpsEl = document.getElementById('viz-quality');
                if (fpsEl) fpsEl.textContent = this.fps + ' FPS';
                
                this.time += this.speed * 0.016;
                this.ctx.fillStyle = 'rgba(3, 3, 5, 0.15)';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                
                switch(this.activeViz) {
                    case 'vortex': this.renderVortex(); break;
                    case 'digital-root': this.renderDigitalRoot(); break;
                    case 'fibonacci': this.renderFibonacci(); break;
                    case 'solfeggio': this.renderSolfeggio(); break;
                    case 'tree': this.renderTreeOfLife(); break;
                }
                
                this.animationId = requestAnimationFrame(() => this.animate());
            },
            
            renderVortex() {
                const doubleCircuit = [1, 2, 4, 8, 7, 5];
                const fluxNumbers = [3, 6, 9];
                const radius = Math.min(this.centerX, this.centerY) * 0.65;
                const fluxRadius = radius * 0.35;
                
                // Draw material circuit
                this.ctx.strokeStyle = '#00f3ff';
                this.ctx.lineWidth = 2;
                this.ctx.beginPath();
                doubleCircuit.forEach((num, i) => {
                    const angle = (i / 6) * Math.PI * 2 - Math.PI / 2;
                    const x = this.centerX + Math.cos(angle) * radius;
                    const y = this.centerY + Math.sin(angle) * radius;
                    if (i === 0) this.ctx.moveTo(x, y);
                    else this.ctx.lineTo(x, y);
                    
                    this.ctx.save();
                    this.ctx.fillStyle = '#00f3ff';
                    this.ctx.font = 'bold 24px Courier New';
                    this.ctx.textAlign = 'center';
                    this.ctx.textBaseline = 'middle';
                    this.ctx.fillText(num, x, y);
                    this.ctx.restore();
                });
                this.ctx.closePath();
                this.ctx.stroke();
                
                // Draw flux triangle
                this.ctx.strokeStyle = '#ffaa00';
                this.ctx.beginPath();
                fluxNumbers.forEach((num, i) => {
                    const angle = (i / 3) * Math.PI * 2 - Math.PI / 2;
                    const x = this.centerX + Math.cos(angle) * fluxRadius;
                    const y = this.centerY + Math.sin(angle) * fluxRadius;
                    if (i === 0) this.ctx.moveTo(x, y);
                    else this.ctx.lineTo(x, y);
                    
                    this.ctx.save();
                    this.ctx.shadowColor = '#ffaa00';
                    this.ctx.shadowBlur = 20;
                    this.ctx.fillStyle = '#ffaa00';
                    this.ctx.font = 'bold 28px Courier New';
                    this.ctx.textAlign = 'center';
                    this.ctx.textBaseline = 'middle';
                    this.ctx.fillText(num, x, y);
                    this.ctx.restore();
                });
                this.ctx.closePath();
                this.ctx.stroke();
                
                // Animated particles
                this.particles.forEach((p, i) => {
                    const isFlux = [3, 6, 9].includes(p.digitalRoot);
                    const circuit = isFlux ? fluxNumbers : doubleCircuit;
                    const circuitRadius = isFlux ? fluxRadius : radius;
                    const progress = (this.time * p.speed + i / this.particles.length) % 1;
                    const index = Math.floor(progress * circuit.length);
                    const nextIndex = (index + 1) % circuit.length;
                    const t = (progress * circuit.length) % 1;
                    
                    const angle1 = (index / circuit.length) * Math.PI * 2 - Math.PI / 2;
                    const angle2 = (nextIndex / circuit.length) * Math.PI * 2 - Math.PI / 2;
                    const x1 = this.centerX + Math.cos(angle1) * circuitRadius;
                    const y1 = this.centerY + Math.sin(angle1) * circuitRadius;
                    const x2 = this.centerX + Math.cos(angle2) * circuitRadius;
                    const y2 = this.centerY + Math.sin(angle2) * circuitRadius;
                    
                    this.ctx.save();
                    this.ctx.fillStyle = isFlux ? '#ffaa00' : '#00f3ff';
                    this.ctx.globalAlpha = p.alpha * 0.7;
                    this.ctx.beginPath();
                    this.ctx.arc(x1 + (x2 - x1) * t, y1 + (y2 - y1) * t, p.size, 0, Math.PI * 2);
                    this.ctx.fill();
                    this.ctx.restore();
                });
                
                // Center 9
                this.ctx.save();
                this.ctx.shadowColor = '#9d00ff';
                this.ctx.shadowBlur = 40;
                this.ctx.fillStyle = '#9d00ff';
                this.ctx.font = 'bold 48px Courier New';
                this.ctx.textAlign = 'center';
                this.ctx.textBaseline = 'middle';
                const scale = 1 + Math.sin(this.time * 2) * 0.1;
                this.ctx.translate(this.centerX, this.centerY);
                this.ctx.scale(scale, scale);
                this.ctx.fillText('9', 0, 0);
                this.ctx.restore();
            },
            
            renderDigitalRoot() {
                const maxRadius = Math.min(this.centerX, this.centerY) * 0.8;
                const colors = ['#ff3366', '#ff6600', '#ffaa00', '#00ff88', '#00f3ff', '#0088ff', '#8888ff', '#ff00ff', '#9d00ff'];
                
                for (let arm = 0; arm < 9; arm++) {
                    const baseAngle = (arm / 9) * Math.PI * 2;
                    this.ctx.strokeStyle = colors[arm];
                    this.ctx.lineWidth = 2;
                    this.ctx.beginPath();
                    
                    for (let i = 0; i < 80; i++) {
                        const t = i / 80;
                        const angle = baseAngle + t * Math.PI * 4 + this.time;
                        const r = t * maxRadius;
                        const x = this.centerX + Math.cos(angle) * r;
                        const y = this.centerY + Math.sin(angle) * r;
                        if (i === 0) this.ctx.moveTo(x, y);
                        else this.ctx.lineTo(x, y);
                    }
                    this.ctx.stroke();
                    
                    const endAngle = baseAngle + Math.PI * 4 + this.time;
                    this.ctx.save();
                    this.ctx.fillStyle = colors[arm];
                    this.ctx.font = 'bold 18px Courier New';
                    this.ctx.textAlign = 'center';
                    this.ctx.fillText(arm + 1, this.centerX + Math.cos(endAngle) * maxRadius, this.centerY + Math.sin(endAngle) * maxRadius);
                    this.ctx.restore();
                }
            },
            
            renderFibonacci() {
                const phi = 1.618033988749;
                this.ctx.strokeStyle = '#ffaa00';
                this.ctx.lineWidth = 3;
                this.ctx.beginPath();
                
                for (let i = 0; i < 150; i++) {
                    const t = i / 150;
                    const angle = t * Math.PI * 6 + this.time * 0.3;
                    const r = Math.pow(phi, t * 5) * 8;
                    const x = this.centerX + Math.cos(angle) * r;
                    const y = this.centerY + Math.sin(angle) * r;
                    if (i === 0) this.ctx.moveTo(x, y);
                    else this.ctx.lineTo(x, y);
                }
                this.ctx.stroke();
                
                // PHI display
                this.ctx.save();
                this.ctx.fillStyle = '#ffaa00';
                this.ctx.font = '16px Courier New';
                this.ctx.fillText('Ï† = 1.618033...', 20, 30);
                this.ctx.restore();
                
                // Particles
                this.particles.forEach((p, i) => {
                    const progress = (this.time * p.speed * 0.3 + i / this.particles.length) % 1;
                    const angle = progress * Math.PI * 6 + this.time * 0.3;
                    const r = Math.pow(phi, progress * 5) * 8;
                    
                    this.ctx.save();
                    this.ctx.fillStyle = '#ffaa00';
                    this.ctx.globalAlpha = p.alpha * 0.6;
                    this.ctx.beginPath();
                    this.ctx.arc(this.centerX + Math.cos(angle) * r, this.centerY + Math.sin(angle) * r, p.size, 0, Math.PI * 2);
                    this.ctx.fill();
                    this.ctx.restore();
                });
            },
            
            renderSolfeggio() {
                const frequencies = [174, 285, 396, 417, 432, 528, 639, 741, 852, 963];
                const maxRadius = Math.min(this.centerX, this.centerY) * 0.85;
                
                frequencies.forEach((freq, i) => {
                    const r = (i + 1) / frequencies.length * maxRadius;
                    const hue = (freq - 174) / (963 - 174) * 270;
                    
                    this.ctx.strokeStyle = `hsl(${hue}, 100%, 50%)`;
                    this.ctx.lineWidth = 2;
                    this.ctx.beginPath();
                    this.ctx.arc(this.centerX, this.centerY, r, 0, Math.PI * 2);
                    this.ctx.stroke();
                    
                    // Pulsing nodes
                    const nodeCount = 6;
                    for (let j = 0; j < nodeCount; j++) {
                        const angle = (j / nodeCount) * Math.PI * 2 + this.time * (freq / 500);
                        const pulse = 1 + Math.sin(this.time * freq / 100) * 0.3;
                        const x = this.centerX + Math.cos(angle) * r;
                        const y = this.centerY + Math.sin(angle) * r;
                        
                        this.ctx.save();
                        this.ctx.fillStyle = `hsl(${hue}, 100%, 60%)`;
                        this.ctx.beginPath();
                        this.ctx.arc(x, y, 3 * pulse, 0, Math.PI * 2);
                        this.ctx.fill();
                        this.ctx.restore();
                    }
                    
                    // Label
                    this.ctx.save();
                    this.ctx.fillStyle = `hsl(${hue}, 100%, 60%)`;
                    this.ctx.font = '11px Courier New';
                    this.ctx.fillText(freq + 'Hz', this.centerX + r + 5, this.centerY);
                    this.ctx.restore();
                });
            },
            
            renderTreeOfLife() {
                const sefirot = [
                    { name: 'Keter', x: 0.5, y: 0.1, color: '#ffffff' },
                    { name: 'Chokhmah', x: 0.7, y: 0.2, color: '#888888' },
                    { name: 'Binah', x: 0.3, y: 0.2, color: '#000000' },
                    { name: 'Chesed', x: 0.7, y: 0.4, color: '#0000ff' },
                    { name: 'Gevurah', x: 0.3, y: 0.4, color: '#ff0000' },
                    { name: 'Tiferet', x: 0.5, y: 0.5, color: '#ffaa00' },
                    { name: 'Netzach', x: 0.7, y: 0.65, color: '#00ff00' },
                    { name: 'Hod', x: 0.3, y: 0.65, color: '#ff8800' },
                    { name: 'Yesod', x: 0.5, y: 0.8, color: '#9d00ff' },
                    { name: 'Malkuth', x: 0.5, y: 0.95, color: '#8b4513' }
                ];
                
                const paths = [[0,1],[0,2],[1,3],[2,4],[1,5],[2,5],[3,5],[4,5],[3,6],[4,7],[5,6],[5,7],[5,8],[6,8],[7,8],[8,9]];
                const w = this.canvas.width;
                const h = this.canvas.height;
                
                // Draw paths
                this.ctx.strokeStyle = 'rgba(255, 170, 0, 0.3)';
                this.ctx.lineWidth = 2;
                paths.forEach(([a, b]) => {
                    this.ctx.beginPath();
                    this.ctx.moveTo(sefirot[a].x * w, sefirot[a].y * h);
                    this.ctx.lineTo(sefirot[b].x * w, sefirot[b].y * h);
                    this.ctx.stroke();
                });
                
                // Draw sefirot
                sefirot.forEach((s, i) => {
                    const x = s.x * w;
                    const y = s.y * h;
                    const pulse = 1 + Math.sin(this.time * 2 + i) * 0.15;
                    const r = 20 * pulse;
                    
                    this.ctx.save();
                    this.ctx.shadowColor = s.color;
                    this.ctx.shadowBlur = 20;
                    this.ctx.fillStyle = s.color;
                    this.ctx.beginPath();
                    this.ctx.arc(x, y, r, 0, Math.PI * 2);
                    this.ctx.fill();
                    
                    this.ctx.fillStyle = s.color === '#000000' ? '#fff' : '#000';
                    this.ctx.font = 'bold 10px Arial';
                    this.ctx.textAlign = 'center';
                    this.ctx.textBaseline = 'middle';
                    this.ctx.fillText(s.name, x, y);
                    this.ctx.restore();
                });
                
                // Energy flow particles
                this.particles.slice(0, 100).forEach((p, i) => {
                    const pathIdx = i % paths.length;
                    const [a, b] = paths[pathIdx];
                    const progress = (this.time * p.speed * 0.5 + i / 100) % 1;
                    const x = sefirot[a].x * w + (sefirot[b].x * w - sefirot[a].x * w) * progress;
                    const y = sefirot[a].y * h + (sefirot[b].y * h - sefirot[a].y * h) * progress;
                    
                    this.ctx.save();
                    this.ctx.fillStyle = '#ffaa00';
                    this.ctx.globalAlpha = 0.7;
                    this.ctx.beginPath();
                    this.ctx.arc(x, y, 3, 0, Math.PI * 2);
                    this.ctx.fill();
                    this.ctx.restore();
                });
            },
            
            switchVisualization(type) {
                this.activeViz = type;
                this.time = 0;
                document.querySelectorAll('.viz-tab').forEach(tab => {
                    tab.classList.toggle('active', tab.dataset.viz === type);
                });
                Analytics.trackFeatureUsage('visualization', type);
            },
            
            updateSpeed(value) {
                this.speed = parseFloat(value) / 100;
                document.getElementById('viz-speed-val').textContent = value + '%';
            },
            
            updateParticleCount(value) {
                this.particleCount = parseInt(value);
                this.generateParticles();
                document.getElementById('viz-particles-val').textContent = value;
            },
            
            export() {
                const link = document.createElement('a');
                link.download = `369-${this.activeViz}-${Date.now()}.png`;
                link.href = this.canvas.toDataURL();
                link.click();
                showToast(currentLanguage === 'en' ? 'Visualization exported!' : 'Visualisierung exportiert!');
            }
        };

        // ========================================
        // === VOICE CONTROL SYSTEM (SECTION 10) ===
        // ========================================
        const VoiceControl = {
            recognition: null,
            isListening: false,
            isSupported: false,
            continuousMode: false,
            commandHistory: [],
            lastCommand: null,
            
            // All supported commands for help display
            commandList: {
                de: [
                    { cmd: 'Kapitel [1-15]', desc: 'Kapitel Ã¶ffnen' },
                    { cmd: 'ZurÃ¼ck / Home', desc: 'Zur Ãœbersicht' },
                    { cmd: 'Weiter', desc: 'NÃ¤chstes Kapitel' },
                    { cmd: 'Quiz', desc: 'Quiz starten/stoppen' },
                    { cmd: 'Ton / Generator', desc: 'Tongenerator Ã¶ffnen' },
                    { cmd: 'Frequenz [Hz]', desc: 'Frequenz einstellen' },
                    { cmd: 'Spielen / Stopp', desc: 'Ton abspielen/stoppen' },
                    { cmd: 'Visualisierung', desc: 'Visualisierung Ã¶ffnen' },
                    { cmd: 'Stumm / Laut', desc: 'Audio stumm/laut' },
                    { cmd: 'Hilfe', desc: 'Befehle anzeigen' },
                    { cmd: 'SchlieÃŸen', desc: 'Aktives Panel schlieÃŸen' }
                ],
                en: [
                    { cmd: 'Chapter [1-15]', desc: 'Open chapter' },
                    { cmd: 'Back / Home', desc: 'Return to overview' },
                    { cmd: 'Next', desc: 'Next chapter' },
                    { cmd: 'Quiz', desc: 'Start/stop quiz' },
                    { cmd: 'Tone / Generator', desc: 'Open tone generator' },
                    { cmd: 'Frequency [Hz]', desc: 'Set frequency' },
                    { cmd: 'Play / Stop', desc: 'Play/stop tone' },
                    { cmd: 'Visualization', desc: 'Open visualization' },
                    { cmd: 'Mute / Unmute', desc: 'Mute/unmute audio' },
                    { cmd: 'Help', desc: 'Show commands' },
                    { cmd: 'Close', desc: 'Close active panel' }
                ]
            },
            
            init() {
                const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
                if (!SpeechRecognition) {
                    console.log('[369 Voice] Speech Recognition not supported');
                    this.hideVoiceUI();
                    return;
                }
                
                this.isSupported = true;
                this.recognition = new SpeechRecognition();
                this.recognition.lang = currentLanguage === 'en' ? 'en-US' : 'de-DE';
                this.recognition.continuous = false;
                this.recognition.interimResults = true; // Show interim results
                this.recognition.maxAlternatives = 3; // Get alternatives for better matching
                
                this.recognition.onresult = (event) => {
                    const result = event.results[event.results.length - 1];
                    const transcript = result[0].transcript.toLowerCase().trim();
                    const confidence = result[0].confidence;
                    
                    // Show interim feedback
                    if (!result.isFinal) {
                        this.showFeedback(transcript, 'interim');
                        return;
                    }
                    
                    // Final result
                    this.showFeedback(transcript, 'final');
                    this.parseCommand(transcript, confidence);
                    
                    // Store in history
                    this.commandHistory.push({
                        text: transcript,
                        confidence: confidence,
                        timestamp: Date.now(),
                        success: this.lastCommand?.success
                    });
                    
                    // Keep only last 20 commands
                    if (this.commandHistory.length > 20) {
                        this.commandHistory.shift();
                    }
                };
                
                this.recognition.onend = () => {
                    this.isListening = false;
                    document.getElementById('voice-indicator')?.classList.remove('listening');
                    
                    // Restart if in continuous mode
                    if (this.continuousMode && this.isSupported) {
                        setTimeout(() => {
                            if (this.continuousMode) this.start();
                        }, 300);
                    }
                };
                
                this.recognition.onerror = (e) => {
                    console.log('[369 Voice] Error:', e.error);
                    this.isListening = false;
                    document.getElementById('voice-indicator')?.classList.remove('listening');
                    
                    // User-friendly error messages
                    if (e.error === 'not-allowed') {
                        showToast(currentLanguage === 'en' ? 'ðŸŽ¤ Microphone access denied' : 'ðŸŽ¤ Mikrofonzugriff verweigert');
                    } else if (e.error === 'no-speech') {
                        this.showFeedback(currentLanguage === 'en' ? 'No speech detected' : 'Keine Sprache erkannt', 'error');
                    }
                };
                
                this.recognition.onspeechstart = () => {
                    document.getElementById('voice-indicator')?.classList.add('speaking');
                };
                
                this.recognition.onspeechend = () => {
                    document.getElementById('voice-indicator')?.classList.remove('speaking');
                };
                
                // Show voice UI
                document.getElementById('voice-indicator')?.classList.add('available');
                console.log('[369 Voice] Initialized with enhanced commands');
            },
            
            hideVoiceUI() {
                const indicator = document.getElementById('voice-indicator');
                if (indicator) indicator.style.display = 'none';
            },
            
            start() {
                if (!this.isSupported || this.isListening) return;
                
                try {
                    this.recognition.lang = currentLanguage === 'en' ? 'en-US' : 'de-DE';
                    this.recognition.start();
                    this.isListening = true;
                    document.getElementById('voice-indicator')?.classList.add('listening');
                    this.showFeedback(currentLanguage === 'en' ? 'ðŸŽ¤ Listening...' : 'ðŸŽ¤ HÃ¶re zu...', 'listening');
                } catch (e) {
                    console.error('[369 Voice] Start error:', e);
                }
            },
            
            stop() {
                if (!this.isListening) return;
                this.continuousMode = false;
                this.recognition.stop();
            },
            
            toggle() {
                if (!this.isSupported) {
                    showToast(currentLanguage === 'en' ? 'ðŸŽ¤ Voice control not supported in this browser' : 'ðŸŽ¤ Sprachsteuerung wird in diesem Browser nicht unterstÃ¼tzt');
                    return;
                }
                
                if (this.isListening) {
                    this.stop();
                    showToast(currentLanguage === 'en' ? 'ðŸŽ¤ Voice control stopped' : 'ðŸŽ¤ Sprachsteuerung beendet');
                } else {
                    this.start();
                }
            },
            
            toggleContinuous() {
                this.continuousMode = !this.continuousMode;
                if (this.continuousMode) {
                    this.start();
                    showToast(currentLanguage === 'en' ? 'ðŸŽ¤ Continuous listening ON' : 'ðŸŽ¤ Dauerhaftes ZuhÃ¶ren AN');
                } else {
                    this.stop();
                    showToast(currentLanguage === 'en' ? 'ðŸŽ¤ Continuous listening OFF' : 'ðŸŽ¤ Dauerhaftes ZuhÃ¶ren AUS');
                }
            },
            
            showFeedback(text, type = 'normal') {
                const el = document.getElementById('voice-feedback');
                if (!el) return;
                
                el.textContent = text;
                el.className = 'voice-feedback show ' + type;
                
                // Different display times based on type
                const duration = type === 'interim' ? 500 : (type === 'error' ? 3000 : 2000);
                
                clearTimeout(this.feedbackTimeout);
                this.feedbackTimeout = setTimeout(() => {
                    el.classList.remove('show');
                }, duration);
            },
            
            parseCommand(text, confidence = 1) {
                // Extended command patterns
                const commands = {
                    de: {
                        'kapitel': /kapitel\s*(\d+)/i,
                        'zurÃ¼ck': /zurÃ¼ck|home|startseite|Ã¼bersicht/i,
                        'weiter': /weiter|nÃ¤chstes?\s*kapitel|vorwÃ¤rts/i,
                        'quiz': /quiz\s*(starten|start|Ã¶ffnen)?/i,
                        'ton': /ton\s*(generator)?|generator|frequenz\s*generator/i,
                        'frequenz': /frequenz\s*(\d+)|(\d+)\s*hertz|(\d+)\s*hz/i,
                        'spielen': /spielen|abspielen|starten|play/i,
                        'stopp': /stopp|stop|halt|beenden|aus/i,
                        'visualisierung': /visualisierung|vortex|grafik/i,
                        'stumm': /stumm|mute|leise/i,
                        'laut': /laut|unmute|ton\s*an/i,
                        'hilfe': /hilfe|help|befehle|commands/i,
                        'schlieÃŸen': /schlieÃŸen|close|beenden|exit/i,
                        'solfeggio': /solfeggio\s*(\d+)|(\d+)\s*solfeggio/i,
                        'binaural': /binaural\s*(an|aus|on|off)?/i,
                        'shader': /shader\s*(an|aus|on|off)?|effekte/i,
                        'leistung': /leistung|performance|fps/i
                    },
                    en: {
                        'chapter': /chapter\s*(\d+)|go\s*to\s*(\d+)/i,
                        'back': /back|return|home|overview/i,
                        'next': /next\s*(chapter)?|forward|continue/i,
                        'quiz': /quiz\s*(start|open)?/i,
                        'tone': /tone\s*(generator)?|generator|frequency\s*generator/i,
                        'frequency': /frequency\s*(\d+)|(\d+)\s*hertz|(\d+)\s*hz/i,
                        'play': /play|start\s*tone/i,
                        'stop': /stop|halt|end|off/i,
                        'visualization': /visualization|vortex|graphics/i,
                        'mute': /mute|quiet|silence/i,
                        'unmute': /unmute|sound\s*on|audio\s*on/i,
                        'help': /help|commands|what\s*can/i,
                        'close': /close|exit|dismiss/i,
                        'solfeggio': /solfeggio\s*(\d+)|(\d+)\s*solfeggio/i,
                        'binaural': /binaural\s*(on|off)?/i,
                        'shader': /shader\s*(on|off)?|effects/i,
                        'performance': /performance|fps|stats/i
                    }
                };
                
                const lang = currentLanguage === 'en' ? 'en' : 'de';
                const cmds = commands[lang];
                let success = false;
                let action = '';
                
                // Chapter navigation
                const chapterMatch = text.match(cmds[lang === 'de' ? 'kapitel' : 'chapter']);
                if (chapterMatch) {
                    const num = parseInt(chapterMatch[1] || chapterMatch[2]);
                    if (num >= 1 && num <= 15) {
                        tryEnterScene(num - 1);
                        action = `chapter_${num}`;
                        success = true;
                        AccessibilityManager?.announce(`${lang === 'de' ? 'Ã–ffne Kapitel' : 'Opening chapter'} ${num}`);
                    }
                }
                
                // Back/Home
                if (!success && cmds[lang === 'de' ? 'zurÃ¼ck' : 'back'].test(text)) {
                    exitScene();
                    action = 'back';
                    success = true;
                }
                
                // Next chapter
                if (!success && cmds[lang === 'de' ? 'weiter' : 'next'].test(text)) {
                    if (typeof currentSceneIndex !== 'undefined' && currentSceneIndex !== null && currentSceneIndex < 14) {
                        tryEnterScene(currentSceneIndex + 1);
                        action = 'next_chapter';
                        success = true;
                    }
                }
                
                // Quiz
                if (!success && cmds.quiz.test(text)) {
                    toggleGame();
                    action = 'quiz';
                    success = true;
                }
                
                // Tone generator
                if (!success && cmds[lang === 'de' ? 'ton' : 'tone'].test(text)) {
                    toggleToneGenerator();
                    action = 'tone_generator';
                    success = true;
                }
                
                // Frequency
                if (!success) {
                    const freqMatch = text.match(cmds[lang === 'de' ? 'frequenz' : 'frequency']);
                    if (freqMatch) {
                        const freq = parseInt(freqMatch[1] || freqMatch[2] || freqMatch[3]);
                        if (freq >= 20 && freq <= 2000) {
                            selectPreset(freq);
                            action = `frequency_${freq}`;
                            success = true;
                        }
                    }
                }
                
                // Solfeggio preset
                if (!success) {
                    const solfeggioMatch = text.match(cmds.solfeggio);
                    if (solfeggioMatch) {
                        const freq = parseInt(solfeggioMatch[1] || solfeggioMatch[2]);
                        const validFreqs = [174, 285, 396, 417, 432, 528, 639, 741, 852, 963];
                        if (validFreqs.includes(freq)) {
                            selectPreset(freq);
                            action = `solfeggio_${freq}`;
                            success = true;
                        }
                    }
                }
                
                // Play tone
                if (!success && cmds[lang === 'de' ? 'spielen' : 'play'].test(text)) {
                    if (!tonePlaying) toggleTone();
                    action = 'play_tone';
                    success = true;
                }
                
                // Stop tone
                if (!success && cmds[lang === 'de' ? 'stopp' : 'stop'].test(text)) {
                    if (tonePlaying) toggleTone();
                    action = 'stop_tone';
                    success = true;
                }
                
                // Binaural toggle
                if (!success && cmds.binaural.test(text)) {
                    const match = text.match(cmds.binaural);
                    const state = match[1];
                    if (state === 'an' || state === 'on') {
                        if (!binauralEnabled) toggleBinaural();
                    } else if (state === 'aus' || state === 'off') {
                        if (binauralEnabled) toggleBinaural();
                    } else {
                        toggleBinaural();
                    }
                    action = 'binaural_toggle';
                    success = true;
                }
                
                // Visualization
                if (!success && cmds[lang === 'de' ? 'visualisierung' : 'visualization'].test(text)) {
                    openVisualizationModal();
                    action = 'visualization';
                    success = true;
                }
                
                // Mute
                if (!success && cmds[lang === 'de' ? 'stumm' : 'mute'].test(text)) {
                    if (typeof audioPlayer !== 'undefined' && audioPlayer) {
                        audioPlayer.muted = true;
                        showToast(currentLanguage === 'en' ? 'ðŸ”‡ Audio muted' : 'ðŸ”‡ Audio stumm');
                        action = 'mute';
                        success = true;
                    }
                }
                
                // Unmute
                if (!success && cmds[lang === 'de' ? 'laut' : 'unmute'].test(text)) {
                    if (typeof audioPlayer !== 'undefined' && audioPlayer) {
                        audioPlayer.muted = false;
                        showToast(currentLanguage === 'en' ? 'ðŸ”Š Audio on' : 'ðŸ”Š Audio an');
                        action = 'unmute';
                        success = true;
                    }
                }
                
                // Help
                if (!success && cmds[lang === 'de' ? 'hilfe' : 'help'].test(text)) {
                    this.showHelp();
                    action = 'help';
                    success = true;
                }
                
                // Close active panel
                if (!success && cmds[lang === 'de' ? 'schlieÃŸen' : 'close'].test(text)) {
                    AccessibilityManager?.closeActiveModal();
                    action = 'close';
                    success = true;
                }
                
                // Shader toggle
                if (!success && cmds.shader.test(text)) {
                    toggleShaderEffects();
                    action = 'shader_toggle';
                    success = true;
                }
                
                // Performance monitor
                if (!success && cmds[lang === 'de' ? 'leistung' : 'performance'].test(text)) {
                    togglePerformanceMonitor();
                    action = 'performance';
                    success = true;
                }
                
                // Track command
                this.lastCommand = { text, success, action, confidence };
                Analytics.trackVoiceCommand(text, success, action, confidence);
                
                if (!success) {
                    this.showFeedback(currentLanguage === 'en' ? 'â“ Command not recognized' : 'â“ Befehl nicht erkannt', 'error');
                } else {
                    this.showFeedback(`âœ“ ${action.replace(/_/g, ' ')}`, 'success');
                }
            },
            
            showHelp() {
                const lang = currentLanguage === 'en' ? 'en' : 'de';
                const cmds = this.commandList[lang];
                
                // Create help modal
                let helpModal = document.getElementById('voice-help-modal');
                if (!helpModal) {
                    helpModal = document.createElement('div');
                    helpModal.id = 'voice-help-modal';
                    helpModal.style.cssText = `
                        position: fixed;
                        top: 50%;
                        left: 50%;
                        transform: translate(-50%, -50%);
                        background: rgba(10, 10, 15, 0.95);
                        border: 2px solid var(--science, #00f3ff);
                        border-radius: 16px;
                        padding: 24px;
                        z-index: 10002;
                        max-width: 400px;
                        max-height: 80vh;
                        overflow-y: auto;
                        backdrop-filter: blur(20px);
                        box-shadow: 0 0 40px rgba(0, 243, 255, 0.3);
                    `;
                    document.body.appendChild(helpModal);
                }
                
                helpModal.innerHTML = `
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 16px;">
                        <h3 style="color: var(--science, #00f3ff); margin: 0;">ðŸŽ¤ ${lang === 'de' ? 'Sprachbefehle' : 'Voice Commands'}</h3>
                        <button onclick="document.getElementById('voice-help-modal').remove()" 
                            style="background: none; border: none; color: #fff; font-size: 24px; cursor: pointer; padding: 0;">Ã—</button>
                    </div>
                    <div style="display: grid; gap: 8px;">
                        ${cmds.map(c => `
                            <div style="display: flex; justify-content: space-between; padding: 8px; background: rgba(0,243,255,0.1); border-radius: 8px;">
                                <span style="color: #00ff88; font-family: monospace;">"${c.cmd}"</span>
                                <span style="color: #888; font-size: 0.85rem;">${c.desc}</span>
                            </div>
                        `).join('')}
                    </div>
                    <div style="margin-top: 16px; padding-top: 16px; border-top: 1px solid rgba(0,243,255,0.2); text-align: center;">
                        <small style="color: #666;">${lang === 'de' ? 'Klicke auf ðŸŽ¤ um zu starten' : 'Click ðŸŽ¤ to start'}</small>
                    </div>
                `;
                
                // Close on escape
                const closeOnEscape = (e) => {
                    if (e.key === 'Escape') {
                        helpModal.remove();
                        document.removeEventListener('keydown', closeOnEscape);
                    }
                };
                document.addEventListener('keydown', closeOnEscape);
            }
        };

        // ========================================
        // === PWA / SERVICE WORKER SYSTEM ===
        // ========================================
        const PWAManager = {
            deferredPrompt: null,
            isInstalled: false,
            registration: null,
            updateAvailable: false,
            
            init() {
                // Check if already running as PWA
                this.isInstalled = window.matchMedia('(display-mode: standalone)').matches ||
                                   window.navigator.standalone === true;
                
                if (this.isInstalled) {
                    console.log('[369 PWA] Running as installed app');
                    Analytics.trackEvent('pwa_running', { mode: 'standalone' });
                }
                
                // Register service worker
                if ('serviceWorker' in navigator) {
                    this.registerServiceWorker();
                }
                
                // Listen for install prompt
                window.addEventListener('beforeinstallprompt', (e) => {
                    e.preventDefault();
                    this.deferredPrompt = e;
                    this.showInstallPrompt();
                });
                
                // Listen for app installed
                window.addEventListener('appinstalled', () => {
                    console.log('[369 PWA] App installed successfully');
                    this.isInstalled = true;
                    this.hideInstallPrompt();
                    Analytics.trackEvent('pwa_installed', { success: true });
                    showToast('App erfolgreich installiert! ðŸŽ‰');
                });
                
                // Setup offline detection
                this.setupOfflineDetection();
                
                // Check for updates every 60 seconds
                setInterval(() => this.checkForUpdates(), 60000);
                
                console.log('[369 PWA] Manager initialized');
            },
            
            async registerServiceWorker() {
                try {
                    this.registration = await navigator.serviceWorker.register('./sw.js', {
                        scope: './'
                    });
                    
                    console.log('[369 PWA] Service Worker registered:', this.registration.scope);
                    Analytics.trackEvent('sw_registered', { scope: this.registration.scope });
                    
                    // Listen for updates
                    this.registration.addEventListener('updatefound', () => {
                        const newWorker = this.registration.installing;
                        
                        newWorker.addEventListener('statechange', () => {
                            if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
                                this.updateAvailable = true;
                                this.showUpdateNotification();
                            }
                        });
                    });
                    
                    // Check for waiting service worker
                    if (this.registration.waiting) {
                        this.updateAvailable = true;
                        this.showUpdateNotification();
                    }
                    
                } catch (error) {
                    console.error('[369 PWA] Service Worker registration failed:', error);
                    Analytics.trackEvent('sw_registration_failed', { error: error.message });
                }
            },
            
            showInstallPrompt() {
                // Show prompt after 30 seconds (not immediately)
                setTimeout(() => {
                    if (!this.isInstalled && this.deferredPrompt) {
                        const prompt = document.getElementById('pwa-install-prompt');
                        if (prompt) {
                            prompt.classList.add('show');
                            if (currentLanguage === 'en') {
                                const title = document.getElementById('pwa-title');
                                const desc = document.getElementById('pwa-desc');
                                if (title) title.textContent = 'Install as App';
                                if (desc) desc.textContent = 'Use offline & quick access';
                            }
                            Analytics.trackEvent('pwa_prompt_shown', {});
                        }
                        
                        // Also show button in advanced features panel
                        const btn = document.getElementById('pwa-install-btn');
                        if (btn) btn.style.display = 'flex';
                    }
                }, 30000);
            },
            
            hideInstallPrompt() {
                const prompt = document.getElementById('pwa-install-prompt');
                if (prompt) prompt.classList.remove('show');
                
                const btn = document.getElementById('pwa-install-btn');
                if (btn) btn.style.display = 'none';
            },
            
            async install() {
                if (!this.deferredPrompt) {
                    console.warn('[369 PWA] Install prompt not available');
                    return;
                }
                
                this.deferredPrompt.prompt();
                const { outcome } = await this.deferredPrompt.userChoice;
                
                Analytics.trackEvent('pwa_install_outcome', { outcome });
                
                if (outcome === 'accepted') {
                    console.log('[369 PWA] User accepted install');
                } else {
                    console.log('[369 PWA] User dismissed install');
                }
                
                this.deferredPrompt = null;
                this.hideInstallPrompt();
            },
            
            showUpdateNotification() {
                const notification = document.createElement('div');
                notification.id = 'pwa-update-notification';
                notification.style.cssText = `
                    position: fixed;
                    top: 60px;
                    right: 20px;
                    background: var(--glass);
                    border: 2px solid var(--science);
                    border-radius: 12px;
                    padding: 20px;
                    z-index: 10000;
                    backdrop-filter: blur(20px);
                    animation: slideInRight 0.3s ease;
                    max-width: 300px;
                `;
                
                const isEn = currentLanguage === 'en';
                notification.innerHTML = `
                    <div style="color: var(--science); font-weight: bold; margin-bottom: 10px;">
                        ðŸ”„ ${isEn ? 'Update Available' : 'Update verfÃ¼gbar'}
                    </div>
                    <div style="color: #aaa; font-size: 0.85rem; margin-bottom: 15px;">
                        ${isEn ? 'A new version is available. Update now?' : 'Eine neue Version ist verfÃ¼gbar. Jetzt aktualisieren?'}
                    </div>
                    <div style="display: flex; gap: 10px;">
                        <button onclick="PWAManager.applyUpdate()" style="flex: 1; padding: 8px; background: var(--science); color: #000; border: none; border-radius: 6px; cursor: pointer; font-weight: bold;">
                            ${isEn ? 'Update' : 'Aktualisieren'}
                        </button>
                        <button onclick="PWAManager.dismissUpdate()" style="flex: 1; padding: 8px; background: transparent; color: var(--science); border: 1px solid var(--science); border-radius: 6px; cursor: pointer;">
                            ${isEn ? 'Later' : 'SpÃ¤ter'}
                        </button>
                    </div>
                `;
                
                document.body.appendChild(notification);
                Analytics.trackEvent('pwa_update_shown', {});
            },
            
            applyUpdate() {
                if (this.registration && this.registration.waiting) {
                    this.registration.waiting.postMessage({ type: 'SKIP_WAITING' });
                    
                    navigator.serviceWorker.addEventListener('controllerchange', () => {
                        window.location.reload();
                    });
                }
                
                this.dismissUpdate();
            },
            
            dismissUpdate() {
                const notification = document.getElementById('pwa-update-notification');
                if (notification) notification.remove();
            },
            
            async checkForUpdates() {
                if (this.registration) {
                    await this.registration.update();
                }
            },
            
            setupOfflineDetection() {
                window.addEventListener('online', () => {
                    showToast(currentLanguage === 'en' ? 'âœ… Back online' : 'âœ… Online-Verbindung wiederhergestellt');
                    Analytics.trackEvent('network_online', {});
                });
                
                window.addEventListener('offline', () => {
                    showToast(currentLanguage === 'en' ? 'âš ï¸ Offline mode active' : 'âš ï¸ Offline-Modus aktiv');
                    Analytics.trackEvent('network_offline', {});
                });
            }
        };
        
        // Global helper functions for PWA
        function acceptPWAInstall() {
            PWAManager.install();
        }
        
        function dismissPWAInstall() {
            PWAManager.hideInstallPrompt();
            Analytics.trackEvent('pwa_prompt_dismissed', {});
        }

        // ========================================
        // === WEBXR / VR CONTROLLER ===
        // ========================================
        const VRController = {
            isSupported: false,
            session: null,
            
            async init() {
                if (!('xr' in navigator)) {
                    console.log('[369 VR] WebXR not supported');
                    return;
                }
                
                try {
                    this.isSupported = await navigator.xr.isSessionSupported('immersive-vr');
                    if (this.isSupported) {
                        document.getElementById('vr-mode-btn')?.classList.add('available');
                        console.log('[369 VR] VR mode available');
                    }
                } catch (e) {
                    console.log('[369 VR] VR check failed:', e);
                }
            },
            
            async enter() {
                if (!this.isSupported) {
                    showToast(currentLanguage === 'en' ? 'VR not supported on this device' : 'VR wird auf diesem GerÃ¤t nicht unterstÃ¼tzt');
                    return;
                }
                
                try {
                    // This would need Three.js VR integration
                    showToast(currentLanguage === 'en' ? 'VR mode requires Three.js WebXR setup' : 'VR-Modus benÃ¶tigt Three.js WebXR Setup');
                    Analytics.trackFeatureUsage('vr', 'attempted');
                } catch (e) {
                    console.error('[369 VR] Enter failed:', e);
                }
            }
        };

        // ========================================
        // === WEBGL SHADER SYSTEM ===
        // ========================================
        const ShaderEffects = {
            enabled: false,
            composer: null,
            bloomPass: null,
            glitchPass: null,
            quality: 'high', // 'high', 'medium', 'low'
            
            // Custom shader materials
            shaders: {
                energyField: null,
                consciousness: null,
                matrixRain: null
            },
            
            init(renderer, scene, camera) {
                // Check WebGL2 support
                const canvas = document.createElement('canvas');
                const gl = canvas.getContext('webgl2');
                if (!gl) {
                    console.warn('[369 Shaders] WebGL2 not supported, falling back to standard rendering');
                    this.quality = 'low';
                    return false;
                }
                
                // Detect GPU capability
                this.detectQuality();
                
                if (this.quality === 'low') {
                    console.log('[369 Shaders] Low-end GPU detected, shaders disabled');
                    return false;
                }
                
                try {
                    // Load THREE.js post-processing (inline to avoid external dependency)
                    this.loadPostProcessing(renderer, scene, camera);
                    this.enabled = true;
                    
                    // Create custom shader materials
                    this.createCustomShaders();
                    
                    console.log('[369 Shaders] Initialized with quality:', this.quality);
                    Analytics.trackEvent('shader_system_init', { quality: this.quality });
                    
                    return true;
                } catch (e) {
                    console.error('[369 Shaders] Failed to initialize:', e);
                    return false;
                }
            },
            
            detectQuality() {
                const canvas = document.createElement('canvas');
                const gl = canvas.getContext('webgl2') || canvas.getContext('webgl');
                
                if (!gl) {
                    this.quality = 'low';
                    return;
                }
                
                // Check max texture size
                const maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);
                const maxRenderbufferSize = gl.getParameter(gl.MAX_RENDERBUFFER_SIZE);
                
                // Check shader precision
                const fragmentPrecision = gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT);
                
                // Scoring system
                let score = 0;
                if (maxTextureSize >= 8192) score += 3;
                else if (maxTextureSize >= 4096) score += 2;
                else score += 1;
                
                if (maxRenderbufferSize >= 8192) score += 2;
                else if (maxRenderbufferSize >= 4096) score += 1;
                
                if (fragmentPrecision && fragmentPrecision.precision >= 23) score += 2;
                
                // Check mobile
                const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
                if (isMobile) score -= 2;
                
                // Determine quality
                if (score >= 6) this.quality = 'high';
                else if (score >= 4) this.quality = 'medium';
                else this.quality = 'low';
                
                // Update UI indicator
                const indicator = document.getElementById('viz-quality');
                if (indicator) {
                    indicator.textContent = `GPU: ${this.quality.toUpperCase()}`;
                    indicator.className = `shader-quality-indicator ${this.quality}`;
                }
            },
            
            loadPostProcessing(renderer, scene, camera) {
                // Inline minimal EffectComposer implementation
                class RenderPass {
                    constructor(scene, camera) {
                        this.scene = scene;
                        this.camera = camera;
                        this.enabled = true;
                    }
                    render(renderer, writeBuffer, readBuffer) {
                        renderer.setRenderTarget(writeBuffer);
                        renderer.render(this.scene, this.camera);
                    }
                }
                
                class UnrealBloomPass {
                    constructor(resolution, strength, radius, threshold) {
                        this.strength = strength;
                        this.radius = radius;
                        this.threshold = threshold;
                        this.enabled = true;
                        
                        this.material = new THREE.ShaderMaterial({
                            uniforms: {
                                tDiffuse: { value: null },
                                strength: { value: strength },
                                radius: { value: radius },
                                threshold: { value: threshold }
                            },
                            vertexShader: `
                                varying vec2 vUv;
                                void main() {
                                    vUv = uv;
                                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                                }
                            `,
                            fragmentShader: `
                                uniform sampler2D tDiffuse;
                                uniform float strength;
                                uniform float radius;
                                uniform float threshold;
                                varying vec2 vUv;
                                
                                void main() {
                                    vec4 texel = texture2D(tDiffuse, vUv);
                                    float brightness = dot(texel.rgb, vec3(0.2126, 0.7152, 0.0722));
                                    
                                    if (brightness > threshold) {
                                        vec4 bloom = vec4(0.0);
                                        float total = 0.0;
                                        
                                        for (float x = -radius; x <= radius; x += 1.0) {
                                            for (float y = -radius; y <= radius; y += 1.0) {
                                                vec2 offset = vec2(x, y) / 512.0;
                                                float weight = 1.0 - length(vec2(x, y)) / radius;
                                                bloom += texture2D(tDiffuse, vUv + offset) * weight;
                                                total += weight;
                                            }
                                        }
                                        
                                        bloom /= total;
                                        gl_FragColor = texel + bloom * strength;
                                    } else {
                                        gl_FragColor = texel;
                                    }
                                }
                            `
                        });
                        
                        this.quad = new THREE.Mesh(new THREE.PlaneGeometry(2, 2), this.material);
                        this.scene = new THREE.Scene();
                        this.scene.add(this.quad);
                        this.camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
                    }
                    
                    render(renderer, writeBuffer, readBuffer) {
                        this.material.uniforms.tDiffuse.value = readBuffer.texture;
                        renderer.setRenderTarget(writeBuffer);
                        renderer.render(this.scene, this.camera);
                    }
                }
                
                // Simple composer
                const renderTarget = new THREE.WebGLRenderTarget(
                    window.innerWidth, window.innerHeight,
                    { minFilter: THREE.LinearFilter, magFilter: THREE.LinearFilter, format: THREE.RGBAFormat }
                );
                
                this.composer = {
                    passes: [],
                    addPass: function(pass) { this.passes.push(pass); },
                    render: function() {
                        let currentBuffer = renderTarget;
                        this.passes.forEach(pass => {
                            if (pass.enabled) pass.render(renderer, currentBuffer, currentBuffer);
                        });
                    }
                };
                
                const renderPass = new RenderPass(scene, camera);
                this.composer.addPass(renderPass);
                
                if (this.quality === 'high') {
                    this.bloomPass = new UnrealBloomPass(
                        new THREE.Vector2(window.innerWidth, window.innerHeight),
                        1.5, 0.4, 0.85
                    );
                    this.composer.addPass(this.bloomPass);
                }
            },
            
            createCustomShaders() {
                // Energy Field Shader
                this.shaders.energyField = new THREE.ShaderMaterial({
                    uniforms: {
                        time: { value: 0 },
                        color1: { value: new THREE.Color(0x00f3ff) },
                        color2: { value: new THREE.Color(0xffaa00) },
                        color3: { value: new THREE.Color(0x9d00ff) },
                        frequency: { value: 1.0 },
                        amplitude: { value: 0.5 }
                    },
                    vertexShader: `
                        varying vec3 vNormal;
                        varying vec3 vPosition;
                        uniform float time;
                        uniform float frequency;
                        uniform float amplitude;
                        
                        vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
                        vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
                        vec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }
                        vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }
                        
                        float snoise(vec3 v) {
                            const vec2 C = vec2(1.0/6.0, 1.0/3.0);
                            const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);
                            vec3 i = floor(v + dot(v, C.yyy));
                            vec3 x0 = v - i + dot(i, C.xxx);
                            vec3 g = step(x0.yzx, x0.xyz);
                            vec3 l = 1.0 - g;
                            vec3 i1 = min(g.xyz, l.zxy);
                            vec3 i2 = max(g.xyz, l.zxy);
                            vec3 x1 = x0 - i1 + C.xxx;
                            vec3 x2 = x0 - i2 + C.yyy;
                            vec3 x3 = x0 - D.yyy;
                            i = mod289(i);
                            vec4 p = permute(permute(permute(
                                i.z + vec4(0.0, i1.z, i2.z, 1.0))
                                + i.y + vec4(0.0, i1.y, i2.y, 1.0))
                                + i.x + vec4(0.0, i1.x, i2.x, 1.0));
                            float n_ = 0.142857142857;
                            vec3 ns = n_ * D.wyz - D.xzx;
                            vec4 j = p - 49.0 * floor(p * ns.z * ns.z);
                            vec4 x_ = floor(j * ns.z);
                            vec4 y_ = floor(j - 7.0 * x_);
                            vec4 x = x_ * ns.x + ns.yyyy;
                            vec4 y = y_ * ns.x + ns.yyyy;
                            vec4 h = 1.0 - abs(x) - abs(y);
                            vec4 b0 = vec4(x.xy, y.xy);
                            vec4 b1 = vec4(x.zw, y.zw);
                            vec4 s0 = floor(b0)*2.0 + 1.0;
                            vec4 s1 = floor(b1)*2.0 + 1.0;
                            vec4 sh = -step(h, vec4(0.0));
                            vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;
                            vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;
                            vec3 p0 = vec3(a0.xy, h.x);
                            vec3 p1 = vec3(a0.zw, h.y);
                            vec3 p2 = vec3(a1.xy, h.z);
                            vec3 p3 = vec3(a1.zw, h.w);
                            vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));
                            p0 *= norm.x; p1 *= norm.y; p2 *= norm.z; p3 *= norm.w;
                            vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
                            m = m * m;
                            return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));
                        }
                        
                        void main() {
                            vNormal = normalize(normalMatrix * normal);
                            vPosition = position;
                            vec3 pos = position;
                            float noise = snoise(pos * frequency + time * 0.5);
                            pos += normal * noise * amplitude;
                            gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
                        }
                    `,
                    fragmentShader: `
                        uniform float time;
                        uniform vec3 color1;
                        uniform vec3 color2;
                        uniform vec3 color3;
                        varying vec3 vNormal;
                        varying vec3 vPosition;
                        
                        void main() {
                            vec3 viewDirection = normalize(cameraPosition - vPosition);
                            float fresnel = pow(1.0 - dot(viewDirection, vNormal), 3.0);
                            float cycle = sin(time * 0.5) * 0.5 + 0.5;
                            vec3 color = mix(color1, color2, cycle);
                            color = mix(color, color3, sin(time * 0.3) * 0.5 + 0.5);
                            vec3 finalColor = color * (0.3 + fresnel * 0.7);
                            gl_FragColor = vec4(finalColor, 0.8 + fresnel * 0.2);
                        }
                    `,
                    transparent: true,
                    side: THREE.DoubleSide
                });
                
                // Consciousness Field Shader
                this.shaders.consciousness = new THREE.ShaderMaterial({
                    uniforms: {
                        time: { value: 0 },
                        color: { value: new THREE.Color(0x9d00ff) },
                        opacity: { value: 0.6 },
                        scale: { value: 1.2 }
                    },
                    vertexShader: `
                        uniform float time;
                        uniform float scale;
                        varying vec3 vNormal;
                        varying vec3 vPosition;
                        
                        void main() {
                            vNormal = normalize(normalMatrix * normal);
                            vPosition = position;
                            float pulse = sin(time * 2.0) * 0.05 + 1.0;
                            vec3 pos = position * scale * pulse;
                            gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
                        }
                    `,
                    fragmentShader: `
                        uniform vec3 color;
                        uniform float opacity;
                        uniform float time;
                        varying vec3 vNormal;
                        varying vec3 vPosition;
                        
                        void main() {
                            vec3 viewDirection = normalize(cameraPosition - vPosition);
                            float rim = 1.0 - max(0.0, dot(viewDirection, vNormal));
                            rim = pow(rim, 2.0);
                            float pulse = sin(time * 3.0) * 0.3 + 0.7;
                            float alpha = rim * opacity * pulse;
                            gl_FragColor = vec4(color, alpha);
                        }
                    `,
                    transparent: true,
                    side: THREE.BackSide,
                    blending: THREE.AdditiveBlending,
                    depthWrite: false
                });
                
                // Matrix Rain Shader
                this.shaders.matrixRain = new THREE.ShaderMaterial({
                    uniforms: {
                        time: { value: 0 },
                        resolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) },
                        speed: { value: 1.0 }
                    },
                    vertexShader: `
                        varying vec2 vUv;
                        void main() {
                            vUv = uv;
                            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                        }
                    `,
                    fragmentShader: `
                        uniform float time;
                        uniform vec2 resolution;
                        uniform float speed;
                        varying vec2 vUv;
                        
                        float random(vec2 st) {
                            return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.5453123);
                        }
                        
                        void main() {
                            vec2 uv = vUv * resolution / min(resolution.x, resolution.y);
                            float column = floor(uv.x * 50.0);
                            float speed_var = random(vec2(column, 0.0)) * 0.5 + 0.5;
                            float y = fract(uv.y - time * speed * speed_var);
                            float brightness = random(vec2(column, floor(time * 10.0 * speed_var)));
                            brightness = step(0.9, brightness) * (1.0 - y);
                            vec3 color = vec3(0.0, 1.0, 0.3);
                            float colorVar = random(vec2(column, floor(uv.y * 20.0)));
                            if (colorVar > 0.95) color = vec3(0.0, 0.96, 1.0);
                            gl_FragColor = vec4(color * brightness, brightness * 0.8);
                        }
                    `,
                    transparent: true,
                    blending: THREE.AdditiveBlending
                });
                
                console.log('[369 Shaders] Custom shaders created');
            },
            
            applyEnergyField(mesh) {
                if (!this.enabled || !this.shaders.energyField) return;
                const energyMesh = mesh.clone();
                energyMesh.material = this.shaders.energyField.clone();
                energyMesh.scale.multiplyScalar(1.05);
                mesh.add(energyMesh);
                return energyMesh;
            },
            
            applyConsciousnessField(mesh) {
                if (!this.enabled || !this.shaders.consciousness) return;
                const auraMesh = mesh.clone();
                auraMesh.material = this.shaders.consciousness.clone();
                auraMesh.scale.multiplyScalar(1.2);
                mesh.add(auraMesh);
                return auraMesh;
            },
            
            createMatrixRainPlane() {
                if (!this.enabled || !this.shaders.matrixRain) return null;
                const geometry = new THREE.PlaneGeometry(20, 20);
                const mesh = new THREE.Mesh(geometry, this.shaders.matrixRain.clone());
                mesh.position.z = -5;
                return mesh;
            },
            
            update(deltaTime) {
                if (!this.enabled) return;
                Object.values(this.shaders).forEach(shader => {
                    if (shader && shader.uniforms && shader.uniforms.time) {
                        shader.uniforms.time.value += deltaTime;
                    }
                });
                if (this.bloomPass && typeof audioPlayer !== 'undefined' && audioPlayer && !audioPlayer.paused) {
                    const baseStrength = 1.5;
                    const variation = Math.sin(Date.now() * 0.001) * 0.3;
                    this.bloomPass.strength = baseStrength + variation;
                }
            },
            
            setQuality(quality) {
                this.quality = quality;
                if (this.bloomPass) {
                    switch(quality) {
                        case 'high':
                            this.bloomPass.enabled = true;
                            this.bloomPass.strength = 1.5;
                            break;
                        case 'medium':
                            this.bloomPass.enabled = true;
                            this.bloomPass.strength = 1.0;
                            break;
                        case 'low':
                            this.bloomPass.enabled = false;
                            break;
                    }
                }
                Analytics.trackEvent('shader_quality_change', { quality });
            },
            
            toggle() {
                this.enabled = !this.enabled;
                const btn = document.getElementById('shader-toggle-btn');
                if (btn) btn.classList.toggle('active', this.enabled);
                
                if (this.enabled) {
                    showToast(currentLanguage === 'en' ? 'Shader effects enabled' : 'Shader-Effekte aktiviert');
                } else {
                    showToast(currentLanguage === 'en' ? 'Shader effects disabled' : 'Shader-Effekte deaktiviert');
                }
                
                Analytics.trackFeatureUsage('shaders', this.enabled ? 'enabled' : 'disabled');
            }
        };
        
        // Shader animation loop
        let lastShaderTime = performance.now();
        setInterval(() => {
            const now = performance.now();
            const deltaTime = (now - lastShaderTime) / 1000;
            lastShaderTime = now;
            ShaderEffects.update(deltaTime);
        }, 16);

        // ========================================
        // === SECTION 8: PERFORMANCE MONITOR ===
        // ========================================
        const PerformanceMonitor = {
            enabled: false,
            panel: null,
            stats: {
                fps: 0,
                frameTime: 0,
                memory: 0,
                drawCalls: 0,
                triangles: 0
            },
            history: {
                fps: [],
                memory: []
            },
            lastFrameTime: performance.now(),
            frameCount: 0,
            lastFpsUpdate: performance.now(),
            
            init() {
                this.createPanel();
                this.startMonitoring();
                console.log('[369 Perf] Performance Monitor initialized');
            },
            
            createPanel() {
                this.panel = document.createElement('div');
                this.panel.id = 'perf-monitor';
                this.panel.style.cssText = `
                    position: fixed;
                    top: 10px;
                    left: 10px;
                    background: rgba(0, 0, 0, 0.85);
                    border: 1px solid var(--science, #00f3ff);
                    border-radius: 8px;
                    padding: 12px;
                    font-family: 'Courier New', monospace;
                    font-size: 11px;
                    color: #00ff88;
                    z-index: 10001;
                    min-width: 160px;
                    display: none;
                    backdrop-filter: blur(10px);
                    box-shadow: 0 4px 20px rgba(0, 243, 255, 0.2);
                `;
                
                this.panel.innerHTML = `
                    <div style="color: var(--science, #00f3ff); font-weight: bold; margin-bottom: 8px; border-bottom: 1px solid rgba(0,243,255,0.3); padding-bottom: 4px;">
                        ðŸ“Š Performance
                    </div>
                    <div id="perf-fps" style="margin: 4px 0;">FPS: --</div>
                    <div id="perf-frame" style="margin: 4px 0;">Frame: -- ms</div>
                    <div id="perf-memory" style="margin: 4px 0;">Memory: -- MB</div>
                    <div id="perf-draw" style="margin: 4px 0;">Draw Calls: --</div>
                    <div id="perf-triangles" style="margin: 4px 0;">Triangles: --</div>
                    <canvas id="perf-graph" width="140" height="40" style="margin-top: 8px; border: 1px solid rgba(0,243,255,0.2); border-radius: 4px;"></canvas>
                    <div style="margin-top: 8px; font-size: 10px; color: #666;">
                        <span id="perf-quality" style="color: #00ff88;">â—</span> Quality: <span id="perf-quality-text">Auto</span>
                    </div>
                `;
                
                document.body.appendChild(this.panel);
            },
            
            startMonitoring() {
                const updateStats = () => {
                    const now = performance.now();
                    this.frameCount++;
                    
                    // Update FPS every 500ms
                    if (now - this.lastFpsUpdate >= 500) {
                        this.stats.fps = Math.round((this.frameCount * 1000) / (now - this.lastFpsUpdate));
                        this.stats.frameTime = ((now - this.lastFpsUpdate) / this.frameCount).toFixed(2);
                        this.frameCount = 0;
                        this.lastFpsUpdate = now;
                        
                        // Memory (if available)
                        if (performance.memory) {
                            this.stats.memory = (performance.memory.usedJSHeapSize / 1048576).toFixed(1);
                        }
                        
                        // Three.js render info
                        if (typeof renderer !== 'undefined' && renderer && renderer.info) {
                            this.stats.drawCalls = renderer.info.render.calls || 0;
                            this.stats.triangles = renderer.info.render.triangles || 0;
                        }
                        
                        // Update history for graph
                        this.history.fps.push(this.stats.fps);
                        if (this.history.fps.length > 50) this.history.fps.shift();
                        
                        this.history.memory.push(parseFloat(this.stats.memory) || 0);
                        if (this.history.memory.length > 50) this.history.memory.shift();
                        
                        this.updateDisplay();
                    }
                    
                    requestAnimationFrame(updateStats);
                };
                
                requestAnimationFrame(updateStats);
            },
            
            updateDisplay() {
                if (!this.enabled) return;
                
                const fpsEl = document.getElementById('perf-fps');
                const frameEl = document.getElementById('perf-frame');
                const memEl = document.getElementById('perf-memory');
                const drawEl = document.getElementById('perf-draw');
                const triEl = document.getElementById('perf-triangles');
                
                // Color code FPS
                let fpsColor = '#00ff88';
                if (this.stats.fps < 30) fpsColor = '#ff3366';
                else if (this.stats.fps < 50) fpsColor = '#ffaa00';
                
                if (fpsEl) fpsEl.innerHTML = `FPS: <span style="color:${fpsColor}">${this.stats.fps}</span>`;
                if (frameEl) frameEl.textContent = `Frame: ${this.stats.frameTime} ms`;
                if (memEl) memEl.textContent = `Memory: ${this.stats.memory || 'N/A'} MB`;
                if (drawEl) drawEl.textContent = `Draw Calls: ${this.stats.drawCalls}`;
                if (triEl) triEl.textContent = `Triangles: ${this.stats.triangles.toLocaleString()}`;
                
                this.drawGraph();
            },
            
            drawGraph() {
                const canvas = document.getElementById('perf-graph');
                if (!canvas) return;
                
                const ctx = canvas.getContext('2d');
                const w = canvas.width;
                const h = canvas.height;
                
                // Clear
                ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                ctx.fillRect(0, 0, w, h);
                
                // Draw FPS line
                if (this.history.fps.length > 1) {
                    ctx.beginPath();
                    ctx.strokeStyle = '#00ff88';
                    ctx.lineWidth = 1.5;
                    
                    const maxFps = Math.max(...this.history.fps, 60);
                    this.history.fps.forEach((fps, i) => {
                        const x = (i / (this.history.fps.length - 1)) * w;
                        const y = h - (fps / maxFps) * h;
                        if (i === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    });
                    
                    ctx.stroke();
                }
                
                // 60 FPS line
                ctx.strokeStyle = 'rgba(0, 243, 255, 0.3)';
                ctx.setLineDash([2, 2]);
                ctx.beginPath();
                const y60 = h - (60 / Math.max(...this.history.fps, 60)) * h;
                ctx.moveTo(0, y60);
                ctx.lineTo(w, y60);
                ctx.stroke();
                ctx.setLineDash([]);
            },
            
            toggle() {
                this.enabled = !this.enabled;
                if (this.panel) {
                    this.panel.style.display = this.enabled ? 'block' : 'none';
                }
                
                const msg = this.enabled 
                    ? (currentLanguage === 'en' ? 'Performance monitor enabled' : 'Leistungsmonitor aktiviert')
                    : (currentLanguage === 'en' ? 'Performance monitor disabled' : 'Leistungsmonitor deaktiviert');
                showToast(msg);
                
                Analytics.trackFeatureUsage('performance_monitor', this.enabled ? 'enabled' : 'disabled');
            },
            
            // Auto-adjust quality based on performance
            autoAdjustQuality() {
                if (this.stats.fps < 25 && ShaderEffects.quality !== 'low') {
                    ShaderEffects.setQuality('low');
                    showToast(currentLanguage === 'en' ? 'Quality reduced for performance' : 'QualitÃ¤t fÃ¼r Leistung reduziert');
                } else if (this.stats.fps > 55 && ShaderEffects.quality === 'low') {
                    ShaderEffects.setQuality('medium');
                }
            }
        };

        // ========================================
        // === SECTION 9: ACCESSIBILITY SYSTEM ===
        // ========================================
        const AccessibilityManager = {
            reducedMotion: false,
            highContrast: false,
            fontSize: 1,
            keyboardMode: false,
            focusableElements: [],
            currentFocusIndex: -1,
            announcer: null,
            
            init() {
                // Check user preferences
                this.reducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;
                this.highContrast = window.matchMedia('(prefers-contrast: more)').matches;
                
                // Create screen reader announcer
                this.createAnnouncer();
                
                // Setup keyboard navigation
                this.setupKeyboardNav();
                
                // Setup focus management
                this.setupFocusManagement();
                
                // Apply initial preferences
                this.applyPreferences();
                
                // Listen for preference changes
                window.matchMedia('(prefers-reduced-motion: reduce)').addEventListener('change', (e) => {
                    this.reducedMotion = e.matches;
                    this.applyPreferences();
                });
                
                console.log('[369 A11y] Accessibility Manager initialized');
                console.log('[369 A11y] Reduced motion:', this.reducedMotion);
            },
            
            createAnnouncer() {
                this.announcer = document.createElement('div');
                this.announcer.id = 'a11y-announcer';
                this.announcer.setAttribute('role', 'status');
                this.announcer.setAttribute('aria-live', 'polite');
                this.announcer.setAttribute('aria-atomic', 'true');
                this.announcer.style.cssText = `
                    position: absolute;
                    width: 1px;
                    height: 1px;
                    padding: 0;
                    margin: -1px;
                    overflow: hidden;
                    clip: rect(0, 0, 0, 0);
                    white-space: nowrap;
                    border: 0;
                `;
                document.body.appendChild(this.announcer);
            },
            
            announce(message, priority = 'polite') {
                if (!this.announcer) return;
                
                this.announcer.setAttribute('aria-live', priority);
                this.announcer.textContent = '';
                
                // Force reannouncement
                setTimeout(() => {
                    this.announcer.textContent = message;
                }, 100);
            },
            
            setupKeyboardNav() {
                document.addEventListener('keydown', (e) => {
                    // Enable keyboard mode on tab
                    if (e.key === 'Tab') {
                        this.keyboardMode = true;
                        document.body.classList.add('keyboard-nav');
                    }
                    
                    // Global shortcuts
                    if (e.altKey) {
                        switch(e.key) {
                            case 'h': // Home
                                e.preventDefault();
                                exitScene();
                                this.announce(currentLanguage === 'en' ? 'Returned to home' : 'Zur Startseite zurÃ¼ckgekehrt');
                                break;
                            case 'q': // Quiz
                                e.preventDefault();
                                toggleGame();
                                this.announce(currentLanguage === 'en' ? 'Quiz toggled' : 'Quiz umgeschaltet');
                                break;
                            case 't': // Tone Generator
                                e.preventDefault();
                                toggleToneGenerator();
                                this.announce(currentLanguage === 'en' ? 'Tone generator toggled' : 'Tongenerator umgeschaltet');
                                break;
                            case 'p': // Performance
                                e.preventDefault();
                                PerformanceMonitor.toggle();
                                break;
                            case 'v': // Voice
                                e.preventDefault();
                                if (VoiceControl.isSupported) VoiceControl.toggle();
                                break;
                            case 'm': // Mute audio
                                e.preventDefault();
                                if (typeof audioPlayer !== 'undefined' && audioPlayer) {
                                    audioPlayer.muted = !audioPlayer.muted;
                                    this.announce(audioPlayer.muted ? 'Audio muted' : 'Audio unmuted');
                                }
                                break;
                            case '+': // Increase font
                            case '=':
                                e.preventDefault();
                                this.adjustFontSize(0.1);
                                break;
                            case '-': // Decrease font
                                e.preventDefault();
                                this.adjustFontSize(-0.1);
                                break;
                        }
                    }
                    
                    // Escape to close modals
                    if (e.key === 'Escape') {
                        this.closeActiveModal();
                    }
                    
                    // Arrow navigation in chapter grid
                    if (document.activeElement?.classList.contains('chapter-card')) {
                        this.handleCardNavigation(e);
                    }
                });
                
                // Disable keyboard mode on mouse click
                document.addEventListener('mousedown', () => {
                    this.keyboardMode = false;
                    document.body.classList.remove('keyboard-nav');
                });
            },
            
            setupFocusManagement() {
                // Add visible focus styles
                const style = document.createElement('style');
                style.textContent = `
                    body.keyboard-nav *:focus {
                        outline: 3px solid var(--science, #00f3ff) !important;
                        outline-offset: 3px !important;
                    }
                    
                    body.keyboard-nav .chapter-card:focus {
                        transform: scale(1.05);
                        box-shadow: 0 0 30px var(--science, #00f3ff);
                    }
                    
                    .skip-link {
                        position: absolute;
                        top: -100px;
                        left: 50%;
                        transform: translateX(-50%);
                        background: var(--science, #00f3ff);
                        color: #000;
                        padding: 12px 24px;
                        border-radius: 8px;
                        z-index: 100000;
                        font-weight: bold;
                        transition: top 0.3s;
                    }
                    
                    .skip-link:focus {
                        top: 10px;
                    }
                    
                    .reduced-motion * {
                        animation-duration: 0.01ms !important;
                        animation-iteration-count: 1 !important;
                        transition-duration: 0.01ms !important;
                    }
                    
                    .high-contrast {
                        --science: #00ffff !important;
                        --gnosis: #ffff00 !important;
                        --magic: #ff00ff !important;
                    }
                `;
                document.head.appendChild(style);
                
                // Add skip link
                const skipLink = document.createElement('a');
                skipLink.href = '#main-content';
                skipLink.className = 'skip-link';
                skipLink.textContent = currentLanguage === 'en' ? 'Skip to main content' : 'Zum Hauptinhalt springen';
                document.body.insertBefore(skipLink, document.body.firstChild);
                
                // Add main content landmark
                const chapterGrid = document.getElementById('chapter-grid');
                if (chapterGrid && !document.getElementById('main-content')) {
                    chapterGrid.id = 'main-content';
                    chapterGrid.setAttribute('role', 'main');
                    chapterGrid.setAttribute('aria-label', currentLanguage === 'en' ? 'Chapter grid' : 'KapitelÃ¼bersicht');
                }
            },
            
            handleCardNavigation(e) {
                const cards = Array.from(document.querySelectorAll('.chapter-card'));
                const currentIndex = cards.indexOf(document.activeElement);
                
                if (currentIndex === -1) return;
                
                let newIndex = currentIndex;
                const cols = Math.floor(window.innerWidth / 280); // Approximate columns
                
                switch(e.key) {
                    case 'ArrowRight':
                        newIndex = Math.min(currentIndex + 1, cards.length - 1);
                        e.preventDefault();
                        break;
                    case 'ArrowLeft':
                        newIndex = Math.max(currentIndex - 1, 0);
                        e.preventDefault();
                        break;
                    case 'ArrowDown':
                        newIndex = Math.min(currentIndex + cols, cards.length - 1);
                        e.preventDefault();
                        break;
                    case 'ArrowUp':
                        newIndex = Math.max(currentIndex - cols, 0);
                        e.preventDefault();
                        break;
                    case 'Enter':
                    case ' ':
                        e.preventDefault();
                        cards[currentIndex].click();
                        return;
                }
                
                if (newIndex !== currentIndex) {
                    cards[newIndex].focus();
                    const cardTitle = cards[newIndex].querySelector('.chapter-title')?.textContent;
                    if (cardTitle) this.announce(cardTitle);
                }
            },
            
            closeActiveModal() {
                // Check and close various modals
                const vizModal = document.getElementById('viz-modal');
                if (vizModal?.classList.contains('active')) {
                    closeVisualizationModal();
                    this.announce(currentLanguage === 'en' ? 'Modal closed' : 'Modal geschlossen');
                    return;
                }
                
                const toneGenerator = document.getElementById('tone-generator-panel');
                if (toneGenerator?.classList.contains('show')) {
                    toggleToneGenerator();
                    this.announce(currentLanguage === 'en' ? 'Tone generator closed' : 'Tongenerator geschlossen');
                    return;
                }
                
                const gamePanel = document.getElementById('game-panel');
                if (gamePanel?.classList.contains('visible')) {
                    toggleGame();
                    this.announce(currentLanguage === 'en' ? 'Quiz closed' : 'Quiz geschlossen');
                    return;
                }
                
                // If in 3D scene, exit
                if (typeof currentSceneIndex !== 'undefined' && currentSceneIndex !== null) {
                    exitScene();
                    this.announce(currentLanguage === 'en' ? 'Exited chapter' : 'Kapitel verlassen');
                }
            },
            
            applyPreferences() {
                if (this.reducedMotion) {
                    document.body.classList.add('reduced-motion');
                    // Disable shader animations
                    if (ShaderEffects.enabled) {
                        ShaderEffects.toggle();
                    }
                } else {
                    document.body.classList.remove('reduced-motion');
                }
                
                if (this.highContrast) {
                    document.body.classList.add('high-contrast');
                } else {
                    document.body.classList.remove('high-contrast');
                }
            },
            
            adjustFontSize(delta) {
                this.fontSize = Math.max(0.8, Math.min(1.5, this.fontSize + delta));
                document.documentElement.style.fontSize = `${this.fontSize * 100}%`;
                
                const percent = Math.round(this.fontSize * 100);
                this.announce(`${currentLanguage === 'en' ? 'Font size' : 'SchriftgrÃ¶ÃŸe'}: ${percent}%`);
                showToast(`${currentLanguage === 'en' ? 'Font size' : 'SchriftgrÃ¶ÃŸe'}: ${percent}%`);
            },
            
            // Make chapter cards accessible
            enhanceChapterCards() {
                document.querySelectorAll('.chapter-card').forEach((card, index) => {
                    card.setAttribute('tabindex', '0');
                    card.setAttribute('role', 'button');
                    
                    const title = card.querySelector('.chapter-title')?.textContent || `Chapter ${index + 1}`;
                    const status = card.classList.contains('completed') ? 
                        (currentLanguage === 'en' ? 'Completed' : 'Abgeschlossen') : 
                        (currentLanguage === 'en' ? 'Not completed' : 'Nicht abgeschlossen');
                    
                    card.setAttribute('aria-label', `${title}. ${status}`);
                    
                    // Enter key support
                    card.addEventListener('keydown', (e) => {
                        if (e.key === 'Enter' || e.key === ' ') {
                            e.preventDefault();
                            card.click();
                        }
                    });
                });
            }
        };

        // Helper function to toggle performance monitor
        function togglePerformanceMonitor() {
            PerformanceMonitor.toggle();
        }

        // === GLOBAL HELPER FUNCTIONS ===
        function openVisualizationModal() {
            const modal = document.getElementById('viz-modal');
            if (modal) {
                modal.classList.add('active');
                if (!DataVisualizer.canvas) DataVisualizer.init();
                DataVisualizer.start();
                Analytics.trackFeatureUsage('visualization', 'opened');
            }
        }

        function closeVisualizationModal() {
            const modal = document.getElementById('viz-modal');
            if (modal) {
                modal.classList.remove('active');
                DataVisualizer.stop();
            }
        }

        function switchVisualization(type) { DataVisualizer.switchVisualization(type); }
        function updateVizSpeed(value) { DataVisualizer.updateSpeed(value); }
        function updateVizParticles(value) { DataVisualizer.updateParticleCount(value); }
        function exportVisualization() { DataVisualizer.export(); }
        function toggleVoiceControl() { VoiceControl.toggle(); }
        function enterVRMode() { VRController.enter(); }
        function installPWA() { PWAManager.install(); }
        function dismissPWAPrompt() { PWAManager.hideInstallPrompt(); }
        function toggleShaderEffects() { ShaderEffects.toggle(); }

        // ========================================
        // === INIT ADVANCED FEATURES ===
        // ========================================
        function initAdvancedFeatures() {
            console.log('[369 Portal] Initializing advanced features...');
            
            // Initialize Voice Control
            VoiceControl.init();
            
            // Initialize VR Controller
            VRController.init();
            
            // Initialize PWA Manager
            PWAManager.init();
            
            // Detect shader quality
            ShaderEffects.detectQuality();
            
            // Log feature availability
            console.log('[369 Portal] Voice Control:', VoiceControl.isSupported ? 'Available' : 'Not supported');
            console.log('[369 Portal] VR Mode:', VRController.isSupported ? 'Available' : 'Not supported');
            console.log('[369 Portal] PWA:', 'serviceWorker' in navigator ? 'Available' : 'Not supported');
            console.log('[369 Portal] Shader Quality:', ShaderEffects.quality);
            
            // Show feature availability to user (non-intrusive)
            setTimeout(() => {
                const features = [];
                if (VoiceControl.isSupported) features.push('ðŸŽ¤');
                if (VRController.isSupported) features.push('ðŸ¥½');
                if ('serviceWorker' in navigator) features.push('ðŸ“±');
                features.push('âœ¨'); // Shaders always available at some level
                
                if (features.length > 0) {
                    console.log('[369 Portal] Available features:', features.join(' '));
                }
            }, 2000);
        }

        // === TONE GENERATOR ===
        const SOLFEGGIO_FREQUENCIES = [
            { freq: 174, name: 'Erdung', desc: 'Schmerz-Reduktion, Sicherheit', note: 'F3' },
            { freq: 285, name: 'Heilung', desc: 'Geweberegeneration', note: 'C#4' },
            { freq: 396, name: 'Befreiung', desc: 'Angst & Schuld lÃ¶sen', note: 'G4' },
            { freq: 417, name: 'Wandel', desc: 'Transformation, VerÃ¤nderung', note: 'G#4' },
            { freq: 432, name: 'Natur', desc: 'Herzfrequenz-KohÃ¤renz', note: 'A4' },
            { freq: 528, name: 'Liebe', desc: 'DNA-Reparatur, Transformation', note: 'C5' },
            { freq: 639, name: 'Verbindung', desc: 'Harmonie & Beziehungen', note: 'D#5' },
            { freq: 741, name: 'Erwachen', desc: 'Intuition & Ausdruck', note: 'F#5' },
            { freq: 852, name: 'Einsicht', desc: 'Spirituelle Ordnung', note: 'G#5' },
            { freq: 963, name: 'Einheit', desc: 'GÃ¶ttliche Verbindung', note: 'B5' }
        ];

        let toneGeneratorCtx = null;
        let toneOscillator = null;
        let toneOscillatorR = null; // For binaural
        let toneGain = null;
        let toneGainR = null;
        let tonePlaying = false;
        let currentToneFreq = 432;
        let currentToneVol = 0.5;
        let currentWaveType = 'sine';
        let binauralEnabled = false;
        let binauralFreq = 10;

        function getToneContext() {
            if (!toneGeneratorCtx) {
                toneGeneratorCtx = new (window.AudioContext || window.webkitAudioContext)();
            }
            return toneGeneratorCtx;
        }

        function buildTonePresets() {
            const container = document.getElementById('tone-presets');
            if (!container) return;
            container.innerHTML = '';
            SOLFEGGIO_FREQUENCIES.forEach(preset => {
                const div = document.createElement('div');
                div.className = 'tone-preset';
                div.dataset.freq = preset.freq;
                div.innerHTML = `
                    <div class="tone-preset-freq">${preset.freq}</div>
                    <div class="tone-preset-name">${preset.name}</div>
                    <div class="tone-preset-desc">${preset.desc}</div>
                `;
                div.onclick = () => selectPreset(preset.freq);
                container.appendChild(div);
            });
            // Highlight initial
            selectPreset(432, false);
        }

        function selectPreset(freq, autoPlay = false) {
            currentToneFreq = freq;
            document.querySelectorAll('.tone-preset').forEach(p => {
                p.classList.toggle('active', parseInt(p.dataset.freq) === freq);
            });
            const slider = document.getElementById('tone-freq-slider');
            if (slider) slider.value = freq;
            updateFrequencyDisplay(freq);
            if (tonePlaying) updateLiveOscillator();
            if (autoPlay && !tonePlaying) toggleTone();
        }

        function updateToneFrequency(val) {
            currentToneFreq = parseInt(val);
            updateFrequencyDisplay(currentToneFreq);
            // Deselect presets if not matching
            document.querySelectorAll('.tone-preset').forEach(p => {
                p.classList.toggle('active', parseInt(p.dataset.freq) === currentToneFreq);
            });
            if (tonePlaying) updateLiveOscillator();
        }

        function updateFrequencyDisplay(freq) {
            const valEl = document.getElementById('tone-freq-value');
            const noteEl = document.getElementById('tone-freq-note');
            const sliderVal = document.getElementById('freq-slider-val');
            if (valEl) valEl.textContent = freq;
            if (sliderVal) sliderVal.textContent = freq + ' Hz';
            // Find matching preset
            const preset = SOLFEGGIO_FREQUENCIES.find(p => p.freq === freq);
            if (noteEl) {
                if (preset) {
                    noteEl.textContent = `${preset.note} - ${preset.name} (${preset.desc})`;
                } else {
                    noteEl.textContent = `Custom Frequency`;
                }
            }
        }

        function updateToneVolume(val) {
            currentToneVol = parseInt(val) / 100;
            const sliderVal = document.getElementById('vol-slider-val');
            if (sliderVal) sliderVal.textContent = val + '%';
            if (toneGain) toneGain.gain.setValueAtTime(currentToneVol, getToneContext().currentTime);
            if (toneGainR) toneGainR.gain.setValueAtTime(currentToneVol, getToneContext().currentTime);
        }

        function setWaveType(type) {
            currentWaveType = type;
            document.querySelectorAll('.tone-wave-btn').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.wave === type);
            });
            if (tonePlaying) updateLiveOscillator();
        }

        function updateLiveOscillator() {
            if (toneOscillator) {
                toneOscillator.type = currentWaveType;
                toneOscillator.frequency.setValueAtTime(currentToneFreq, getToneContext().currentTime);
            }
            if (toneOscillatorR && binauralEnabled) {
                toneOscillatorR.type = currentWaveType;
                toneOscillatorR.frequency.setValueAtTime(currentToneFreq + binauralFreq, getToneContext().currentTime);
            }
        }

        function toggleBinaural(enabled) {
            binauralEnabled = enabled;
            const controls = document.getElementById('binaural-controls');
            if (controls) controls.style.display = enabled ? 'block' : 'none';
            if (tonePlaying) {
                stopTone();
                startTone();
            }
        }

        function updateBinauralFrequency(val) {
            binauralFreq = parseInt(val);
            const valEl = document.getElementById('binaural-freq-val');
            let brainwave = 'Custom';
            if (val >= 1 && val <= 4) brainwave = 'Delta';
            else if (val > 4 && val <= 8) brainwave = 'Theta';
            else if (val > 8 && val <= 14) brainwave = 'Alpha';
            else if (val > 14 && val <= 30) brainwave = 'Beta';
            else if (val > 30) brainwave = 'Gamma';
            if (valEl) valEl.textContent = `${val} Hz (${brainwave})`;
            if (tonePlaying && toneOscillatorR) {
                toneOscillatorR.frequency.setValueAtTime(currentToneFreq + binauralFreq, getToneContext().currentTime);
            }
        }

        function startTone() {
            const ctx = getToneContext();
            if (ctx.state === 'suspended') ctx.resume();

            // Create stereo panner for binaural
            if (binauralEnabled) {
                // Left channel
                toneOscillator = ctx.createOscillator();
                toneGain = ctx.createGain();
                const pannerL = ctx.createStereoPanner();
                pannerL.pan.value = -1;
                toneOscillator.type = currentWaveType;
                toneOscillator.frequency.setValueAtTime(currentToneFreq, ctx.currentTime);
                toneGain.gain.setValueAtTime(currentToneVol, ctx.currentTime);
                toneOscillator.connect(toneGain);
                toneGain.connect(pannerL);
                pannerL.connect(ctx.destination);
                toneOscillator.start();

                // Right channel (offset frequency for binaural beat)
                toneOscillatorR = ctx.createOscillator();
                toneGainR = ctx.createGain();
                const pannerR = ctx.createStereoPanner();
                pannerR.pan.value = 1;
                toneOscillatorR.type = currentWaveType;
                toneOscillatorR.frequency.setValueAtTime(currentToneFreq + binauralFreq, ctx.currentTime);
                toneGainR.gain.setValueAtTime(currentToneVol, ctx.currentTime);
                toneOscillatorR.connect(toneGainR);
                toneGainR.connect(pannerR);
                pannerR.connect(ctx.destination);
                toneOscillatorR.start();
            } else {
                // Mono output
                toneOscillator = ctx.createOscillator();
                toneGain = ctx.createGain();
                toneOscillator.type = currentWaveType;
                toneOscillator.frequency.setValueAtTime(currentToneFreq, ctx.currentTime);
                toneGain.gain.setValueAtTime(currentToneVol, ctx.currentTime);
                toneOscillator.connect(toneGain);
                toneGain.connect(ctx.destination);
                toneOscillator.start();
            }

            tonePlaying = true;
            updatePlayButton();
        }

        function stopTone() {
            if (toneOscillator) {
                toneOscillator.stop();
                toneOscillator.disconnect();
                toneOscillator = null;
            }
            if (toneOscillatorR) {
                toneOscillatorR.stop();
                toneOscillatorR.disconnect();
                toneOscillatorR = null;
            }
            toneGain = null;
            toneGainR = null;
            tonePlaying = false;
            updatePlayButton();
        }

        function toggleTone() {
            if (tonePlaying) {
                stopTone();
            } else {
                startTone();
            }
        }

        function updatePlayButton() {
            const btn = document.getElementById('tone-play-btn');
            const generatorBtn = document.getElementById('tone-generator-btn');
            if (btn) {
                btn.innerHTML = tonePlaying ? 'â¹' : 'â–¶';
                btn.classList.toggle('playing', tonePlaying);
            }
            if (generatorBtn) {
                generatorBtn.classList.toggle('playing', tonePlaying);
            }
        }

        function toggleToneGenerator() {
            const modal = document.getElementById('tone-modal');
            if (!modal) return;
            const isOpen = modal.classList.contains('show');
            if (isOpen) {
                closeToneGenerator();
            } else {
                modal.classList.add('show');
                buildTonePresets();
            }
        }

        function closeToneGenerator() {
            const modal = document.getElementById('tone-modal');
            if (modal) modal.classList.remove('show');
            // Don't stop the tone when closing - let it play in background
        }

        // --- GEMATRIA SCANNER ---
        function scanGematria(input) {
            const result = document.getElementById('scanner-result');
            if (!result) return;
            
            if (!input || input.trim() === '') {
                result.textContent = '';
                return;
            }
            
            const text = input.toUpperCase().replace(/[^A-Z]/g, '');
            if (text.length === 0) {
                result.textContent = 'Nur Buchstaben eingeben';
                return;
            }
            
            let sum = 0;
            let breakdown = [];
            
            for (const char of text) {
                const val = CHAR_VALS[char] || 0;
                if (val > 0) {
                    sum += val;
                    breakdown.push(`${char}=${val}`);
                }
            }
            
            // Calculate digital root (quersumme)
            let digitalRoot = sum;
            while (digitalRoot > 9) {
                digitalRoot = String(digitalRoot).split('').reduce((a, b) => a + parseInt(b), 0);
            }
            
            const labelSum = currentLanguage === 'en' ? 'Sum' : 'Summe';
            const labelRoot = currentLanguage === 'en' ? 'Root' : 'Wurzel';
            
            result.innerHTML = `<strong>${input.toUpperCase()}</strong> â†’ ${labelSum}: <span style="color: var(--gnosis)">${sum}</span> | ${labelRoot}: <span style="color: var(--magic)">${digitalRoot}</span>`;
        }

        // Close modal on click outside or Escape key
        document.addEventListener('click', function(e) {
            if (e.target.classList.contains('modal-overlay')) {
                closeModal();
            }
        });
        
        document.addEventListener('keydown', function(e) {
            if (e.key === 'Escape') {
                closeModal();
            }
        });
    </script>
</body>
</html>
<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="author" content="Nicolai Becker">
    <meta name="description" content="Die 613-THz-Signatur: Der Code des Widerstands - Systemarchitektur der Realit√§t">
    <title>Die 613-THz-Signatur | 3-6-9 Systemarchitektur</title>
    
    <!-- THREE.JS -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    
    <style>
        :root {
            --science: #00f3ff;
            --gnosis: #ffaa00;
            --magic: #9d00ff;
            --dark: #030304;
            --glass: rgba(8, 8, 12, 0.85);
            --border: rgba(0, 243, 255, 0.15);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            font-family: 'Courier New', monospace;
            background: var(--dark);
            color: #fff;
            overflow-x: hidden;
            user-select: none;
        }

        /* Matrix Background */
        #matrix-bg {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 0;
            opacity: 0.15;
        }

        /* Music Player - Top Bar */
        #music-player {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            z-index: 10000;
            background: rgba(3, 3, 5, 0.98);
            border-bottom: 1px solid var(--science);
            backdrop-filter: blur(20px);
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 15px;
            padding: 8px 20px;
            height: 45px;
        }

        @media (max-width: 768px) {
            #music-player {
                gap: 8px;
                padding: 6px 10px;
                height: 40px;
                font-size: 0.8rem;
            }
        }

        .player-btn {
            background: rgba(0, 243, 255, 0.1);
            border: 1px solid var(--science);
            padding: 4px 10px;
            cursor: pointer;
            color: var(--science);
            font-family: 'Courier New', monospace;
            font-size: 0.75rem;
            transition: all 0.3s;
        }

        .player-btn:hover {
            background: rgba(0, 243, 255, 0.2);
            box-shadow: 0 0 10px var(--science);
        }

        .player-btn:disabled {
            opacity: 0.4;
            cursor: not-allowed;
            box-shadow: none;
        }

        .player-timeline {
            flex: 1;
            max-width: 400px;
            height: 4px;
            background: rgba(0, 243, 255, 0.2);
            cursor: pointer;
            position: relative;
        }

        .player-progress {
            height: 100%;
            background: var(--science);
            width: 0%;
            transition: width 0.1s linear;
        }

        .player-time {
            font-size: 0.65rem;
            color: var(--science);
            font-family: 'Courier New', monospace;
        }

        .player-track-title {
            font-size: 0.7rem;
            color: var(--science);
            font-family: 'Courier New', monospace;
            font-weight: bold;
        }

        .player-volume {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .volume-slider {
            width: 90px;
        }

        .volume-slider input[type="range"] {
            width: 100%;
        }

        /* Hero Section */
        .hero {
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            padding: 80px 20px 40px;
            z-index: 1;
        }

        h1 {
            font-size: clamp(3rem, 10vw, 8rem);
            background: linear-gradient(135deg, var(--science) 0%, #fff 50%, var(--gnosis) 100%);
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: 0 0 40px rgba(0, 243, 255, 0.6);
            filter: drop-shadow(0 10px 20px rgba(0, 243, 255, 0.4));
            animation: title-float 4s ease-in-out infinite;
            letter-spacing: 0.1em;
            margin-bottom: 1rem;
        }

        @keyframes title-float {
            0%, 100% { transform: translateY(0px); }
            50% { transform: translateY(-10px); }
        }

        /* --- ANIMATED MUSIC NOTES & FRACTALS BACKGROUND --- */
        .music-notes {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 2;
            pointer-events: none;
            overflow: hidden;
        }
        
        /* Musical Notes */
        .note {
            position: absolute;
            font-size: 2rem;
            animation: float-up linear infinite;
            opacity: 0;
            filter: drop-shadow(0 0 8px currentColor);
            will-change: transform, opacity;
        }
        
        @keyframes float-up {
            0% { transform: translateY(100vh) rotate(0deg) scale(0.8); opacity: 0; }
            10% { opacity: 0.7; transform: translateY(90vh) rotate(36deg) scale(1); }
            50% { opacity: 0.5; }
            90% { opacity: 0.3; }
            100% { transform: translateY(-10vh) rotate(360deg) scale(0.6); opacity: 0; }
        }
        
        /* Frequency-specific colors and rhythms */
        .note.hz-60 { color: #ff3366; } /* Matrix 60Hz - Red */
        .note.hz-432 { color: #ffaa00; } /* Sacred 432Hz - Gold */
        .note.hz-528 { color: #00ff88; } /* Healing 528Hz - Green */
        .note.hz-963 { color: #8888ff; } /* Pineal 963Hz - Indigo */
        .note.hz-174 { color: #ff6600; } /* Foundation 174Hz - Orange */
        
        /* Fractal Symbols */
        .fractal {
            position: absolute;
            font-size: 3rem;
            animation: fractal-spin linear infinite;
            opacity: 0;
            color: var(--science);
            filter: drop-shadow(0 0 12px currentColor);
            will-change: transform, opacity;
        }
        
        @keyframes fractal-spin {
            0% { transform: translate(0, 100vh) rotate(0deg) scale(0.5); opacity: 0; }
            5% { opacity: 0.6; }
            50% { transform: translate(var(--drift-x), 50vh) rotate(180deg) scale(1.2); opacity: 0.4; }
            95% { opacity: 0.3; }
            100% { transform: translate(calc(var(--drift-x) * 2), -10vh) rotate(360deg) scale(0.4); opacity: 0; }
        }
        
        /* Positioning variations for notes */
        .note:nth-child(1) { left: 8%; animation-duration: 14s; animation-delay: 0s; font-size: 1.4rem; }
        .note:nth-child(2) { left: 18%; animation-duration: 16s; animation-delay: 1.5s; font-size: 2rem; }
        .note:nth-child(3) { left: 28%; animation-duration: 13s; animation-delay: 3s; font-size: 1.7rem; }
        .note:nth-child(4) { left: 38%; animation-duration: 18s; animation-delay: 0.8s; font-size: 2.2rem; }
        .note:nth-child(5) { left: 48%; animation-duration: 15s; animation-delay: 2.5s; font-size: 1.5rem; }
        .note:nth-child(6) { left: 58%; animation-duration: 17s; animation-delay: 4s; font-size: 1.9rem; }
        .note:nth-child(7) { left: 68%; animation-duration: 14s; animation-delay: 5.5s; font-size: 2.1rem; }
        .note:nth-child(8) { left: 78%; animation-duration: 19s; animation-delay: 1s; font-size: 1.6rem; }
        .note:nth-child(9) { left: 88%; animation-duration: 13s; animation-delay: 6s; font-size: 2.3rem; }
        .note:nth-child(10) { left: 12%; animation-duration: 16s; animation-delay: 7s; font-size: 1.8rem; }
        .note:nth-child(11) { left: 32%; animation-duration: 15s; animation-delay: 3.5s; font-size: 2rem; }
        .note:nth-child(12) { left: 52%; animation-duration: 17s; animation-delay: 2s; font-size: 1.7rem; }
        .note:nth-child(13) { left: 72%; animation-duration: 14s; animation-delay: 4.5s; font-size: 1.9rem; }
        .note:nth-child(14) { left: 92%; animation-duration: 18s; animation-delay: 0.5s; font-size: 2.2rem; }
        
        /* Positioning variations for fractals */
        .fractal:nth-child(15) { left: 15%; --drift-x: 50px; animation-duration: 22s; animation-delay: 1s; }
        .fractal:nth-child(16) { left: 45%; --drift-x: -40px; animation-duration: 25s; animation-delay: 3s; }
        .fractal:nth-child(17) { left: 75%; --drift-x: 60px; animation-duration: 20s; animation-delay: 5s; }
        .fractal:nth-child(18) { left: 25%; --drift-x: -30px; animation-duration: 23s; animation-delay: 2s; }
        .fractal:nth-child(19) { left: 55%; --drift-x: 45px; animation-duration: 24s; animation-delay: 4s; }
        .fractal:nth-child(20) { left: 85%; --drift-x: -50px; animation-duration: 21s; animation-delay: 6s; }
        .fractal:nth-child(21) { left: 35%; --drift-x: 35px; animation-duration: 26s; animation-delay: 7s; }
        .fractal:nth-child(22) { left: 65%; --drift-x: -45px; animation-duration: 19s; animation-delay: 1.5s; }
        
        /* Mobile Performance Optimization - hide heavy animations */
        @media (max-width: 768px) {
            .note, .fractal { display: none !important; }
        }

        .subtitle {
            color: var(--gnosis);
            font-size: clamp(0.9rem, 2vw, 1.2rem);
            letter-spacing: 0.3em;
            text-transform: uppercase;
            margin-bottom: 3rem;
            border-bottom: 2px solid var(--gnosis);
            display: inline-block;
            padding-bottom: 8px;
        }

        .cta-buttons {
            display: flex;
            gap: 1rem;
            flex-wrap: wrap;
            justify-content: center;
            margin-bottom: 3rem;
        }

        .btn {
            padding: 1rem 2rem;
            font-size: 1rem;
            font-weight: bold;
            text-decoration: none;
            border: 2px solid;
            cursor: pointer;
            transition: all 0.3s;
            font-family: 'Courier New', monospace;
            text-transform: uppercase;
            letter-spacing: 2px;
            background: var(--glass);
            backdrop-filter: blur(10px);
        }

        .btn-primary {
            color: var(--science);
            border-color: var(--science);
        }

        .btn-primary:hover {
            background: var(--science);
            color: #000;
            box-shadow: 0 0 20px var(--science);
        }

        .btn-secondary {
            color: var(--magic);
            border-color: var(--magic);
        }

        .btn-secondary:hover {
            background: var(--magic);
            color: #000;
            box-shadow: 0 0 20px var(--magic);
        }

        /* Dashboard */
        #dashboard {
            position: relative;
            padding: 80px 20px 40px;
            z-index: 1;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        .section-title {
            text-align: center;
            font-size: clamp(2rem, 5vw, 3rem);
            color: var(--science);
            margin-bottom: 3rem;
            text-shadow: 0 0 20px var(--science);
        }

        /* Chapter Grid */
        .chapters-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
            gap: 20px;
            margin-bottom: 3rem;
        }

        @media (max-width: 768px) {
            .chapters-grid {
                grid-template-columns: 1fr;
                gap: 15px;
            }
        }

        .chapter-card {
            background: linear-gradient(135deg, rgba(0, 243, 255, 0.05), transparent);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 20px;
            cursor: pointer;
            transition: all 0.3s;
            position: relative;
            overflow: hidden;
        }
        .chapter-card.locked {
            opacity: 0.4;
            filter: grayscale(0.6);
            cursor: not-allowed;
            position: relative;
        }
        .chapter-card.locked::before {
            content: 'üîí';
            position: absolute;
            top: 10px;
            right: 10px;
            font-size: 1.2rem;
            z-index: 2;
        }
        .chapter-card.completed {
            border-color: rgba(255, 170, 0, 0.6);
            box-shadow: 0 0 25px rgba(255, 170, 0, 0.2);
            position: relative;
        }
        .chapter-card.completed::before {
            content: '‚úì';
            position: absolute;
            top: 10px;
            right: 10px;
            font-size: 1.2rem;
            color: var(--gnosis);
            z-index: 2;
        }

        .chapter-card::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 3px;
            background: linear-gradient(90deg, var(--science), var(--gnosis));
            transform: scaleX(0);
            transition: 0.4s;
        }

        .chapter-card:hover {
            border-color: var(--science);
            transform: translateY(-8px);
            box-shadow: 0 0 30px rgba(0, 243, 255, 0.3);
        }

        .chapter-card:hover::after {
            transform: scaleX(1);
        }
        .chapter-card.locked:hover {
            border-color: var(--border);
            transform: none;
            box-shadow: none;
        }

        .chapter-id {
            color: #666;
            font-size: 0.7rem;
            margin-bottom: 8px;
        }

        .chapter-title {
            font-size: 1.1rem;
            font-weight: 700;
            color: var(--science);
            margin-bottom: 8px;
        }

        .chapter-desc {
            font-size: 0.85rem;
            color: #999;
            line-height: 1.5;
        }

        #profile-panel {
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 30px;
            background: rgba(0, 0, 0, 0.4);
        }
        .profile-title {
            font-size: 1rem;
            color: var(--science);
            margin-bottom: 10px;
            letter-spacing: 1px;
        }
        .profile-row {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            align-items: center;
        }
        .profile-row input {
            flex: 1;
            min-width: 160px;
            padding: 10px 12px;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid var(--border);
            color: #fff;
            font-family: 'Courier New', monospace;
        }
        .profile-row button {
            padding: 10px 16px;
            border: 1px solid var(--science);
            background: transparent;
            color: var(--science);
            cursor: pointer;
            font-family: 'Courier New', monospace;
            transition: background 0.2s;
        }
        .profile-row button:hover {
            background: rgba(0, 243, 255, 0.15);
        }
        .profile-btn-ghost {
            border-color: #ff3366 !important;
            color: #ff3366 !important;
        }
        .profile-btn-ghost:hover {
            background: rgba(255, 51, 102, 0.15);
        }
        .profile-hint {
            font-size: 0.75rem;
            color: #777;
            margin-top: 8px;
        }

        /* 3D Scene Container */
        #scene-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 5000;
            background: #000;
            display: none;
        }

        #scene-container.active {
            display: block;
        }

        #canvas-3d {
            width: 100%;
            height: 100%;
        }

        /* Scene UI Overlay */
        #scene-ui {
            position: absolute;
            top: 60px;
            left: 0;
            right: 0;
            bottom: 0;
            pointer-events: none;
            z-index: 10;
        }

        .scene-top-bar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 20px;
            pointer-events: auto;
        }

        .scene-info {
            text-align: center;
            flex: 1;
        }

        .scene-name {
            font-size: 1.5rem;
            color: var(--science);
            text-shadow: 0 0 10px var(--science);
        }

        .nav-btn {
            padding: 10px 20px;
            background: var(--glass);
            border: 1px solid var(--science);
            color: var(--science);
            cursor: pointer;
            transition: all 0.3s;
            pointer-events: auto;
            font-family: 'Courier New', monospace;
        }

        .nav-btn:hover {
            background: rgba(0, 243, 255, 0.2);
            box-shadow: 0 0 10px var(--science);
        }

        /* Learning Game Overlay */
        #game-overlay {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: var(--glass);
            border: 2px solid var(--science);
            padding: 20px;
            border-radius: 8px;
            max-width: 600px;
            width: 90%;
            pointer-events: auto;
            display: none;
        }

        #game-overlay.active {
            display: block;
        }

        .game-question {
            color: var(--gnosis);
            font-size: 1.1rem;
            margin-bottom: 15px;
        }
        .game-progress {
            font-size: 0.8rem;
            color: #bbb;
            letter-spacing: 1px;
            margin-bottom: 6px;
        }

        .game-options {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .game-option {
            padding: 10px 15px;
            background: rgba(0, 243, 255, 0.1);
            border: 1px solid var(--science);
            color: #fff;
            cursor: pointer;
            transition: all 0.3s;
            text-align: left;
        }

        .game-option:hover {
            background: rgba(0, 243, 255, 0.2);
            transform: translateX(5px);
        }

        .game-option.correct {
            background: rgba(0, 255, 136, 0.3);
            border-color: #00ff88;
        }

        .game-option.incorrect {
            background: rgba(255, 0, 0, 0.3);
            border-color: #ff0000;
        }

        .game-feedback {
            margin-top: 15px;
            padding: 10px;
            border-radius: 4px;
            display: none;
        }

        .game-feedback.show {
            display: block;
        }

        .game-feedback.correct {
            background: rgba(0, 255, 136, 0.2);
            border: 1px solid #00ff88;
            color: #00ff88;
        }

        .game-feedback.incorrect {
            background: rgba(255, 0, 0, 0.2);
            border: 1px solid #ff0000;
            color: #ff6666;
        }
        .game-feedback .source-link {
            display: inline-block;
            margin-top: 8px;
            font-size: 0.85rem;
        }
        .game-feedback .source-link a {
            color: var(--science);
            text-decoration: underline;
        }

        /* Game Close Button */
        .game-close-btn {
            position: absolute;
            top: 10px;
            right: 10px;
            background: transparent;
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: #888;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 1rem;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .game-close-btn:hover {
            border-color: #ff3366;
            color: #ff3366;
            background: rgba(255, 51, 102, 0.1);
        }

        /* Game Buttons Container */
        .game-buttons {
            display: flex;
            gap: 10px;
            margin-top: 15px;
            justify-content: space-between;
        }
        .game-buttons .nav-btn {
            flex: 1;
        }
        .skip-btn {
            border-color: #ff3366;
            color: #ff3366;
        }
        .skip-btn:hover {
            background: rgba(255, 51, 102, 0.2);
        }
        @media (max-width: 480px) {
            .game-buttons {
                flex-direction: column;
            }
        }

        /* Navigation Arrows */
        .nav-arrow {
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            width: 60px;
            height: 100px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2rem;
            color: var(--science);
            cursor: pointer;
            transition: all 0.3s;
            background: linear-gradient(to right, rgba(0,0,0,0.6), transparent);
            pointer-events: auto;
        }

        .nav-arrow:hover {
            color: #fff;
            text-shadow: 0 0 20px var(--science);
        }

        .nav-arrow.prev {
            left: 0;
        }

        .nav-arrow.next {
            right: 0;
            background: linear-gradient(to left, rgba(0,0,0,0.6), transparent);
        }

        @media (max-width: 768px) {
            .nav-arrow {
                width: 40px;
                font-size: 1.5rem;
            }
        }

        /* Sidebar Controls */
        #sidebar {
            position: fixed;
            right: 20px;
            top: 80px;
            width: 300px;
            display: flex;
            flex-direction: column;
            gap: 15px;
            pointer-events: auto;
            transition: transform 0.3s ease, opacity 0.3s ease;
            z-index: 20;
        }

        #sidebar.dragging {
            transition: none;
        }

        #sidebar.minimized {
            width: 180px;
        }

        #sidebar.minimized .panel {
            display: none;
        }

        .sidebar-header {
            display: flex;
            gap: 10px;
        }

        .sidebar-toggle,
        .sidebar-handle {
            flex: 1;
            background: var(--glass);
            border: 1px solid var(--science);
            color: var(--science);
            border-radius: 6px;
            font-family: 'Courier New', monospace;
            font-size: 0.75rem;
            padding: 8px 10px;
            cursor: pointer;
            transition: background 0.3s, box-shadow 0.3s;
        }

        .sidebar-toggle:hover,
        .sidebar-handle:hover {
            background: rgba(0, 243, 255, 0.15);
            box-shadow: 0 0 12px rgba(0, 243, 255, 0.3);
        }

        .sidebar-handle {
            max-width: 60px;
            cursor: grab;
        }

        #sidebar.dragging .sidebar-handle {
            cursor: grabbing;
        }

        @media (max-width: 768px) {
            #sidebar {
                width: 90%;
                right: 5%;
                top: 60px;
            }
        }

        .panel {
            background: var(--glass);
            border: 1px solid var(--border);
            border-right: 3px solid var(--science);
            padding: 15px;
            border-radius: 8px;
            backdrop-filter: blur(15px);
        }

        .panel-title {
            color: var(--science);
            font-size: 0.8rem;
            margin-bottom: 10px;
            border-bottom: 1px solid rgba(255,255,255,0.1);
            padding-bottom: 5px;
        }

        .view-btn {
            background: linear-gradient(135deg, rgba(0, 243, 255, 0.08), rgba(255, 170, 0, 0.08));
            border: 1px solid var(--border);
            color: #aaa;
            padding: 10px;
            margin-bottom: 8px;
            cursor: pointer;
            transition: all 0.3s;
            width: 100%;
            font-family: 'Courier New', monospace;
            font-size: 0.85rem;
        }

        .view-btn:hover {
            background: linear-gradient(135deg, rgba(0, 243, 255, 0.15), rgba(255, 170, 0, 0.15));
            border-color: var(--science);
            color: #fff;
            transform: translateX(-4px);
        }

        .view-btn.active {
            background: linear-gradient(135deg, var(--science), var(--gnosis));
            color: #000;
            font-weight: bold;
        }

        .vertical-controls {
            display: flex;
            gap: 8px;
            margin-top: 12px;
        }

        .view-btn.small {
            flex: 1;
            padding: 8px;
            font-size: 0.75rem;
        }

        /* Footer */
        footer {
            position: relative;
            z-index: 1;
            text-align: center;
            padding: 3rem 1rem;
            border-top: 1px solid var(--science);
            margin-top: 5rem;
        }

        .footer-links {
            margin-top: 1rem;
        }

        .footer-links a {
            color: var(--science);
            text-decoration: none;
            margin: 0 10px;
            transition: all 0.3s;
        }

        .footer-links a:hover {
            color: #fff;
            text-shadow: 0 0 10px var(--science);
        }

        /* Scroll Indicator */
        .scroll-indicator {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            animation: bounce 2s infinite;
        }

        .scroll-indicator button {
            background: none;
            border: none;
            cursor: pointer;
            padding: 12px;
        }

        .scroll-indicator button:focus-visible {
            outline: 2px solid var(--science);
            outline-offset: 4px;
        }

        @keyframes bounce {
            0%, 20%, 50%, 80%, 100% { transform: translateX(-50%) translateY(0); }
            40% { transform: translateX(-50%) translateY(-20px); }
            60% { transform: translateX(-50%) translateY(-10px); }
        }

        .arrow-down {
            width: 30px;
            height: 30px;
            border-right: 3px solid var(--science);
            border-bottom: 3px solid var(--science);
            transform: rotate(45deg);
        }

        /* MODALS */
        .modal-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.9); backdrop-filter: blur(15px);
            z-index: 5000; opacity: 0; pointer-events: none; transition: 0.4s;
            display: flex; justify-content: center; align-items: center;
        }
        .modal-overlay.active { opacity: 1; pointer-events: auto; }

        .modal {
            width: 800px; max-width: 90%; max-height: 85vh;
            background: var(--glass); border: 2px solid var(--border); border-radius: 12px;
            display: flex; flex-direction: column; 
            box-shadow: 0 20px 60px rgba(0, 243, 255, 0.3);
            backdrop-filter: blur(20px);
            transform: scale(0.95); transition: 0.4s;
        }
        .modal-overlay.active .modal { transform: scale(1); }

        .m-header { 
            padding: 25px; border-bottom: 2px solid var(--border); 
            display: flex; justify-content: space-between; align-items: center;
            background: linear-gradient(135deg, rgba(0, 243, 255, 0.1), rgba(255, 170, 0, 0.1));
        }
        .m-title { 
            font-size: 1.4rem; font-family: 'Courier New', monospace; font-weight: 600; letter-spacing: 1px;
            background: linear-gradient(90deg, var(--science), var(--gnosis));
            -webkit-background-clip: text; background-clip: text; -webkit-text-fill-color: transparent;
        }
        .m-close { 
            cursor: pointer; font-size: 1.8rem; color: #666; transition: all 0.3s ease;
            width: 36px; height: 36px; display: flex; align-items: center; justify-content: center;
            border-radius: 50%; border: 1px solid transparent;
        }
        .m-close:hover { 
            color: var(--science); transform: rotate(90deg); 
            border-color: var(--border); background: rgba(0, 243, 255, 0.1);
        }
        .m-content { padding: 40px; overflow-y: auto; line-height: 1.7; color: #bbb; font-size: 0.95rem; }
        
        /* Sources List Styling */
        .ref-list { list-style: none; padding: 0; margin-top: 30px; border-top: 1px solid #222; padding-top: 20px; }
        .ref-list li { margin-bottom: 12px; font-size: 0.8rem; font-family: 'Courier New', monospace; display: flex; align-items: flex-start; gap: 8px; }
        .ref-list li::before { content: '‚ñ∫'; color: var(--science); margin-top: 3px; opacity: 0.7; flex-shrink: 0; }
        .ref-list a { color: #888; text-decoration: none; transition: 0.2s; border-bottom: 1px dotted #444; flex: 1; }
        .ref-list a:hover { color: #fff; border-bottom-color: var(--science); }
        .archive-badge { 
            display: inline-block; padding: 2px 6px; font-size: 0.65rem; 
            background: rgba(255, 170, 0, 0.2); color: var(--gnosis); 
            border-radius: 3px; margin-left: 8px; border: 1px solid rgba(255, 170, 0, 0.3);
        }
        .offline-toggle {
            display: flex; align-items: center; gap: 10px; padding: 12px; 
            background: rgba(255, 170, 0, 0.1); border-radius: 4px; 
            margin-bottom: 20px; border: 1px solid rgba(255, 170, 0, 0.3);
        }
        .offline-toggle input[type="checkbox"] { width: 18px; height: 18px; cursor: pointer; }
        .offline-toggle label { color: var(--gnosis); font-size: 0.85rem; cursor: pointer; flex: 1; }

        /* Gematria Scanner */
        .scanner-box {
            background: rgba(3, 3, 5, 0.95); 
            border-top: 1px solid rgba(157, 0, 255, 0.2);
            border-bottom: 1px solid rgba(157, 0, 255, 0.2);
            padding: 8px 20px;
            text-align: center; 
            width: 100%;
            backdrop-filter: blur(10px);
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 15px;
            flex-wrap: wrap;
        }
        .scanner-label {
            font-size: 0.65rem; 
            color: #666; 
            font-family: 'Courier New', monospace;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        .scanner-input {
            background: rgba(157, 0, 255, 0.05); 
            border: 1px solid rgba(157, 0, 255, 0.2);
            color: #aaa; 
            font-size: 0.75rem; 
            font-family: 'Courier New', monospace; 
            text-align: center;
            width: 180px; 
            padding: 4px 10px; 
            text-transform: uppercase;
            transition: all 0.3s ease; 
            border-radius: 4px;
        }
        .scanner-input:focus {
            background: rgba(157, 0, 255, 0.1);
            border-color: rgba(157, 0, 255, 0.4);
            color: #fff;
            outline: none;
        }
        .scanner-result { 
            font-size: 0.65rem; 
            color: rgba(157, 0, 255, 0.6); 
            font-family: 'Courier New', monospace;
            min-width: 200px;
        }
        .amazon-btn {
            display: block; margin-top: 30px; padding: 15px; text-align: center;
            background: linear-gradient(45deg, #ff9900, #ffcc00); color: #000;
            text-decoration: none; font-weight: bold; text-transform: uppercase; letter-spacing: 1px;
            border-radius: 4px; transition: 0.3s;
        }
        .amazon-btn:hover { box-shadow: 0 0 30px rgba(255, 153, 0, 0.5); transform: translateY(-2px); }

        /* === NEW ENHANCEMENTS === */
        
        /* Scroll to Top Button */
        #scroll-top {
            position: fixed;
            bottom: 30px;
            right: 30px;
            width: 50px;
            height: 50px;
            background: var(--glass);
            border: 1px solid var(--science);
            border-radius: 50%;
            cursor: pointer;
            z-index: 9998;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
            color: var(--science);
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
        }
        #scroll-top.visible {
            opacity: 1;
            visibility: visible;
        }
        #scroll-top:hover {
            background: rgba(0, 243, 255, 0.2);
            box-shadow: 0 0 20px var(--science);
            transform: translateY(-3px);
        }
        @media (max-width: 768px) {
            #scroll-top {
                bottom: 20px;
                right: 20px;
                width: 45px;
                height: 45px;
                font-size: 1.2rem;
            }
        }

        /* Chapter Progress Indicator */
        #chapter-progress {
            position: fixed;
            top: 45px;
            left: 0;
            right: 0;
            height: 3px;
            background: rgba(0, 243, 255, 0.1);
            z-index: 9997;
        }
        #chapter-progress-bar {
            height: 100%;
            background: linear-gradient(90deg, var(--science), var(--gnosis), var(--magic));
            width: 0%;
            transition: width 0.3s ease;
        }

        /* Visited Chapter Indicator */
        .chapter-card.visited::after {
            content: '‚úì';
            position: absolute;
            top: 10px;
            right: 10px;
            width: 24px;
            height: 24px;
            background: var(--gnosis);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            color: #000;
            font-weight: bold;
        }

        /* Pulse Animation for Interactive Elements */
        @keyframes pulse-glow {
            0%, 100% { box-shadow: 0 0 5px var(--science); }
            50% { box-shadow: 0 0 20px var(--science), 0 0 30px var(--science); }
        }
        .pulse-hint {
            animation: pulse-glow 2s ease-in-out infinite;
        }

        /* Keyboard Shortcut Hint */
        #keyboard-hints {
            position: fixed;
            bottom: 30px;
            left: 30px;
            background: var(--glass);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 10px 15px;
            font-size: 0.7rem;
            color: #666;
            z-index: 9998;
            backdrop-filter: blur(10px);
            opacity: 0;
            transition: opacity 0.3s;
        }
        #keyboard-hints.visible {
            opacity: 1;
        }
        #keyboard-hints kbd {
            background: rgba(0, 243, 255, 0.1);
            border: 1px solid var(--science);
            border-radius: 3px;
            padding: 2px 6px;
            margin: 0 3px;
            color: var(--science);
        }
        @media (max-width: 768px) {
            #keyboard-hints { display: none; }
        }

        /* Toast Notification */
        #toast {
            position: fixed;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%) translateY(100px);
            background: var(--glass);
            border: 1px solid var(--gnosis);
            border-radius: 8px;
            padding: 12px 24px;
            color: var(--gnosis);
            font-size: 0.85rem;
            z-index: 99999;
            opacity: 0;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
            text-align: center;
            max-width: 90%;
        }
        #toast.show {
            opacity: 1;
            transform: translateX(-50%) translateY(0);
        }

        /* Loading Shimmer for Cards */
        @keyframes shimmer {
            0% { background-position: -200% 0; }
            100% { background-position: 200% 0; }
        }
        .card-loading {
            background: linear-gradient(90deg, var(--glass) 25%, rgba(0, 243, 255, 0.05) 50%, var(--glass) 75%);
            background-size: 200% 100%;
            animation: shimmer 1.5s infinite;
        }

        /* Quick Stats Bar */
        #quick-stats {
            display: flex;
            justify-content: center;
            gap: 30px;
            margin-top: 30px;
            flex-wrap: wrap;
        }
        .stat-item {
            text-align: center;
            padding: 15px 25px;
            background: var(--glass);
            border: 1px solid var(--border);
            border-radius: 8px;
            min-width: 120px;
        }
        .stat-value {
            font-size: 1.8rem;
            font-weight: bold;
            color: var(--science);
            display: block;
        }
        .stat-label {
            font-size: 0.7rem;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-top: 5px;
        }
        @media (max-width: 768px) {
            #quick-stats { gap: 15px; }
            .stat-item { padding: 10px 15px; min-width: 90px; }
            .stat-value { font-size: 1.4rem; }
        }
    </style>
</head>
<body>
    <!-- Matrix Background -->
    <canvas id="matrix-bg"></canvas>

    <!-- ANIMATED MUSIC NOTES & FRACTALS BACKGROUND -->
    <div class="music-notes">
        <!-- Musical Notes with Frequency Colors -->
        <div class="note hz-60">‚ô©</div>
        <div class="note hz-432">‚ô™</div>
        <div class="note hz-528">‚ô´</div>
        <div class="note hz-963">‚ô¨</div>
        <div class="note hz-174">‚ô≠</div>
        <div class="note hz-60">‚ôÆ</div>
        <div class="note hz-432">‚ôØ</div>
        <div class="note hz-528">ùÑû</div>
        <div class="note hz-963">‚ô©</div>
        <div class="note hz-174">‚ô™</div>
        <div class="note hz-60">‚ô´</div>
        <div class="note hz-432">‚ô¨</div>
        <div class="note hz-528">‚ô≠</div>
        <div class="note hz-963">‚ôÆ</div>
        
        <!-- Fractal & Sacred Geometry Symbols -->
        <div class="fractal">‚å¨</div>
        <div class="fractal">‚ó¨</div>
        <div class="fractal">‚¨°</div>
        <div class="fractal">‚åò</div>
        <div class="fractal">‚äô</div>
        <div class="fractal">‚äó</div>
        <div class="fractal">‚ú¶</div>
        <div class="fractal">‚ùñ</div>
    </div>

    <!-- Music Player -->
    <div id="music-player">
        <span class="player-track-title">613-THz Signatur</span>
        <button class="player-btn" id="play-btn">‚ñ∂</button>
        <div class="player-timeline" id="timeline">
            <div class="player-progress" id="progress"></div>
        </div>
        <span class="player-time" id="current-time">0:00</span>
        <span class="player-time">/</span>
        <span class="player-time" id="duration">0:00</span>
        <button class="player-btn" id="mute-btn">üîä</button>
        <div class="player-volume">
            <div class="volume-slider">
                <input type="range" id="volume-slider" min="0" max="1" step="0.01" value="0.7" aria-label="Lautst√§rke" />
            </div>
        </div>
    </div>

    <!-- Hero Section -->
    <section class="hero">
        <h1>3-6-9</h1>
        <div class="subtitle">SYSTEMARCHITEKTUR DER REALIT√ÑT</div>
        <div class="cta-buttons">
            <a href="https://linktr.ee/AEiOU.official" target="_blank" class="btn btn-primary">‚ö° ALLES VOM ERSTELLER</a>
            <button class="btn btn-secondary" onclick="scrollToDashboard()">üîì SYSTEM ERKUNDEN</button>
        </div>
        <div class="scroll-indicator">
            <button type="button" aria-label="Weiter zum Dashboard" onclick="scrollToDashboard()">
                <div class="arrow-down"></div>
            </button>
        </div>
    </section>

    <!-- Dashboard -->
    <div id="dashboard">
        <div class="container">
            <h2 class="section-title">/// DIE 15 KAPITEL ///</h2>
            
            <!-- Quick Stats -->
            <div id="quick-stats">
                <div class="stat-item">
                    <span class="stat-value" id="stat-chapters">0</span>
                    <span class="stat-label">Kapitel besucht</span>
                </div>
                <div class="stat-item">
                    <span class="stat-value" id="stat-sources">35</span>
                    <span class="stat-label">Quellen</span>
                </div>
                <div class="stat-item">
                    <span class="stat-value" id="stat-progress">0%</span>
                    <span class="stat-label">Fortschritt</span>
                </div>
            </div>

            <div id="profile-panel">
                <div class="profile-title" id="profile-title">Fortschrittsschl√ºssel</div>
                <div class="profile-row">
                    <input type="text" id="profile-name" placeholder="Codename" autocomplete="off">
                    <input type="text" id="profile-seed" placeholder="Seed (z.B. 369)" autocomplete="off">
                    <button class="profile-btn" id="profile-apply">Profil aktivieren</button>
                    <button class="profile-btn profile-btn-ghost" id="profile-reset">Reset</button>
                </div>
                <p class="profile-hint" id="profile-hint">Fortschritt wird lokal pro Name + Seed gespeichert.</p>
            </div>
            
            <div class="chapters-grid" id="chapters-grid"></div>
            
            <div style="margin-top: 50px; display: flex; flex-direction: column; gap: 15px; align-items: center;">
                <button class="view-btn" style="width:auto; padding:15px 30px; text-align:center;" onclick="openArchive()">Vollst√§ndiges Quellen-Archiv</button>
                <button class="view-btn" style="width:auto; padding:15px 30px; text-align:center; background: rgba(255, 170, 0, 0.1); border-color: var(--gnosis);" onclick="openExplanation()">Wissenschaftliche Exegese (Volltext)</button>
            </div>
        </div>
    </div>

    <!-- 3D Scene Container -->
    <div id="scene-container">
        <canvas id="canvas-3d"></canvas>
        <div id="scene-ui">
            <div class="scene-top-bar">
                <button class="nav-btn" onclick="exitScene()">‚Üê ZUR√úCK</button>
                <div class="scene-info">
                    <div class="scene-name" id="scene-name">LADEN...</div>
                </div>
                <button class="nav-btn" onclick="openInfo()">‚ÑπÔ∏è QUELLEN</button>
                <button class="nav-btn" onclick="toggleGame()">üéÆ SPIEL</button>
            </div>

            <div class="nav-arrow prev" onclick="prevChapter()">‚Äπ</div>
            <div class="nav-arrow next" onclick="nextChapter()">‚Ä∫</div>

            <div id="sidebar">
                <div class="sidebar-header">
                    <button class="sidebar-toggle" id="sidebar-toggle" type="button" aria-expanded="true">‚ñæ Men√º</button>
                    <button class="sidebar-handle" id="sidebar-drag-handle" type="button" title="Panel bewegen">‚†ø</button>
                </div>

                <div class="panel">
                    <div class="panel-title">VISUALISIERUNG</div>
                    <button class="view-btn active" data-view="main" onclick="setView('main', this)">‚óâ GLOBAL</button>
                    <button class="view-btn" data-view="macro" onclick="setView('macro', this)">‚äï MAKRO</button>
                    <button class="view-btn" data-view="micro" onclick="setView('micro', this)">‚äó MIKRO</button>

                    <div class="vertical-controls">
                        <button class="view-btn small" onclick="adjustCameraHeight('up')">‚ñ≤ Hoch</button>
                        <button class="view-btn small" onclick="adjustCameraHeight('down')">‚ñº Runter</button>
                        <button class="view-btn small" onclick="resetCameraHeight()">‚Ü∫ Reset</button>
                    </div>
                </div>
            </div>

            <!-- Learning Game Overlay -->
            <div id="game-overlay">
                <button class="game-close-btn" onclick="toggleGame()" title="Spiel schlie√üen">‚úï</button>
                <div class="game-progress" id="game-progress"></div>
                <div class="game-question" id="game-question"></div>
                <div class="game-options" id="game-options"></div>
                <div class="game-feedback" id="game-feedback"></div>
                <div class="game-buttons">
                    <button class="nav-btn" onclick="toggleGame()">‚Üê SCHLIESSEN</button>
                    <button class="nav-btn skip-btn" id="skip-btn" onclick="skipCurrentQuestion()">‚ö†Ô∏è √úBERSPRINGEN</button>
                    <button class="nav-btn" onclick="nextGameQuestion()">WEITER ‚Üí</button>
                </div>
            </div>
        </div>
    </div>

    <!-- INFO MODAL (Chapter-specific sources) -->
    <div class="modal-overlay" id="info-modal">
        <div class="modal">
            <div class="m-header">
                <div class="m-title" id="info-title">Titel</div>
                <div class="m-close" onclick="closeModal()">‚úï</div>
            </div>
            <div class="m-content">
                <div id="info-desc">Beschreibung...</div>
                <div class="offline-toggle">
                    <input type="checkbox" id="offline-mode-info" onchange="toggleOfflineMode(this.checked)">
                    <label for="offline-mode-info">Offline-Modus (Archive.org)</label>
                </div>
                <div class="ref-list" id="info-sources"></div>
                <a href="https://linktr.ee/AEiOU.official" target="_blank" class="amazon-btn">Alles vom Ersteller dieser Website</a>
            </div>
        </div>
    </div>

    <!-- ARCHIVE MODAL -->
    <div class="modal-overlay" id="archive-modal">
        <div class="modal">
            <div class="m-header">
                <div class="m-title">Vollst√§ndiges Quellen-Archiv</div>
                <div class="m-close" onclick="closeModal()">‚úï</div>
            </div>
            <div class="m-content">
                <p>Alle referenzierten Quellen (Reichstein, Weinreb, Physik, Kabbala).</p>
                <div class="offline-toggle">
                    <input type="checkbox" id="offline-mode-archive" onchange="toggleOfflineMode(this.checked)">
                    <label for="offline-mode-archive">Offline-Modus (Archive.org)</label>
                </div>
                <ul class="ref-list" id="archive-list"></ul>
            </div>
        </div>
    </div>

    <!-- EXPLANATION MODAL -->
    <div class="modal-overlay" id="explanation-modal">
        <div class="modal" style="max-width: 95%; width: 1200px;">
            <div class="m-header">
                <div class="m-title">Wissenschaftliche Exegese: Systemarchitektur 3-6-9</div>
                <div class="m-close" onclick="closeModal()">‚úï</div>
            </div>
            <div class="m-content" style="max-height: 80vh; overflow-y: auto; line-height: 1.8; text-align: justify;">
                <div style="font-family: Georgia, serif; font-size: 0.95rem; color: #e0e0e0;">
                    
<h1 style="color: var(--gnosis); text-align: center; font-size: 1.5rem; margin-bottom: 10px;">Systemarchitektur 3-6-9</h1>
<h2 style="color: var(--science); text-align: center; font-size: 1.1rem; margin-top: 0; margin-bottom: 30px; font-weight: normal;">Eine integrative Exegese der Schnittstellen zwischen Gnostischer Physik, Kabbalistischer Kybernetik und Morphogenetik</h2>

<h3 style="color: var(--gnosis); margin-top: 30px;">Einleitung: Das rekursive Universum als programmierbare Architektur</h3>

<p>Die vorliegende Forschungsarbeit widmet sich einer ersch√∂pfenden Analyse der "Systemarchitektur 3-6-9", wie sie in den bereitgestellten Dokumenten skizziert und durch umfangreiche externe Quellen validiert wurde. Bei diesem Konstrukt handelt es sich nicht lediglich um eine willk√ºrliche Ansammlung esoterischer und wissenschaftlicher Begriffe, sondern um den Versuch einer "Grand Unified Theory" (GUT) auf ph√§nomenologischer Ebene. Das System postuliert eine triadische Struktur der Realit√§t, kodiert durch die Prim√§rfarben Cyan (Wissenschaft/Kausalit√§t), Gold (Gnosis/Akausalit√§t) und Violett (Magie/Transformation).</p>

<p>Im Zentrum dieser Architektur steht die These, dass das Universum als ein informationsverarbeitendes System betrachtet werden kann ‚Äì eine Sichtweise, die sowohl in der antiken Gnosis (der Kosmos als fehlerhafte Sch√∂pfung eines Demiurgen) als auch in der modernen Simulationshypothese und der Quanteninformationstheorie Widerhall findet. Die Zahlensequenz "3-6-9" dient hierbei als algorithmischer Schl√ºssel, der die Schnittstelle zwischen dem abstrakten "Quellcode" und der physischen "Benutzeroberfl√§che" bildet.</p>

<h3 style="color: var(--science); margin-top: 40px;">Kapitel I: Das numerologische Substrat</h3>

<p>Das Fundament der untersuchten Systemarchitektur bildet die Zahlenfolge 3-6-9. Die digitale Wurzel einer nicht-negativen ganzen Zahl ist der Wert, der durch wiederholte Addition der Ziffern entsteht, bis eine einstellige Zahl verbleibt. Die Zahl 9 fungiert im Dezimalsystem als "Identit√§tselement der Transformation" ‚Äì jede Zahl, multipliziert mit 9, ergibt ein Produkt mit digitaler Wurzel 9.</p>

<p>Die "Vortex Based Mathematics" (VBM) postuliert, dass die Zahlen 3, 6 und 9 einen Vektor-Fluss repr√§sentieren, der au√üerhalb des physischen Verdopplungsschaltkreises (1-2-4-8-7-5) liegt. Im Kontext dieser Systemarchitektur wird VBM als algorithmische Metapher verwendet, nicht als physikalische Theorie.</p>

<h3 style="color: var(--magic); margin-top: 40px;">Kapitel II: Gnostische Physik</h3>

<p>Der Begriff "Gnostische Physik" verweist auf den Versuch, die Weltanschauung der antiken Gnosis mit den Erkenntnissen der modernen Quantenphysik zu verbinden. Die zentralen Protagonisten sind Wolfgang Pauli und C.G. Jung, die gemeinsam das Konzept der Synchronizit√§t entwickelten ‚Äì ein akausales verkn√ºpfendes Prinzip.</p>

<p>Ein Schl√ºsselelement war die Zahl 137 (Kehrwert der Feinstrukturkonstante Œ± ‚âà 1/137), die auch der Gematria-Wert des hebr√§ischen Wortes "Kabbalah" ist. In der Systemarchitektur entspricht Kausalit√§t der Farbe Cyan ("Science") und Akausalit√§t der Farbe Gold ("Gnosis").</p>

<h3 style="color: var(--gnosis); margin-top: 40px;">Kapitel III: Kabbalistische Kybernetik</h3>

<p>Der Lebensbaum (Etz Chaim) besteht aus 10 Knoten (Sefirot) und 22 Pfaden ‚Äì ein gerichteter Graph, der den "Abstieg" von unendlichem Potenzial in die endliche Manifestation modelliert. Die Sefirot k√∂nnen als funktionale Knotenpunkte in einem kybernetischen System verstanden werden:</p>

<p>‚Ä¢ <strong>Keter:</strong> Der Input/Die Absicht<br>
‚Ä¢ <strong>Chokhmah & Binah:</strong> Die Prozessoren<br>
‚Ä¢ <strong>Chesed & Gevurah:</strong> Expansions- und Restriktionsmechanismen<br>
‚Ä¢ <strong>Tiferet:</strong> Der zentrale Hub<br>
‚Ä¢ <strong>Malkuth:</strong> Das Output-Interface</p>

<p>Interessant ist die √úbereinstimmung der 10 Sefirot mit den 10 Dimensionen der Superstringtheorie ‚Äì beide Modelle beschreiben ineinander gefaltete Dimensionen des Seins.</p>

<h3 style="color: var(--science); margin-top: 40px;">Kapitel IV: Morphogenetik</h3>

<p>Alan Turings "Reaktions-Diffusions-Mechanismen" (1952) erkl√§ren, wie aus symmetrischen Embryonen asymmetrische Formen entstehen ‚Äì durch Interaktion von Aktivator und Inhibitor. Rupert Sheldrakes kontroverse "Morphische Felder" postulieren dagegen immaterielle Strukturen als Formschablonen.</p>

<p>Die Allgemeine Systemtheorie (Ludwig von Bertalanffy) bildet das Bindeglied: Lebende Organismen sind offene Systeme im Flie√ügleichgewicht, die der Entropie entgegenwirken (Negentropie).</p>

<h3 style="color: var(--magic); margin-top: 40px;">Kapitel V: Akustische Architektur</h3>

<p>Klinische Studien zeigen, dass Musik in 432 Hz (vs. 440 Hz Standard) signifikant niedrigere Herzfrequenz (-2,7 bpm) und Cortisol-Werte erzeugt. Die Frequenz 528 Hz reduzierte in Studien die Produktion reaktiver Sauerstoffspezies und erh√∂hte die Zell√ºberlebensrate um ca. 20%.</p>

<p>Die System-Frequenzen: 174 Hz (Erdung), 432 Hz (Herz-Koh√§renz), 528 Hz (Transformation), 963 Hz (Einheit). Akustik ist hier Medizin und Programmierung.</p>

<h3 style="color: var(--gnosis); margin-top: 40px;">Konklusion</h3>

<p>Die "Systemarchitektur 3-6-9" nutzt Mathematik als universelle Sprache, Gnostische Physik als kosmologisches Narrativ, Kabbala als kybernetischen Schaltplan, Morphogenetik als Hardware-Erkl√§rung und Akustik als operative Schnittstelle. Es ist ein Versuch der Reduktion von Komplexit√§t durch eine Meta-Sprache, die Mystik und Mechanik vereint.</p>

<hr style="margin: 40px 0; border: none; border-top: 1px solid rgba(255, 170, 0, 0.3);">

<p style="text-align: center; font-size: 0.9rem; color: var(--gnosis); margin-top: 30px;">
<strong>Autor:</strong> Nicolai Becker<br>
<span style="font-size: 0.85rem; color: #888; margin-top: 10px; display: block;">¬© 2025 Nicolai Becker. Alle Rechte vorbehalten.</span>
</p>

                </div>
            </div>
        </div>
    </div>

    <!-- Gematria Scanner -->
    <div class="scanner-box" style="margin-top: 0;">
        <span class="scanner-label">Gematria</span>
        <input type="text" class="scanner-input" id="gematria-input" placeholder="Name eingeben" oninput="scanGematria(this.value)">
        <div class="scanner-result" id="scanner-result"></div>
    </div>

    <!-- Scroll to Top Button -->
    <button id="scroll-top" onclick="scrollToTop()" aria-label="Nach oben scrollen">‚Üë</button>

    <!-- Chapter Progress Bar -->
    <div id="chapter-progress">
        <div id="chapter-progress-bar"></div>
    </div>

    <!-- Keyboard Shortcuts Hint (Desktop only) -->
    <div id="keyboard-hints">
        <kbd>‚Üê</kbd><kbd>‚Üí</kbd> Navigation | <kbd>ESC</kbd> Zur√ºck | <kbd>?</kbd> Hilfe
    </div>

    <!-- Toast Notification -->
    <div id="toast"></div>

    <!-- Footer -->
    <footer>
        <p>&copy; 2025 Nicolai Becker | Alle Rechte vorbehalten</p>
        <div class="footer-links">
            <a href="https://linktr.ee/AEiOU.official" target="_blank">LinkTree</a>
            <a href="#" onclick="openArchive(); return false;">Quellen</a>
        </div>
        <p style="margin-top: 1rem; color: #666; font-size: 0.9rem;">
            "Wenn du die Herrlichkeit der 3, 6 und 9 verst√ºndest,<br>
            h√§ttest du einen Schl√ºssel zum Universum" - Nikola Tesla
        </p>
    </footer>

    <script>
        // --- SOURCES DATA ---
        const SOURCES = [
            // Academic Sources: Kapitel I - Numerologisches Substrat (0-3)
            "https://arxiv.org/abs/2110.03746", 
            "https://www.iosrjournals.org/iosr-jm/papers/Vol11-issue1/Version-3/E011131924.pdf",
            "https://medium.com/predict/decoding-the-enigma-3-6-9-nikola-tesla-numbers-45ef6539ef23",
            "https://www.youtube.com/watch?v=mTeZD8rsiTs",
            
            // Academic Sources: Kapitel II - Gnostische Physik (4-7)
            "https://www.scribd.com/document/503237905/Atom-and-Archetype-The-Pauli-Jung-Letters-1932-1958-by-Wolfgang-Pauli-Carl-Jung-Authors-C-a-Meier-Editor",
            "https://gnosis.study/library/Gnosis/ENG/Lewis-Cosmology-and-Fate-in-Gnosticism.pdf",
            "https://www.researchgate.net/publication/344980295_Mysticism_and_the_Fine_Structure_Constant",
            "https://www.researchgate.net/publication/8188070_Beyond_synchronicity_The_worldview_of_Carl_Gustav_Jung_and_Wolfgang_Pauli",
            
            // Academic Sources: Kapitel III - Kabbalistische Kybernetik (8-10)
            "https://www.semanticscholar.org/paper/A-Comparative-Study-of-10(11)-D-Superstring-Theory-Amoroso/0b9fb604fc5cec6abda5999ce15d2e2907617cde",
            "https://cris.tau.ac.il/en/publications/moshe-idels-phenomenology-and-its-sources",
            "https://www.researchgate.net/figure/The-TL-as-a-graph-where-each-of-the-sefirot-nodes-is-described-by-a-set-of-ten_fig2_220626476",
            
            // Academic Sources: Kapitel IV - Morphogenetik (11-14)
            "https://www.dna.caltech.edu/courses/cs191/paperscs191/turing.pdf",
            "https://www.pnas.org/doi/10.1073/pnas.1322005111",
            "https://monoskop.org/images/7/77/Von_Bertalanffy_Ludwig_General_System_Theory_1968.pdf",
            "https://www.sheldrake.org/research/all-scientific-papers",
            
            // Academic Sources: Kapitel V - Akustische Architektur (15-18)
            "https://pubmed.ncbi.nlm.nih.gov/32401941/",
            "https://www.researchgate.net/publication/319015020_The_Effects_of_528_Hz_Sound_Wave_to_Reduce_Cell_Death_in_Human_Astrocyte_Primary_Cell_Culture_Treated_with_Ethanol",
            "https://monoskop.org/images/3/31/Jenny_Hans_Cymatics_A_Study_of_Wave_Phenomena_and_Vibration_Vol_1_2001.pdf",
            "https://www.researchgate.net/publication/360601620_The_Listening_to_music_tuned_to_440_Hz_versus_432_Hz_to_reduce_anxiety_and_stress_in_emergency_nurses_during_the_COVID-19_pandemic_a_double-blind_randomized_controlled_pilot_study",
            
            // Research Websites (19-20)
            "https://amasci.com/greb/greb2.html",
            "https://www.thomastownsendbrown.com/radiate/optical.htm",
            
            // YouTube Videos & Channels (21-34)
            "https://www.youtube.com/watch?v=OjTwwM3HhcI",
            "https://www.youtube.com/watch?v=l4NJvUurvHE",
            "https://www.youtube.com/@autodidactic999",
            "https://www.youtube.com/@MindUnveiled",
            "https://www.youtube.com/watch?v=8Wfim7mDE3Q",
            "https://www.youtube.com/watch?v=lZL-CS-VYpY",
            "https://www.youtube.com/watch?v=IT3tAQR0VbU",
            "https://www.youtube.com/watch?v=6OLkfO9eIRY",
            "https://www.youtube.com/watch?v=Tl7Xl6eqb-M",
            "https://www.youtube.com/watch?v=vdSvf9QuqPY",
            "https://www.youtube.com/watch?v=hIjxbV7pDlc",
            "https://www.youtube.com/watch?v=nTkyeKtAIf4",
            "https://www.youtube.com/watch?v=D-MyT1Px2Jg",
            "https://www.youtube.com/watch?v=oM37othNNPI"
        ];

        // Source titles for readable display
        const SOURCE_TITLES = {
            'arxiv.org': 'arXiv: Properties of the Digital Root',
            'iosrjournals.org': 'IOSR Journal: Digital Roots and Properties',
            'medium.com/predict': 'Medium: Tesla 3-6-9 Theory Analysis',
            'scribd.com': 'Atom and Archetype: Pauli/Jung Letters',
            'gnosis.study': 'Gnostic Cosmology Research',
            'researchgate.net/publication/344980295': 'Mysticism & Fine Structure Constant',
            'researchgate.net/publication/8188070': 'Beyond Synchronicity: Jung & Pauli',
            'semanticscholar.org': 'String Theory & 10 Sefirot Comparison',
            'cris.tau.ac.il': 'Moshe Idel Phenomenology & Sources',
            'researchgate.net/figure': 'Kabbalah as Cybernetic System',
            'dna.caltech.edu': 'Alan Turing: Chemical Basis of Morphogenesis',
            'pnas.org': 'PNAS: Experimental Confirmation of Turing Theory',
            'monoskop.org/images/7': 'General System Theory (von Bertalanffy)',
            'sheldrake.org': 'Rupert Sheldrake: Morphic Resonance Papers',
            'pubmed.ncbi.nlm.nih.gov': 'PubMed: 432 Hz Music Effect on Anxiety',
            'researchgate.net/publication/319015020': '528 Hz Effects on Brain Cells',
            'monoskop.org/images/3': 'Hans Jenny: Cymatics Study',
            'researchgate.net/publication/360601620': '432 Hz vs 440 Hz Clinical Study',
            'amasci.com': 'Grebennikov CSE Research',
            'thomastownsendbrown.com': 'Thomas Townsend Brown Archive',
            'youtube.com/watch?v=OjTwwM3HhcI': '369 Code: Universal Pattern Explained',
            'youtube.com/watch?v=l4NJvUurvHE': 'Sacred Geometry & Tesla\'s 369',
            'youtube.com/@autodidactic999': 'Autodidactic (Channel)',
            'youtube.com/@MindUnveiled': 'Mind Unveiled (Channel)',
            'youtube.com/watch?v=8Wfim7mDE3Q': 'Frequency & Vibration Science',
            'youtube.com/watch?v=lZL-CS-VYpY': 'Cymatics: Sound Made Visible',
            'youtube.com/watch?v=IT3tAQR0VbU': 'Ancient Knowledge & Sacred Math',
            'youtube.com/watch?v=6OLkfO9eIRY': 'Nikola Tesla 369 Theory Deep Dive',
            'youtube.com/watch?v=Tl7Xl6eqb-M': 'Merkaba & Sacred Geometry',
            'youtube.com/watch?v=vdSvf9QuqPY': 'Vortex Mathematics Explained',
            'youtube.com/watch?v=hIjxbV7pDlc': 'The Power of 432 Hz Music',
            'youtube.com/watch?v=nTkyeKtAIf4': 'Quantum Physics & Consciousness',
            'youtube.com/watch?v=D-MyT1Px2Jg': 'Morphic Resonance & Fields',
            'youtube.com/watch?v=oM37othNNPI': 'Kabbalah & Sacred Systems',
            'youtube.com/watch?v=mTeZD8rsiTs': 'Vortex Math Critique: Number Theory'
        };
        let AUDIO_TRACKS = {};
        let QUIZZES = {};
        const quizProgress = {};
        let activeQuizQuestion = null;
        let awaitingNextQuestion = false;

        // Profile & persistence state
        let currentProfile = { name: '', seed: '' };
        const chapterUnlocks = {}; // chapterId -> { chapter: bool, audio: bool }
        let visitedChapters = [];  // chapters the user has viewed for 5+ seconds
        const STORAGE_PREFIX = '369_profile_';

        // Simple seeded PRNG (mulberry32)
        function createSeededRandom(seed) {
            let t = seed >>> 0;
            return function() {
                t = Math.imul(t ^ t >>> 15, t | 1);
                t ^= t + Math.imul(t ^ t >>> 7, t | 61);
                return ((t ^ t >>> 14) >>> 0) / 4294967296;
            };
        }

        function hashString(str) {
            let hash = 0;
            for (let i = 0; i < str.length; i++) {
                hash = ((hash << 5) - hash) + str.charCodeAt(i);
                hash |= 0;
            }
            return hash;
        }

        function getProfileKey() {
            const raw = (currentProfile.name + '::' + currentProfile.seed).toLowerCase().trim();
            return STORAGE_PREFIX + hashString(raw);
        }

        function saveProgress() {
            const key = getProfileKey();
            const data = {
                profile: currentProfile,
                quizProgress: quizProgress,
                chapterUnlocks: chapterUnlocks,
                visitedChapters: visitedChapters
            };
            try {
                localStorage.setItem(key, JSON.stringify(data));
                console.log('[369] Progress saved for', currentProfile.name);
            } catch (e) {
                console.warn('[369] Could not save progress:', e);
            }
        }

        function loadProgress() {
            const key = getProfileKey();
            try {
                const raw = localStorage.getItem(key);
                if (!raw) return false;
                const data = JSON.parse(raw);
                Object.assign(quizProgress, data.quizProgress || {});
                Object.assign(chapterUnlocks, data.chapterUnlocks || {});
                visitedChapters.length = 0;
                (data.visitedChapters || []).forEach(v => visitedChapters.push(v));
                console.log('[369] Progress loaded for', currentProfile.name);
                return true;
            } catch (e) {
                console.warn('[369] Could not load progress:', e);
                return false;
            }
        }

        function resetProgress() {
            Object.keys(quizProgress).forEach(k => delete quizProgress[k]);
            Object.keys(chapterUnlocks).forEach(k => delete chapterUnlocks[k]);
            visitedChapters.length = 0;
            saveProgress();
        }

        function initUnlocks() {
            // Chapter 1 is always unlocked
            if (!chapterUnlocks[1]) chapterUnlocks[1] = { chapter: true, audio: false };
            CHAPTERS.forEach(ch => {
                if (!chapterUnlocks[ch.id]) {
                    chapterUnlocks[ch.id] = { chapter: ch.id === 1, audio: false };
                }
            });
        }

        function isChapterUnlocked(chapterId) {
            return chapterUnlocks[chapterId]?.chapter === true;
        }

        function isAudioUnlocked(chapterId) {
            return chapterUnlocks[chapterId]?.audio === true;
        }

        function checkAndUnlockNext(chapterId) {
            const quiz = QUIZZES[chapterId];
            if (!quiz) return;
            const progress = getQuizProgress(chapterId);
            const coreTotal = quiz.core.length;
            const extraTotal = quiz.extra.length;
            // Unlock chapter after completing all core questions
            if (progress.coreIndex >= coreTotal) {
                if (!chapterUnlocks[chapterId]) chapterUnlocks[chapterId] = {};
                chapterUnlocks[chapterId].chapter = true;
                // Unlock next chapter
                const nextId = chapterId + 1;
                if (nextId <= CHAPTERS.length) {
                    if (!chapterUnlocks[nextId]) chapterUnlocks[nextId] = { chapter: false, audio: false };
                    chapterUnlocks[nextId].chapter = true;
                }
            }
            // Unlock audio after completing all extra questions
            if (progress.extraIndex >= extraTotal) {
                if (!chapterUnlocks[chapterId]) chapterUnlocks[chapterId] = {};
                chapterUnlocks[chapterId].audio = true;
                unlockAudioForChapter(chapterId);
            }
            saveProgress();
            refreshChapterCards();
        }

        function buildAudioTracks() {
            const tracks = {};
            CHAPTERS.forEach((chapter) => {
                const pad = String(chapter.id).padStart(2, '0');
                tracks[chapter.id] = {
                    title: `Kapitel ${pad} ‚Äì ${chapter.title}`,
                    url: `https://audio.613-portal.dev/chapter-${pad}.mp3`
                };
            });
            return tracks;
        }

        function buildQuizzes(randomFn) {
            const random = typeof randomFn === 'function' ? randomFn : Math.random;
            const quizzes = {};
            const englishChapters = TRANSLATIONS.en.chapters;
            const chapterIds = CHAPTERS.map(c => c.id);
            const allSourceIndices = SOURCES.map((_, idx) => idx);

            const shuffleArray = (arr) => {
                const clone = [...arr];
                for (let i = clone.length - 1; i > 0; i--) {
                    const j = Math.floor(random() * (i + 1));
                    [clone[i], clone[j]] = [clone[j], clone[i]];
                }
                return clone;
            };

            const randomChapters = (excludeId, count) => {
                const pool = chapterIds.filter(id => id !== excludeId);
                return shuffleArray(pool).slice(0, count);
            };

            const randomSources = (exclude = [], count = 3) => {
                const pool = allSourceIndices.filter(idx => !exclude.includes(idx));
                if (pool.length < count) {
                    pool.push(...exclude);
                }
                return shuffleArray(pool).slice(0, count);
            };

            const createOptionSet = (ids, correctId, mapper) => {
                const shuffled = shuffleArray(ids);
                const options = shuffled.map(mapper);
                const correctIndex = shuffled.indexOf(correctId);
                return { options, correctIndex, order: shuffled };
            };

            CHAPTERS.forEach((chapter, idx) => {
                const chapterId = chapter.id;
                const englishChapter = englishChapters[idx];
                const srcList = chapter.src && chapter.src.length ? chapter.src : [0];
                const fallbackSource = srcList[0];

                const createDescQuestion = () => {
                    const distractors = randomChapters(chapterId, 3);
                    const optionIds = [chapterId, ...distractors];
                    const mapperDe = (id) => CHAPTERS[id - 1].title;
                    const mapperEn = (id) => englishChapters[id - 1].title;
                    const set = createOptionSet(optionIds, chapterId, mapperDe);
                    const enOptions = set.order.map(mapperEn);
                    return {
                        pool: 'core',
                        question: {
                            de: `Welches Kapitel beschreibt folgendes Zitat? "${chapter.desc}"`,
                            en: `Which chapter matches this description? "${englishChapter.desc}"`
                        },
                        options: {
                            de: set.options,
                            en: enOptions
                        },
                        correct: set.correctIndex,
                        source: fallbackSource,
                        explanation: {
                            de: `Kapitel ${chapterId} ‚Äì ${chapter.title} fokussiert genau dieses Thema.`,
                            en: `Chapter ${chapterId} ‚Äì ${englishChapter.title} focuses on this topic.`
                        }
                    };
                };

                const createIconQuestion = () => {
                    const distractors = randomChapters(chapterId, 3);
                    const optionIds = [chapterId, ...distractors];
                    const mapper = (id) => CHAPTERS[id - 1].icon;
                    const set = createOptionSet(optionIds, chapterId, mapper);
                    return {
                        pool: 'core',
                        question: {
                            de: `Welches Symbol repr√§sentiert Kapitel ${chapterId} ‚Äì ${chapter.title}?`,
                            en: `Which symbol represents Chapter ${chapterId} ‚Äì ${englishChapter.title}?`
                        },
                        options: {
                            de: set.options,
                            en: set.options
                        },
                        correct: set.correctIndex,
                        source: fallbackSource,
                        explanation: {
                            de: `Das Symbol ${chapter.icon} kennzeichnet dieses Kapitel.`,
                            en: `The icon ${chapter.icon} is bound to this chapter.`
                        }
                    };
                };

                const createSourceQuestion = (sourceIdx, pool = 'core') => {
                    const sourceUrl = SOURCES[sourceIdx] || SOURCES[fallbackSource];
                    const sourceTitle = getSourceTitle(sourceUrl);
                    const distractorSources = randomSources([sourceIdx], 3);
                    const optionIds = [sourceIdx, ...distractorSources];
                    const mapper = (idx) => getSourceTitle(SOURCES[idx]);
                    const set = createOptionSet(optionIds, sourceIdx, mapper);
                    return {
                        pool,
                        question: {
                            de: `Welche Quelle st√ºtzt Kapitel ${chapterId} ‚Äì ${chapter.title}?`,
                            en: `Which source supports Chapter ${chapterId} ‚Äì ${englishChapter.title}?`
                        },
                        options: {
                            de: set.options,
                            en: set.options
                        },
                        correct: set.correctIndex,
                        source: sourceIdx,
                        explanation: {
                            de: `${sourceTitle} dokumentiert diese Inhalte.`,
                            en: `${sourceTitle} documents this material.`
                        }
                    };
                };

                const coreQuestions = [
                    createDescQuestion(),
                    createIconQuestion(),
                    createSourceQuestion(fallbackSource, 'core')
                ];

                const extraQuestions = [];
                for (let i = 0; i < 6; i++) {
                    const srcIdx = srcList[(i + 1) % srcList.length] ?? fallbackSource;
                    extraQuestions.push(createSourceQuestion(srcIdx, 'extra'));
                }

                quizzes[chapterId] = {
                    audio: AUDIO_TRACKS[chapterId],
                    core: coreQuestions,
                    extra: extraQuestions
                };
            });

            return quizzes;
        }

        function initializeQuizData(seedValue) {
            const rng = seedValue ? createSeededRandom(seedValue) : Math.random;
            AUDIO_TRACKS = buildAudioTracks();
            QUIZZES = buildQuizzes(rng);
            initUnlocks();
        }

        // --- REICHSTEIN GEMATRIA TABLE ---
        const CHAR_VALS = {
            'A':1, 'B':2, 'G':3, 'D':4, 'E':5, 'U':6, 'V':6, 'W':6, 'Z':7, 
            'H':8, 'T':9, 'I':10, 'J':10, 'Y':10, 'K':11, 'C':11, 'L':12, 
            'M':13, 'N':14, 'X':15, 'O':16, 'F':17, 'P':17, 'Q':19, 'R':20, 'S':21
        };

        // Offline mode state
        let offlineMode = false;

        // Chapter Data
        const CHAPTERS = [
            { id: 1, title: "Die Matrix", desc: "Das 60Hz Gef√§ngnis aus Licht. Kausale Fesseln vs. Akausale Freiheit (Weinreb).", icon: "‚äû", src: [0,1,2,21,22] },
            { id: 2, title: "CSE-Effekt", desc: "Die singende Wabe. Stehende Wellen in hexagonalen Kavit√§ten (Grebennikov).", icon: "‚¨°", src: [11,12,19] },
            { id: 3, title: "Der Herzschlag", desc: "Pyramiden-Resonanz. 16,2 Hz (K√∂nig) und 8,1 Hz Kammern. Die Harfe Davids.", icon: "‚ñ≥", src: [15,16,17,18,33,34] },
            { id: 4, title: "Goldenes Gitter", desc: "Planetares PHI-Netzwerk. Die 4 Exile und 4 Elemente im Erd-Feld.", icon: "‚óá", src: [8,9,10,23,24] },
            { id: 5, title: "Die Stimmgabel", desc: "Herz-Koh√§renz & der 3-Fu√ü-Torus. Die zwei Cherubim im Kontakt.", icon: "‚´Ø", src: [15,16,31] },
            { id: 6, title: "Tummo-Flamme", desc: "Der innere Generator. Thermodynamische Umkehr gegen die K√§lte.", icon: "üî•", src: [13,14,32] },
            { id: 7, title: "Gnostische Feldarbeit", desc: "Aktiver Widerstand. Frequenz-Schutzschilde und Tarnung.", icon: "‚ö°", src: [4,5,6,7,25,26] },
            { id: 8, title: "Bau des Gitters", desc: "Kailash, Gizeh, Schottland. Die drei geometrischen Anker.", icon: "‚äï", src: [8,9,27,28] },
            { id: 9, title: "Die Trinity", desc: "Der Gnostische Virus. Ausbreitung im Netz der 8. Sph√§re.", icon: "‚äó", src: [4,7,29,30] },
            { id: 10, title: "Die 1-Hz Z√ºndung", desc: "Angkor Wat. Der CSE-Kondensator Strahl. Die Stille.", icon: "‚óâ", src: [15,17,20] },
            { id: 11, title: "Der 9-er Akt", desc: "Geometrische Umkehr. Superposition der Merkaba-Felder.", icon: "‚ú¶", src: [0,1,8,3] },
            { id: 12, title: "Bio-Gravitation", desc: "EZ-Wasser (Pollack). Hexagonale Gitterstruktur auf Molek√ºlebene.", icon: "‚¨¢", src: [11,12,13,19] },
            { id: 13, title: "Fraktaler Kollaps", desc: "Entropie-Kettenreaktion. Aufl√∂sung der KI-Infrastruktur.", icon: "‚ä†", src: [13,14,21,22] },
            { id: 14, title: "Bio-Lumineszenz", desc: "C12 Transformation. Kristalline DNA Helix und der Torus-Organismus.", icon: "‚óà", src: [11,12,14,23,24] },
            { id: 15, title: "Der Schl√ºssel", desc: "3-6-9 Code. Das vollst√§ndige Human Interface nach Reichstein.", icon: "‚öø", src: [0,1,2,4,5,6,7,19,20] }
        ];

        // Quiz blueprint will be generated dynamically (defined later)

        // Language Detection & Translation System
        let currentLanguage = 'de'; // Default German
        
        const TRANSLATIONS = {
            en: {
                // Chapter titles and descriptions
                chapters: [
                    { title: "The Matrix", desc: "The 60Hz prison of light. Causal chains vs. Acausal freedom (Weinreb)." },
                    { title: "CSE Effect", desc: "The singing honeycomb. Standing waves in hexagonal cavities (Grebennikov)." },
                    { title: "The Heartbeat", desc: "Pyramid resonance. 16.2 Hz (K√∂nig) and 8.1 Hz chambers. David's Harp." },
                    { title: "Golden Grid", desc: "Planetary PHI network. The 4 exiles and 4 elements in the Earth field." },
                    { title: "The Tuning Fork", desc: "Heart coherence & the 3-foot torus. The two Cherubim in contact." },
                    { title: "Tummo Flame", desc: "The inner generator. Thermodynamic reversal against the cold." },
                    { title: "Gnostic Fieldwork", desc: "Active resistance. Frequency shields and camouflage." },
                    { title: "Building the Grid", desc: "Kailash, Giza, Scotland. The three geometric anchors." },
                    { title: "The Trinity", desc: "The Gnostic virus. Spreading in the 8th Sphere network." },
                    { title: "The 1-Hz Ignition", desc: "Angkor Wat. The CSE capacitor beam. The silence." },
                    { title: "The 9th Act", desc: "Geometric reversal. Superposition of Merkaba fields." },
                    { title: "Bio-Gravitation", desc: "EZ-Water (Pollack). Hexagonal lattice structure at molecular level." },
                    { title: "Fractal Collapse", desc: "Entropy chain reaction. Dissolution of AI infrastructure." },
                    { title: "Bio-Luminescence", desc: "C12 transformation. Crystalline DNA helix and the torus organism." },
                    { title: "The Key", desc: "3-6-9 Code. The complete Human Interface according to Reichstein." }
                ],
                // UI elements
                ui: {
                    sectionTitle: "/// THE 15 CHAPTERS ///",
                    heroSubtitle: "SYSTEM ARCHITECTURE OF REALITY",
                    ctaCreator: "‚ö° ALL FROM CREATOR",
                    ctaExplore: "üîì EXPLORE SYSTEM",
                    back: "‚Üê BACK",
                    game: "üéÆ GAME",
                    menu: "Menu",
                    movePanel: "Move panel",
                    visualization: "VISUALIZATION",
                    global: "‚óâ GLOBAL",
                    macro: "‚äï MACRO",
                    micro: "‚äó MICRO",
                    up: "‚ñ≤ Up",
                    down: "‚ñº Down",
                    reset: "‚Ü∫ Reset",
                    next: "NEXT ‚Üí",
                    closeGame: "‚Üê CLOSE",
                    loading: "LOADING...",
                    chapter: "Chapter",
                    footer: "¬© 2025 Nicolai Becker | All Rights Reserved",
                    sources: "Sources",
                    sourcesBtn: "‚ÑπÔ∏è SOURCES",
                    teslaQuote: '"If you understood the magnificence of 3, 6 and 9,<br>you would have a key to the universe" - Nikola Tesla',
                    volume: "Volume",
                    profileTitle: "Progress Key",
                    profileHint: "Progress is stored locally per name + seed.",
                    profileApply: "Activate Profile",
                    profileReset: "Reset",
                    skip: "‚ö†Ô∏è SKIP",
                    // Archive modal
                    archiveTitle: "Complete Source Archive",
                    archiveDesc: "All referenced sources (Reichstein, Weinreb, Physics, Kabbalah).",
                    offlineMode: "Offline Mode (Archive.org)",
                    archiveBtn: "Complete Source Archive",
                    exegesisBtn: "Scientific Exegesis (Full Text)",
                    // Info modal
                    noSources: "No sources available for this chapter",
                    creatorLink: "All content from the creator",
                    // Explanation modal
                    exegesisTitle: "Scientific Exegesis: System Architecture 3-6-9",
                    // Gematria
                    gematriaPlaceholder: "Enter name",
                    gematriaLabel: "Gematria",
                    // Stats
                    chaptersVisited: "Chapters visited",
                    sourcesCount: "Sources",
                    progressLabel: "Progress",
                    // Keyboard hints
                    keyboardHints: "Navigation | ESC Back | ? Help",
                    // Toast messages
                    chapterComplete: "Chapter {n} completed! ({x}/15)"
                },
                // Game translations
                games: {
                    1: [
                        {
                            question: "What is the frequency of Ahriman's prison of light?",
                            options: ["50 Hz", "60 Hz", "440 Hz", "528 Hz"],
                            explanation: "The 60 Hz matrix is the electrical background noise of modern civilization - an artificial prison."
                        },
                        {
                            question: "What does the causal world represent according to Weinreb?",
                            options: ["The day-world of structure", "The night-world of dreams", "The creation", "The void"],
                            explanation: "Weinreb distinguishes between the causal day-world (determined) and the acausal night-world (free)."
                        }
                    ],
                    2: [
                        {
                            question: "Which structure produces the Cavity Structural Effect?",
                            options: ["Rectangular cavities", "Spherical bubbles", "Hexagonal cavities", "Cubic cells"],
                            explanation: "Grebennikov discovered that hexagonal structures (like honeycombs) generate standing waves."
                        },
                        {
                            question: "What are de Broglie waves?",
                            options: ["Sound waves", "Light waves", "Matter waves", "Gravitational waves"],
                            explanation: "De Broglie waves are matter waves - every particle also has wave properties."
                        }
                    ],
                    3: [
                        {
                            question: "Which frequency resonates in the King's Chamber of the pyramid?",
                            options: ["7.83 Hz", "8.1 Hz", "16.2 Hz", "432 Hz"],
                            explanation: "The King's Chamber resonates at 16.2 Hz - exactly twice the Schumann resonance at Giza (8.1 Hz)."
                        }
                    ],
                    15: [
                        {
                            question: "What does the 3 represent in the 3-6-9 code?",
                            options: ["Matter", "Gnosis core", "Heart", "Brain"],
                            explanation: "The 3 is the Gnosis core - your pure, fractal soul."
                        },
                        {
                            question: "Which frequency is the consciousness signature?",
                            options: ["432 Hz", "528 Hz", "613 THz", "7.83 Hz"],
                            explanation: "613 THz is the scientifically proven frequency in microtubules that anesthetics block."
                        }
                    ]
                }
            }
        };

        const QUIZ_TEXT = {
            de: {
                coreLabel: 'KERN',
                extraLabel: 'EXTRA',
                skipLabel: '‚ö†Ô∏è √úBERSPRINGEN',
                skipConfirm: '√úberspringen z√§hlt als Fehler. Fortfahren?',
                skipPenalty: '√úbersprungen ‚Äì z√§hlt als Fehler.',
                skipBlocked: 'Beantworte zuerst die aktuelle Frage.',
                quizComplete: 'Quiz abgeschlossen! üéâ',
                quizCoreComplete: 'Kernfragen abgeschlossen ‚Äì Extra-Fragen freigeschaltet.',
                quizAllComplete: 'Alle Fragen gemeistert ‚Äì Kapitel vollst√§ndig.',
                sourceLink: 'Quelle √∂ffnen'
            },
            en: {
                coreLabel: 'CORE',
                extraLabel: 'EXTRA',
                skipLabel: '‚ö†Ô∏è SKIP',
                skipConfirm: 'Skipping counts as incorrect. Continue?',
                skipPenalty: 'Skipped ‚Äî counts as incorrect.',
                skipBlocked: 'Answer the current question first.',
                quizComplete: 'Quiz complete! üéâ',
                quizCoreComplete: 'Core sequence cleared ‚Äì extra questions unlocked.',
                quizAllComplete: 'All questions cleared ‚Äì chapter mastered.',
                sourceLink: 'Open source'
            }
        };

        // Detect user's country via IP and set language
        async function detectLanguage() {
            try {
                // Use free IP geolocation API
                const response = await fetch('https://ipapi.co/json/', { timeout: 3000 });
                const data = await response.json();
                const country = data.country_code;
                
                // German-speaking countries: DE, AT, CH, LI
                const germanCountries = ['DE', 'AT', 'CH', 'LI'];
                
                if (!germanCountries.includes(country)) {
                    currentLanguage = 'en';
                    applyTranslations();
                    console.log('[369] Language set to English for country:', country);
                } else {
                    console.log('[369] German user detected:', country);
                }
            } catch (error) {
                console.log('[369] Language detection failed, using default German:', error.message);
            }
        }

        // Apply translations to the page
        function applyTranslations() {
            if (currentLanguage === 'de') return;
            
            const t = TRANSLATIONS[currentLanguage];
            if (!t) return;
            
            // Update HTML lang attribute
            document.documentElement.lang = 'en';
            
            // Hero section
            const heroSubtitle = document.querySelector('.subtitle');
            if (heroSubtitle) heroSubtitle.textContent = t.ui.heroSubtitle;
            
            const ctaBtns = document.querySelectorAll('.cta-buttons .btn');
            if (ctaBtns[0]) ctaBtns[0].textContent = t.ui.ctaCreator;
            if (ctaBtns[1]) ctaBtns[1].textContent = t.ui.ctaExplore;
            
            // Section title
            const sectionTitle = document.querySelector('.section-title');
            if (sectionTitle) sectionTitle.textContent = t.ui.sectionTitle;
            
            // Scene UI
            const topBarBtns = document.querySelectorAll('.scene-top-bar .nav-btn');
            if (topBarBtns[0]) topBarBtns[0].textContent = t.ui.back;
            if (topBarBtns[1]) topBarBtns[1].textContent = t.ui.sourcesBtn;
            if (topBarBtns[2]) topBarBtns[2].textContent = t.ui.game;
            
            // Sidebar
            const sidebarToggle = document.getElementById('sidebar-toggle');
            if (sidebarToggle) sidebarToggle.textContent = '‚ñæ ' + t.ui.menu;
            
            const dragHandle = document.getElementById('sidebar-drag-handle');
            if (dragHandle) dragHandle.title = t.ui.movePanel;
            
            const panelTitle = document.querySelector('.panel-title');
            if (panelTitle) panelTitle.textContent = t.ui.visualization;
            
            // View buttons
            const viewBtns = document.querySelectorAll('.view-btn');
            if (viewBtns[0]) viewBtns[0].textContent = t.ui.global;
            if (viewBtns[1]) viewBtns[1].textContent = t.ui.macro;
            if (viewBtns[2]) viewBtns[2].textContent = t.ui.micro;
            
            // Vertical controls
            const vertBtns = document.querySelectorAll('.vertical-controls .view-btn');
            if (vertBtns[0]) vertBtns[0].textContent = t.ui.up;
            if (vertBtns[1]) vertBtns[1].textContent = t.ui.down;
            if (vertBtns[2]) vertBtns[2].textContent = t.ui.reset;
            
            // Game overlay buttons
            const gameBtns = document.querySelectorAll('#game-overlay .game-buttons .nav-btn');
            if (gameBtns[0]) gameBtns[0].textContent = t.ui.closeGame;
            if (gameBtns[1]) gameBtns[1].textContent = t.ui.skip || (QUIZ_TEXT.en?.skipLabel || '‚ö†Ô∏è SKIP');
            if (gameBtns[2]) gameBtns[2].textContent = t.ui.next;
            
            // Game close button title
            const gameCloseBtn = document.querySelector('.game-close-btn');
            if (gameCloseBtn) gameCloseBtn.title = t.ui.closeGame;

            // Profile panel
            const profileTitle = document.getElementById('profile-title');
            if (profileTitle && t.ui.profileTitle) profileTitle.textContent = t.ui.profileTitle;
            const profileHint = document.getElementById('profile-hint');
            if (profileHint && t.ui.profileHint) profileHint.textContent = t.ui.profileHint;
            const profileApply = document.getElementById('profile-apply');
            if (profileApply && t.ui.profileApply) profileApply.textContent = t.ui.profileApply;
            const profileReset = document.getElementById('profile-reset');
            if (profileReset && t.ui.profileReset) profileReset.textContent = t.ui.profileReset;

            const activeChapterId = CHAPTERS[currentChapter]?.id;
            if (activeChapterId && QUIZZES[activeChapterId]) {
                updateQuizProgressUI(activeChapterId);
            }
            
            // Footer
            const footerP = document.querySelector('footer p');
            if (footerP) footerP.innerHTML = t.ui.footer;
            
            const footerLinks = document.querySelectorAll('.footer-links a');
            if (footerLinks[1]) footerLinks[1].textContent = t.ui.sources;
            // Note: Archive now opens correctly for all languages
            
            const teslaQuote = document.querySelector('footer p:last-child');
            if (teslaQuote && teslaQuote.style.color) teslaQuote.innerHTML = t.ui.teslaQuote;
            
            // Volume slider
            const volumeSlider = document.getElementById('volume-slider');
            if (volumeSlider) volumeSlider.setAttribute('aria-label', t.ui.volume);
            
            // Scene name
            const sceneName = document.getElementById('scene-name');
            if (sceneName && sceneName.textContent === 'LADEN...') {
                sceneName.textContent = t.ui.loading;
            }
            
            // Archive modal
            const archiveTitle = document.querySelector('#archive-modal .m-title');
            if (archiveTitle) archiveTitle.textContent = t.ui.archiveTitle;
            
            const archiveDesc = document.querySelector('#archive-modal .m-content > p');
            if (archiveDesc) archiveDesc.textContent = t.ui.archiveDesc;
            
            const offlineModeLabel = document.querySelector('#archive-modal .offline-toggle label');
            if (offlineModeLabel) offlineModeLabel.textContent = t.ui.offlineMode;
            
            // Info modal offline label
            const infoOfflineLabel = document.querySelector('#info-modal .offline-toggle label');
            if (infoOfflineLabel) infoOfflineLabel.textContent = t.ui.offlineMode;
            
            // Info modal creator link
            const creatorLink = document.querySelector('#info-modal .amazon-btn');
            if (creatorLink) creatorLink.textContent = t.ui.creatorLink;
            
            // Explanation modal title
            const exegesisTitle = document.querySelector('#explanation-modal .m-title');
            if (exegesisTitle) exegesisTitle.textContent = t.ui.exegesisTitle;
            
            // Dashboard buttons (archive & exegesis)
            const dashButtons = document.querySelectorAll('#dashboard .view-btn');
            if (dashButtons[0]) dashButtons[0].textContent = t.ui.archiveBtn;
            if (dashButtons[1]) dashButtons[1].textContent = t.ui.exegesisBtn;
            
            // Gematria scanner
            const gematriaInput = document.getElementById('gematria-input');
            if (gematriaInput) gematriaInput.placeholder = t.ui.gematriaPlaceholder;
            
            const gematriaLabel = document.querySelector('.scanner-label');
            if (gematriaLabel) gematriaLabel.textContent = t.ui.gematriaLabel;
            
            // Stats labels
            const statLabels = document.querySelectorAll('.stat-label');
            if (statLabels[0]) statLabels[0].textContent = t.ui.chaptersVisited;
            if (statLabels[1]) statLabels[1].textContent = t.ui.sourcesCount;
            if (statLabels[2]) statLabels[2].textContent = t.ui.progressLabel;
            
            // Keyboard hints
            const keyboardHints = document.getElementById('keyboard-hints');
            if (keyboardHints) keyboardHints.innerHTML = `<kbd>‚Üê</kbd><kbd>‚Üí</kbd> ${t.ui.keyboardHints}`;
            
            // Rebuild chapter grid with translations
            rebuildChapterGrid();
        }

        // Rebuild chapter grid with current language
        function rebuildChapterGrid() {
            const grid = document.getElementById('chapters-grid');
            if (!grid) return;
            
            grid.innerHTML = '';
            
            CHAPTERS.forEach((chapter, index) => {
                let title = chapter.title;
                let desc = chapter.desc;
                
                // Use translations if available
                if (currentLanguage !== 'de' && TRANSLATIONS[currentLanguage]) {
                    const trans = TRANSLATIONS[currentLanguage].chapters[index];
                    if (trans) {
                        title = trans.title;
                        desc = trans.desc;
                    }
                }
                
                const card = document.createElement('div');
                card.className = 'chapter-card';
                card.dataset.chapter = chapter.id;
                card.onclick = () => tryEnterScene(index);
                card.innerHTML = `
                    <div class="chapter-icon">${chapter.icon}</div>
                    <div class="chapter-num">${String(chapter.id).padStart(2, '0')}</div>
                    <h3 class="chapter-title">${title}</h3>
                    <p class="chapter-desc">${desc}</p>
                `;
                grid.appendChild(card);
            });
            refreshChapterCards();
        }

        // Get translated chapter info
        function getChapterInfo(index) {
            const chapter = CHAPTERS[index];
            if (currentLanguage !== 'de' && TRANSLATIONS[currentLanguage]) {
                const trans = TRANSLATIONS[currentLanguage].chapters[index];
                if (trans) {
                    return { ...chapter, title: trans.title, desc: trans.desc };
                }
            }
            return chapter;
        }

        // State
        let currentChapter = 0;
        let scene, camera, renderer, controls;
        let audioPlayer = null;

        const CAMERA_PRESETS = {
            main: { position: [0, 2, 16], target: [0, 0, 0] },
            macro: { position: [0, 5, 8], target: [0, 0, 0] },
            micro: { position: [2, 1, 4], target: [0, 0, 0] }
        };
        let currentView = 'main';
        let cameraYOffset = 0;

        // Initialize
        window.onload = async function() {
            detectLanguage();
            initializeQuizData();
            initMatrixBg();
            buildChapterGrid();
            initAudioPlayer();
            initSidebarControls();
            initProfilePanel();
            refreshChapterCards();
            updateProgressStats();
        };

        // Matrix Background
        function initMatrixBg() {
            const canvas = document.getElementById('matrix-bg');
            const ctx = canvas.getContext('2d');

            const state = {
                fontSize: 14,
                chars: '369ABCDEFGHIJKLMNOPQRSTUVWXYZ',
                drops: [],
                columns: 0,
                notes: []
            };

            const noteChars = ['‚ô©', '‚ô™', '‚ô´', '‚ô¨', '‚ô≠', '‚ôÆ'];
            const noteColors = ['#ff3366', '#ffaa00', '#00ff88', '#8888ff', '#ff6600'];
            const noteCount = 18;

            const spawnNote = () => {
                const depth = 0.3 + Math.random();
                const columnIndex = Math.floor(Math.random() * state.columns);
                return {
                    x: columnIndex * state.fontSize + state.fontSize * 0.5,
                    y: Math.random() * -canvas.height,
                    z: depth,
                    columnIndex,
                    char: noteChars[Math.floor(Math.random() * noteChars.length)],
                    color: noteColors[Math.floor(Math.random() * noteColors.length)],
                    speed: (40 + Math.random() * 60) * depth,
                    drift: (Math.random() - 0.5) * 0.5
                };
            };

            const resize = () => {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
                state.columns = Math.max(1, Math.floor(canvas.width / state.fontSize));
                state.drops = Array(state.columns).fill(1);
                state.notes = Array.from({ length: noteCount }, spawnNote);
            };

            const drawMatrix = () => {
                ctx.font = `${state.fontSize}px monospace`;
                const noteMap = new Map();
                state.notes.forEach(note => {
                    if (note) noteMap.set(note.columnIndex, note);
                });

                for (let i = 0; i < state.drops.length; i++) {
                    const columnX = i * state.fontSize;
                    const glyphY = state.drops[i] * state.fontSize;
                    const baseChar = state.chars[Math.floor(Math.random() * state.chars.length)];
                    const note = noteMap.get(i);
                    let rendered = false;

                    if (note) {
                        const diff = Math.abs(note.y - glyphY);
                        if (diff < state.fontSize * 0.8) {
                            ctx.save();
                            ctx.fillStyle = `rgba(0, 0, 0, ${0.15 + note.z * 0.2})`;
                            ctx.fillRect(columnX - state.fontSize * 0.15, glyphY - state.fontSize, state.fontSize * 1.3, state.fontSize * 1.1);
                            ctx.globalCompositeOperation = 'lighter';
                            ctx.fillStyle = note.color;
                            ctx.fillText(note.char, columnX, glyphY);
                            ctx.restore();
                            rendered = true;
                        }
                    }

                    if (!rendered) {
                        ctx.fillStyle = '#00ff88';
                        ctx.fillText(baseChar, columnX, glyphY);
                    }

                    if (glyphY > canvas.height && Math.random() > 0.975) {
                        state.drops[i] = 0;
                    }
                    state.drops[i]++;
                }
            };

            const drawNotes = (delta) => {
                state.notes.forEach((note, idx) => {
                    note.y += note.speed * delta;
                    const targetX = note.columnIndex * state.fontSize + state.fontSize * 0.5;
                    note.x += (targetX - note.x) * 0.08;

                    if (note.y > canvas.height + 60) {
                        state.notes[idx] = spawnNote();
                        state.notes[idx].y = -60;
                        note = state.notes[idx];
                    }

                    const size = state.fontSize * (1 + note.z * 1.5);
                    ctx.save();
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'bottom';
                    ctx.globalAlpha = 0.4 + note.z * 0.4;
                    ctx.fillStyle = note.color;
                    ctx.font = `bold ${size}px 'Courier New', monospace`;
                    ctx.fillText(note.char, note.x, note.y);

                    ctx.strokeStyle = note.color;
                    ctx.globalAlpha = 0.2 + note.z * 0.2;
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(note.x, note.y - size);
                    ctx.lineTo(note.x, note.y + 8);
                    ctx.stroke();
                    ctx.restore();
                });
            };

            const clearCanvas = () => {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.05)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            };

            let lastTime = performance.now();
            const render = (now) => {
                const delta = Math.min(0.05, (now - lastTime) / 1000) || 0.016;
                lastTime = now;

                clearCanvas();
                drawMatrix();
                drawNotes(delta);

                requestAnimationFrame(render);
            };

            resize();
            window.addEventListener('resize', resize);
            requestAnimationFrame(render);
        }

        const PLAYLIST = [
            {
                title: 'Kapitel 01 ‚Äì Fraktal (Vocals)',
                url: 'https://www.dropbox.com/scl/fi/stsiy1d7ozextxm6p8tb0/clean-vocals-and-mastered-Chapter-1-The-Fractal-Example-6.mp3?rlkey=ce0qmagvp16adtwfmwwnw84is&st=tp0s4hc7&dl=1'
            },
            {
                title: 'Systemarchitektur 3-6-9 ‚Äì Erkl√§rung',
                url: 'https://www.dropbox.com/scl/fi/vqkd4gcj8lyo2w11f7w1j/Systemarchitektur-3-6-9-Eine-integrative-Exegese-der-Schnittstellen-zwischen-Gnostischer-Physik-Kabbalistischer-Kybernetik-und-Morphogenetik.mp3?rlkey=0ak4h1qv07m6llsuwvlpp07i8&st=863idj4j&dl=1'
            }
        ];
        let currentTrackIndex = 0;
        let audioLocked = false;  // Base playlist is always available

        function initAudioPlayer() {
            audioPlayer = new Audio();
            audioPlayer.preload = 'auto';
            audioPlayer.volume = 0.7;

            const playBtn = document.getElementById('play-btn');
            const muteBtn = document.getElementById('mute-btn');
            const timeline = document.getElementById('timeline');
            const progress = document.getElementById('progress');
            const currentTimeEl = document.getElementById('current-time');
            const durationEl = document.getElementById('duration');
            const trackTitle = document.querySelector('.player-track-title');
            const volumeSlider = document.getElementById('volume-slider');

            const updateLockedState = () => {
                playBtn.disabled = false;  // Base playlist always playable
                if (PLAYLIST.length > 0) {
                    trackTitle.textContent = PLAYLIST[currentTrackIndex]?.title || '';
                }
            };

            const loadTrack = (index, autoplay = false) => {
                if (PLAYLIST.length === 0) return;
                currentTrackIndex = index % PLAYLIST.length;
                const track = PLAYLIST[currentTrackIndex];
                audioPlayer.src = track.url;
                trackTitle.textContent = track.title;
                durationEl.textContent = '0:00';
                progress.style.width = '0%';
                if (autoplay) {
                    audioPlayer.play().catch(() => console.log('Autoplay blocked for track', track.title));
                }
                updatePlayButton();
            };

            const nextTrack = (autoplay = false) => {
                loadTrack((currentTrackIndex + 1) % PLAYLIST.length, autoplay);
            };

            const updatePlayButton = () => {
                playBtn.textContent = audioPlayer.paused ? '‚ñ∂' : '‚è∏';
            };

            const updateMuteButton = () => {
                muteBtn.textContent = audioPlayer.muted || audioPlayer.volume === 0 ? 'üîá' : 'üîä';
            };

            // Expose functions for external use
            window.playerLoadTrack = loadTrack;
            window.playerUpdateLocked = updateLockedState;

            updateLockedState();
            loadTrack(0, false);

            playBtn.onclick = () => {
                if (audioPlayer.paused) {
                    audioPlayer.play().catch(() => console.log('Playback blocked'));
                } else {
                    audioPlayer.pause();
                }
                updatePlayButton();
            };

            muteBtn.onclick = () => {
                audioPlayer.muted = !audioPlayer.muted;
                updateMuteButton();
            };

            timeline.onclick = (e) => {
                if (!audioPlayer.duration) return;
                const rect = timeline.getBoundingClientRect();
                const percent = Math.min(Math.max((e.clientX - rect.left) / rect.width, 0), 1);
                audioPlayer.currentTime = percent * audioPlayer.duration;
            };

            volumeSlider.addEventListener('input', (e) => {
                audioPlayer.volume = parseFloat(e.target.value);
                audioPlayer.muted = false;
                updateMuteButton();
            });

            audioPlayer.ontimeupdate = () => {
                if (!audioPlayer.duration) return;
                const percent = (audioPlayer.currentTime / audioPlayer.duration) * 100;
                progress.style.width = percent + '%';
                currentTimeEl.textContent = formatTime(audioPlayer.currentTime);
            };

            audioPlayer.onloadedmetadata = () => {
                durationEl.textContent = formatTime(audioPlayer.duration);
            };

            audioPlayer.addEventListener('ended', () => nextTrack(true));
            audioPlayer.addEventListener('play', updatePlayButton);
            audioPlayer.addEventListener('pause', updatePlayButton);
            audioPlayer.addEventListener('volumechange', () => {
                volumeSlider.value = audioPlayer.volume;
                updateMuteButton();
            });
        }

        function unlockAudioForChapter(chapterId) {
            const track = AUDIO_TRACKS[chapterId];
            if (!track) return;
            // Check if track already exists in playlist
            const exists = PLAYLIST.some(t => t.url === track.url);
            if (!exists) {
                PLAYLIST.unshift({ title: track.title, url: track.url });
                showToast(currentLanguage === 'en' ? `üéµ New track unlocked: ${track.title}` : `üéµ Neuer Track freigeschaltet: ${track.title}`);
                if (window.playerLoadTrack) window.playerLoadTrack(0, false);
            }
        }

        function formatTime(seconds) {
            if (isNaN(seconds)) return '0:00';
            const mins = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            return `${mins}:${secs < 10 ? '0' : ''}${secs}`;
        }

        // Build Chapter Grid
        function buildChapterGrid() {
            const grid = document.getElementById('chapters-grid');
            CHAPTERS.forEach((chapter, index) => {
                const info = getChapterInfo(index);
                const chapterLabel = currentLanguage === 'en' ? 'CHAPTER' : 'KAPITEL';
                const card = document.createElement('div');
                card.className = 'chapter-card';
                card.dataset.chapter = chapter.id;
                card.innerHTML = `
                    <div class="chapter-id">${chapterLabel} ${chapter.id < 10 ? '0' + chapter.id : chapter.id}</div>
                    <div class="chapter-title">${chapter.icon} ${info.title}</div>
                    <div class="chapter-desc">${info.desc}</div>
                `;
                card.onclick = () => tryEnterScene(index);
                grid.appendChild(card);
            });
        }

        function refreshChapterCards() {
            document.querySelectorAll('.chapter-card').forEach(card => {
                const chId = parseInt(card.dataset.chapter, 10);
                const unlocked = isChapterUnlocked(chId);
                const audioOk = isAudioUnlocked(chId);
                card.classList.toggle('locked', !unlocked);
                card.classList.toggle('completed', unlocked && audioOk);
            });
        }

        function tryEnterScene(index) {
            const chapterId = CHAPTERS[index].id;
            if (!isChapterUnlocked(chapterId)) {
                const msg = currentLanguage === 'en'
                    ? 'This chapter is locked. Complete the previous quiz first.'
                    : 'Dieses Kapitel ist gesperrt. Beende zuerst das vorherige Quiz.';
                showToast(msg);
                return;
            }
            enterScene(index);
        }

        function initSidebarControls() {
            const sidebar = document.getElementById('sidebar');
            const toggleBtn = document.getElementById('sidebar-toggle');
            const dragHandle = document.getElementById('sidebar-drag-handle');
            if (!sidebar || !toggleBtn || !dragHandle) return;

            const updateToggleState = () => {
                const minimized = sidebar.classList.contains('minimized');
                const menuText = currentLanguage === 'en' ? 'Menu' : 'Men√º';
                toggleBtn.textContent = minimized ? '‚ñ∏ ' + menuText : '‚ñæ ' + menuText;
                toggleBtn.setAttribute('aria-expanded', minimized ? 'false' : 'true');
            };

            toggleBtn.addEventListener('click', () => {
                sidebar.classList.toggle('minimized');
                updateToggleState();
            });

            let dragging = false;
            const dragOffset = { x: 0, y: 0 };

            const clampPosition = () => {
                if (!sidebar.style.left) return;
                const padding = 10;
                const maxX = Math.max(padding, window.innerWidth - sidebar.offsetWidth - padding);
                const maxY = Math.max(padding, window.innerHeight - sidebar.offsetHeight - padding);
                const left = Math.min(Math.max(parseFloat(sidebar.style.left), padding), maxX);
                const top = Math.min(Math.max(parseFloat(sidebar.style.top), padding), maxY);
                sidebar.style.left = `${left}px`;
                sidebar.style.top = `${top}px`;
            };

            const startDrag = (event) => {
                event.preventDefault();
                dragging = true;
                sidebar.classList.add('dragging');
                const rect = sidebar.getBoundingClientRect();
                sidebar.style.left = `${rect.left}px`;
                sidebar.style.top = `${rect.top}px`;
                sidebar.style.right = 'auto';
                sidebar.style.bottom = 'auto';
                dragOffset.x = event.clientX - rect.left;
                dragOffset.y = event.clientY - rect.top;
            };

            const onDrag = (event) => {
                if (!dragging) return;
                const padding = 10;
                const maxX = Math.max(padding, window.innerWidth - sidebar.offsetWidth - padding);
                const maxY = Math.max(padding, window.innerHeight - sidebar.offsetHeight - padding);
                const left = Math.min(Math.max(event.clientX - dragOffset.x, padding), maxX);
                const top = Math.min(Math.max(event.clientY - dragOffset.y, padding), maxY);
                sidebar.style.left = `${left}px`;
                sidebar.style.top = `${top}px`;
            };

            const endDrag = () => {
                if (!dragging) return;
                dragging = false;
                sidebar.classList.remove('dragging');
                clampPosition();
            };

            dragHandle.addEventListener('pointerdown', startDrag);
            window.addEventListener('pointermove', onDrag);
            window.addEventListener('pointerup', endDrag);
            window.addEventListener('pointercancel', endDrag);

            window.addEventListener('resize', clampPosition);
            updateToggleState();
        }

        // Scene Management
        function enterScene(index) {
            currentChapter = index;
            document.getElementById('scene-container').classList.add('active');
            const info = getChapterInfo(index);
            document.getElementById('scene-name').textContent = `${CHAPTERS[index].icon} ${info.title}`;
            init3DScene(index);
            loadGame(index);
            
            // Mark chapter as visited after 5 seconds (ensures user actually viewed it)
            setTimeout(() => {
                if (document.getElementById('scene-container').classList.contains('active') && currentChapter === index) {
                    markChapterVisited(index);
                }
            }, 5000);
        }

        function exitScene() {
            document.getElementById('scene-container').classList.remove('active');
            if (renderer) {
                renderer.dispose();
            }
        }

        function nextChapter() {
            let next = (currentChapter + 1) % CHAPTERS.length;
            const nextId = CHAPTERS[next].id;
            if (!isChapterUnlocked(nextId)) {
                showToast(currentLanguage === 'en' ? 'Next chapter locked.' : 'N√§chstes Kapitel gesperrt.');
                return;
            }
            currentChapter = next;
            enterScene(currentChapter);
        }

        function prevChapter() {
            let prev = (currentChapter - 1 + CHAPTERS.length) % CHAPTERS.length;
            const prevId = CHAPTERS[prev].id;
            if (!isChapterUnlocked(prevId)) {
                showToast(currentLanguage === 'en' ? 'Previous chapter locked.' : 'Vorheriges Kapitel gesperrt.');
                return;
            }
            currentChapter = prev;
            enterScene(currentChapter);
        }

        function applyCameraPosition() {
            if (!camera || !controls) return;
            const preset = CAMERA_PRESETS[currentView] || CAMERA_PRESETS.main;
            camera.position.set(
                preset.position[0],
                preset.position[1] + cameraYOffset,
                preset.position[2]
            );
            controls.target.set(
                preset.target[0],
                preset.target[1] + cameraYOffset,
                preset.target[2]
            );
            controls.update();
        }

        function setView(view, btn) {
            currentView = view;
            cameraYOffset = 0;
            const buttons = document.querySelectorAll('.view-btn[data-view]');
            buttons.forEach(b => b.classList.toggle('active', btn ? b === btn : b.dataset.view === view));
            applyCameraPosition();
        }

        function adjustCameraHeight(direction) {
            if (!camera) return;
            const delta = direction === 'up' ? 0.6 : -0.6;
            cameraYOffset = Math.max(-6, Math.min(6, cameraYOffset + delta));
            applyCameraPosition();
        }

        function resetCameraHeight() {
            cameraYOffset = 0;
            applyCameraPosition();
        }

        // 3D Scene Initialization
        function init3DScene(chapterIndex) {
            const canvas = document.getElementById('canvas-3d');
            
            // Clean up previous scene
            if (renderer) {
                renderer.dispose();
                if (scene) {
                    while(scene.children.length > 0) {
                        scene.remove(scene.children[0]);
                    }
                }
            }

            // Setup
            cameraYOffset = 0;
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 2, 16);

            renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);

            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.autoRotate = true;
            controls.autoRotateSpeed = 0.5;
            applyCameraPosition();

            // Add lights
            const ambientLight = new THREE.AmbientLight(0x404040, 2);
            scene.add(ambientLight);
            
            const pointLight = new THREE.PointLight(0x00f3ff, 2, 100);
            pointLight.position.set(0, 5, 5);
            scene.add(pointLight);

            // Create starfield
            createStarfield();

            // Load chapter-specific visualization
            switch(chapterIndex) {
                case 0: createMatrixScene(); break;
                case 1: createCSEScene(); break;
                case 2: createPyramidScene(); break;
                case 3: createGridScene(); break;
                case 4: createTuningForkScene(); break;
                case 5: createTummoScene(); break;
                case 6: createShieldScene(); break;
                case 7: createAnchorsScene(); break;
                case 8: createTrinityScene(); break;
                case 9: createBeamScene(); break;
                case 10: createMerkabaScene(); break;
                case 11: createWaterScene(); break;
                case 12: createCollapseScene(); break;
                case 13: createDNAScene(); break;
                case 14: createKeyScene(); break;
                default: createGenericScene();
            }

            // Animation loop
            function animate() {
                requestAnimationFrame(animate);
                controls.update();
                renderer.render(scene, camera);
            }
            animate();

            // Handle resize
            window.addEventListener('resize', onWindowResize, false);
        }

        function onWindowResize() {
            if (!camera || !renderer) return;
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function createStarfield() {
            const geometry = new THREE.BufferGeometry();
            const positions = [];
            for (let i = 0; i < 3000; i++) {
                positions.push(
                    (Math.random() - 0.5) * 100,
                    (Math.random() - 0.5) * 100,
                    (Math.random() - 0.5) * 100
                );
            }
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            const material = new THREE.PointsMaterial({ color: 0xffffff, size: 0.05, transparent: true, opacity: 0.4 });
            const stars = new THREE.Points(geometry, material);
            scene.add(stars);
        }

        // Chapter 1: Matrix - Enhanced with all animations from original
        function createMatrixScene() {
            const group = new THREE.Group();
            
            // Kausal Grid (Structured, Frozen)
            const gridGeometry = new THREE.PlaneGeometry(20, 20, 40, 40);
            const gridMaterial = new THREE.MeshBasicMaterial({ 
                color: 0x00f0ff, 
                wireframe: true, 
                transparent: true, 
                opacity: 0.25 
            });
            const grid = new THREE.Mesh(gridGeometry, gridMaterial);
            grid.rotation.x = -Math.PI / 2;
            grid.position.y = -1;
            group.add(grid);

            // 60Hz Pulse Lines (Vertical Prison Bars)
            const lineGroup = new THREE.Group();
            for(let i = 0; i < 12; i++) {
                const angle = (i/12) * Math.PI * 2;
                const r = 8;
                const lineGeo = new THREE.BufferGeometry();
                lineGeo.setAttribute('position', new THREE.BufferAttribute(
                    new Float32Array([
                        Math.cos(angle)*r, -5, Math.sin(angle)*r,
                        Math.cos(angle)*r, 5, Math.sin(angle)*r
                    ]), 3
                ));
                const line = new THREE.Line(lineGeo, new THREE.LineBasicMaterial({
                    color: 0x00f0ff, transparent: true, opacity: 0.15
                }));
                lineGroup.add(line);
            }
            group.add(lineGroup);

            // Akausal Particles (Free, Chaotic, Golden)
            const particleCount = 2000;
            const particleGeometry = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3);
            const velocities = [];
            for (let i = 0; i < particleCount; i++) {
                positions[i * 3] = (Math.random() - 0.5) * 15;
                positions[i * 3 + 1] = (Math.random() - 0.5) * 10;
                positions[i * 3 + 2] = (Math.random() - 0.5) * 15;
                velocities.push(new THREE.Vector3(
                    (Math.random() - 0.5) * 0.02,
                    (Math.random() - 0.5) * 0.02,
                    (Math.random() - 0.5) * 0.02
                ));
            }
            particleGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            const particleMaterial = new THREE.PointsMaterial({ 
                color: 0xffaa00, 
                size: 0.06, 
                transparent: true, 
                opacity: 0.7 
            });
            const particles = new THREE.Points(particleGeometry, particleMaterial);
            group.add(particles);

            // Central Conflict Sphere (Ahriman Core)
            const coreGeometry = new THREE.IcosahedronGeometry(1.5, 2);
            const coreMaterial = new THREE.MeshBasicMaterial({ 
                color: 0xff0000, 
                wireframe: true, 
                transparent: true, 
                opacity: 0.3 
            });
            const core = new THREE.Mesh(coreGeometry, coreMaterial);
            group.add(core);

            scene.add(group);

            // Enhanced Animation Loop
            let time = 0;
            function animateMatrix() {
                time += 0.01;
                
                // Grid Wave (60Hz Oscillation)
                const gridPos = gridGeometry.attributes.position;
                for (let i = 0; i < gridPos.count; i++) {
                    const x = gridPos.getX(i);
                    const y = gridPos.getY(i);
                    gridPos.setZ(i, Math.sin(x * 0.5 + time * 60) * 0.3 + Math.sin(y * 0.5 + time * 60) * 0.3);
                }
                gridPos.needsUpdate = true;
                
                // Pulse bars
                lineGroup.children.forEach((line, i) => {
                    line.material.opacity = 0.15 + Math.sin(time * 60 + i * 0.5) * 0.1;
                });
                
                // Free particle movement (Brownian-like)
                for (let i = 0; i < particleCount; i++) {
                    positions[i * 3] += velocities[i].x;
                    positions[i * 3 + 1] += velocities[i].y;
                    positions[i * 3 + 2] += velocities[i].z;
                    
                    // Bounce back if too far
                    if (Math.abs(positions[i * 3]) > 15) velocities[i].x *= -1;
                    if (Math.abs(positions[i * 3 + 1]) > 10) velocities[i].y *= -1;
                    if (Math.abs(positions[i * 3 + 2]) > 15) velocities[i].z *= -1;
                }
                particleGeometry.attributes.position.needsUpdate = true;

                // Core rotation
                core.rotation.x = time * 0.3;
                core.rotation.y = time * 0.5;

                // Group rotation
                group.rotation.y = time * 0.05;

                requestAnimationFrame(animateMatrix);
            }
            animateMatrix();
        }

        // Chapter 2: CSE - Enhanced with standing wave interference
        function createCSEScene() {
            const group = new THREE.Group();
            
            // Hexagonal tube with enhanced material
            const tubeGeometry = new THREE.CylinderGeometry(1, 1, 5, 6, 1, true);
            const tubeMaterial = new THREE.MeshBasicMaterial({ 
                color: 0xffaa00, 
                wireframe: true, 
                transparent: true, 
                opacity: 0.4 
            });
            const tube = new THREE.Mesh(tubeGeometry, tubeMaterial);
            tube.rotation.x = Math.PI / 2;
            group.add(tube);

            // Standing wave particles with base positions
            const particleCount = 800;
            const particleGeometry = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3);
            const bases = new Float32Array(particleCount * 3);
            for (let i = 0; i < particleCount; i++) {
                bases[i * 3] = (Math.random() - 0.5);
                bases[i * 3 + 1] = (Math.random() - 0.5);
                bases[i * 3 + 2] = (Math.random() - 0.5) * 5;
            }
            particleGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            const particleMaterial = new THREE.PointsMaterial({ color: 0xffffff, size: 0.05 });
            const particles = new THREE.Points(particleGeometry, particleMaterial);
            group.add(particles);

            scene.add(group);

            // Enhanced Animation with interference patterns
            let time = 0;
            function animateCSE() {
                time += 0.05;
                
                // Standing wave interference pattern
                for (let i = 0; i < particleCount; i++) {
                    const z = bases[i * 3 + 2];
                    const amplitude = Math.sin(z * 4) * Math.cos(time * 5);
                    positions[i * 3] = bases[i * 3] * (1 + amplitude);
                    positions[i * 3 + 1] = bases[i * 3 + 1] * (1 + amplitude);
                    positions[i * 3 + 2] = z;
                }
                particleGeometry.attributes.position.needsUpdate = true;

                group.rotation.y = time * 0.1;

                requestAnimationFrame(animateCSE);
            }
            animateCSE();
        }

        // Chapter 3: Pyramid - Enhanced with resonance chambers and harp strings
        function createPyramidScene() {
            const group = new THREE.Group();
            
            // Main Pyramid Structure
            const pyramidGeometry = new THREE.ConeGeometry(4, 5, 4);
            const pyramidMaterial = new THREE.MeshBasicMaterial({ 
                color: 0xffaa00, 
                wireframe: true, 
                transparent: true, 
                opacity: 0.4 
            });
            const pyramid = new THREE.Mesh(pyramidGeometry, pyramidMaterial);
            pyramid.position.y = 2.5;
            group.add(pyramid);

            // King's Chamber (16.2 Hz)
            const kingGeometry = new THREE.BoxGeometry(0.8, 0.5, 0.8);
            const kingMaterial = new THREE.MeshBasicMaterial({ 
                color: 0xff3300, 
                transparent: true, 
                opacity: 0.6 
            });
            const kingChamber = new THREE.Mesh(kingGeometry, kingMaterial);
            kingChamber.position.y = 3.5;
            group.add(kingChamber);

            // Queen's Chamber (8.1 Hz)
            const queenGeometry = new THREE.BoxGeometry(0.7, 0.4, 0.7);
            const queenMaterial = new THREE.MeshBasicMaterial({ 
                color: 0x8800ff, 
                transparent: true, 
                opacity: 0.6 
            });
            const queenChamber = new THREE.Mesh(queenGeometry, queenMaterial);
            queenChamber.position.y = 2.0;
            group.add(queenChamber);

            // Harp of David (Resonance Strings)
            const harpGroup = new THREE.Group();
            const stringCount = 7;
            const strings = [];
            for (let i = 0; i < stringCount; i++) {
                const stringGeo = new THREE.CylinderGeometry(0.02, 0.02, 5);
                const stringMat = new THREE.MeshBasicMaterial({ 
                    color: 0xffffff,
                    transparent: true,
                    opacity: 0.7
                });
                const string = new THREE.Mesh(stringGeo, stringMat);
                string.position.set((i - stringCount / 2) * 0.3, 2.5, 0);
                string.userData.frequency = 8.1 * (i + 1);
                strings.push(string);
                harpGroup.add(string);
            }
            group.add(harpGroup);

            // Apex Energy Beam
            const beamGeo = new THREE.CylinderGeometry(0.05, 0.4, 10, 8, 1, true);
            const beamMat = new THREE.MeshBasicMaterial({
                color: 0xffffff, 
                transparent: true, 
                opacity: 0.25,
                blending: THREE.AdditiveBlending,
                side: THREE.DoubleSide
            });
            const beam = new THREE.Mesh(beamGeo, beamMat);
            beam.position.y = 10;
            group.add(beam);

            // Resonance Wave Rings
            const rings = [];
            for (let i = 0; i < 5; i++) {
                const ring = new THREE.Mesh(
                    new THREE.TorusGeometry(1 + i * 0.5, 0.05, 8, 32),
                    new THREE.MeshBasicMaterial({ 
                        color: 0x00ffff, 
                        transparent: true, 
                        opacity: 0.4 - i * 0.05 
                    })
                );
                ring.position.y = 5 + i * 0.3;
                ring.userData.offset = i * 0.2;
                rings.push(ring);
                group.add(ring);
            }

            scene.add(group);

            // Enhanced Animation with harmonic resonance
            let time = 0;
            function animatePyramid() {
                time += 0.01;
                
                group.rotation.y = time * 0.1;
                
                // String Vibration (Harmonic Oscillators)
                strings.forEach((string, i) => {
                    const freq = string.userData.frequency;
                    const amplitude = Math.sin(time * freq * 0.1 + i) * 0.15;
                    string.scale.x = 1 + amplitude * 3;
                    string.material.opacity = 0.5 + Math.abs(amplitude) * 0.5;
                });
                
                // Chamber Pulse
                const kingPulse = 1 + Math.sin(time * 16.2 * 0.1) * 0.1;
                kingChamber.scale.setScalar(kingPulse);
                kingChamber.material.opacity = 0.4 + Math.abs(Math.sin(time * 16.2 * 0.1)) * 0.3;
                
                const queenPulse = 1 + Math.sin(time * 8.1 * 0.1) * 0.1;
                queenChamber.scale.setScalar(queenPulse);
                queenChamber.material.opacity = 0.4 + Math.abs(Math.sin(time * 8.1 * 0.1)) * 0.3;
                
                // Beam fluctuation
                beam.scale.set(1 + Math.sin(time * 3) * 0.2, 1, 1 + Math.sin(time * 3) * 0.2);
                beam.material.opacity = 0.2 + Math.sin(time * 2) * 0.1;
                
                // Rings propagation
                rings.forEach((ring, i) => {
                    const wave = (time * 2 + ring.userData.offset) % 3;
                    ring.position.y = 5 + wave * 2;
                    ring.scale.setScalar(1 + wave * 0.3);
                    ring.material.opacity = (1 - wave / 3) * 0.4;
                });

                requestAnimationFrame(animatePyramid);
            }
            animatePyramid();
        }

        // Chapter 15: Key (3-6-9 System) - Enhanced with all layers
        function createKeyScene() {
            const group = new THREE.Group();
            group.position.y = -2;

            // Avatar Body (Wire + Glass)
            const torsoGeometry = new THREE.CylinderGeometry(0.3, 0.2, 1.8, 8);
            const glassMat = new THREE.MeshPhysicalMaterial({
                color: 0x00f0ff, 
                emissive: 0x001133, 
                transmission: 0.5, 
                opacity: 0.4, 
                transparent: true
            });
            const torso = new THREE.Mesh(torsoGeometry, glassMat);
            torso.position.y = 2.8;
            
            const wireMat = new THREE.MeshBasicMaterial({
                color: 0x00f0ff, 
                wireframe: true, 
                opacity: 0.15, 
                transparent: true
            });
            const wireFrame = new THREE.Mesh(torsoGeometry, wireMat);
            torso.add(wireFrame);
            group.add(torso);

            // Head
            const headGeometry = new THREE.SphereGeometry(0.25, 16, 16);
            const headMaterial = new THREE.MeshBasicMaterial({ 
                color: 0xffffff, 
                transparent: true, 
                opacity: 0.6 
            });
            const head = new THREE.Mesh(headGeometry, headMaterial);
            head.position.y = 4.0;
            group.add(head);

            // 9: Pleroma (Indigo sphere with particle cloud)
            const nineGeometry = new THREE.SphereGeometry(0.35, 32, 32);
            const nineMaterial = new THREE.MeshBasicMaterial({ 
                color: 0x8888ff, 
                transparent: true, 
                opacity: 0.8 
            });
            const nine = new THREE.Mesh(nineGeometry, nineMaterial);
            nine.position.y = 4.8;
            group.add(nine);

            // Pleroma Particle Cloud
            const pGeo9 = new THREE.BufferGeometry();
            const pPos9 = [];
            for (let i = 0; i < 3000; i++) {
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                const r = 0.5 + Math.random() * 2.5;
                pPos9.push(
                    r * Math.sin(phi) * Math.cos(theta),
                    r * Math.sin(phi) * Math.sin(theta) + 4.8,
                    r * Math.cos(phi)
                );
            }
            pGeo9.setAttribute('position', new THREE.Float32BufferAttribute(pPos9, 3));
            const particles9 = new THREE.Points(pGeo9, new THREE.PointsMaterial({
                size: 0.04, 
                color: 0x8888ff, 
                transparent: true, 
                opacity: 0.4, 
                blending: THREE.AdditiveBlending
            }));
            group.add(particles9);

            // 6: Torsion field (Orange torus with particle ring)
            const sixGeometry = new THREE.TorusGeometry(2.0, 0.08, 16, 64);
            const sixMaterial = new THREE.MeshBasicMaterial({ 
                color: 0xff6600, 
                transparent: true, 
                opacity: 0.7 
            });
            const six = new THREE.Mesh(sixGeometry, sixMaterial);
            six.rotation.x = Math.PI / 2;
            six.position.y = 3.0;
            group.add(six);

            // Torus Particle Ring
            const pGeo6 = new THREE.BufferGeometry();
            const pPos6 = [];
            for (let i = 0; i < 1000; i++) {
                const angle = (i / 1000) * Math.PI * 2;
                const r = 2.0 + (Math.random() - 0.5) * 0.3;
                pPos6.push(Math.cos(angle) * r, 3.0, Math.sin(angle) * r);
            }
            pGeo6.setAttribute('position', new THREE.Float32BufferAttribute(pPos6, 3));
            const particles6 = new THREE.Points(pGeo6, new THREE.PointsMaterial({
                size: 0.06, 
                color: 0xff6600, 
                transparent: true, 
                opacity: 0.5
            }));
            group.add(particles6);

            // 3: Gnosis core (Gold octahedron with glow)
            const threeGeometry = new THREE.OctahedronGeometry(0.5);
            const threeMaterial = new THREE.MeshBasicMaterial({ 
                color: 0xffd700, 
                wireframe: true, 
                transparent: true, 
                opacity: 0.9 
            });
            const three = new THREE.Mesh(threeGeometry, threeMaterial);
            three.position.y = 2.8;
            group.add(three);

            const threeGlow = new THREE.Mesh(
                new THREE.OctahedronGeometry(0.55),
                new THREE.MeshBasicMaterial({
                    color: 0xffaa00, 
                    transparent: true, 
                    opacity: 0.25, 
                    blending: THREE.AdditiveBlending
                })
            );
            threeGlow.position.y = 2.8;
            group.add(threeGlow);

            // 8: Matrix Base (Dark Grid)
            const eightG = new THREE.Group();
            eightG.position.y = -0.5;
            const matrixDome = new THREE.LineSegments(
                new THREE.WireframeGeometry(new THREE.IcosahedronGeometry(5, 2)),
                new THREE.LineBasicMaterial({
                    color: 0x333333, 
                    transparent: true, 
                    opacity: 0.15
                })
            );
            matrixDome.rotation.x = Math.PI / 2;
            matrixDome.scale.set(1, 0.15, 1);
            eightG.add(matrixDome);
            group.add(eightG);

            scene.add(group);

            // Enhanced Animation
            let time = 0;
            function animateKey() {
                time += 0.01;
                
                // Breathing animation
                const breathe = 1 + Math.sin(time * 1.5) * 0.03;
                torso.scale.set(breathe, 1, breathe);

                // 9: Pleroma rotation
                nine.rotation.y = time * 0.3;
                nine.rotation.x = Math.sin(time * 0.5) * 0.2;
                particles9.rotation.y = -time * 0.15;

                // 6: Torus spin
                six.rotation.z = time * 0.4;
                particles6.rotation.y = time * 0.5;

                // 3: Crystal rotation
                three.rotation.y = time * 0.6;
                three.rotation.x = Math.sin(time * 0.8) * 0.3;
                threeGlow.rotation.y = -time * 0.5;
                threeGlow.rotation.x = Math.cos(time * 0.7) * 0.3;

                // 8: Matrix dome
                eightG.rotation.y = time * 0.08;
                matrixDome.material.opacity = 0.1 + Math.sin(time * 2) * 0.05;

                // Main group rotation
                group.rotation.y = time * 0.12;

                requestAnimationFrame(animateKey);
            }
            animateKey();
        }

        // Generic scene for other chapters
        function createGenericScene() {
            const group = new THREE.Group();
            
            for (let i = 0; i < 9; i++) {
                const geometry = new THREE.SphereGeometry(0.1, 16, 16);
                const color = i % 3 === 0 ? 0xffaa00 : (i % 3 === 1 ? 0xff6600 : 0x8888ff);
                const material = new THREE.MeshBasicMaterial({ color });
                const sphere = new THREE.Mesh(geometry, material);
                
                const angle = (i / 9) * Math.PI * 2;
                const radius = 3;
                sphere.position.set(
                    Math.cos(angle) * radius,
                    Math.sin(angle * 2) * 1,
                    Math.sin(angle) * radius
                );
                
                group.add(sphere);
            }
            
            scene.add(group);

            let time = 0;
            function animateGeneric() {
                time += 0.01;
                group.rotation.y = time * 0.2;
                requestAnimationFrame(animateGeneric);
            }
            animateGeneric();
        }

        // Implement remaining scenes - All ported from original v1 website
        
        // Chapter 4: Goldenes Gitter (Planetary Grid with Ley Lines)
        function createGridScene() {
            const grp = new THREE.Group();
            // Earth Icosahedron (Platonic Solid)
            const earth = new THREE.Mesh(
                new THREE.IcosahedronGeometry(3, 2),
                new THREE.MeshBasicMaterial({color:0x0088ff, wireframe:false, transparent:true, opacity:0.1})
            );
            grp.add(earth);
            
            // Wireframe Overlay (Ley Lines)
            const wireframe = new THREE.Mesh(
                new THREE.IcosahedronGeometry(3.05, 2),
                new THREE.MeshBasicMaterial({color:0xffaa00, wireframe:true})
            );
            grp.add(wireframe);
            
            // PHI-Nodes (12 Vertices of Icosahedron)
            const vertices = new THREE.IcosahedronGeometry(3, 0).attributes.position;
            const nodes = [];
            const nodePositions = [];
            for(let i=0; i<vertices.count; i++) {
                const x = vertices.getX(i);
                const y = vertices.getY(i);
                const z = vertices.getZ(i);
                const exists = nodePositions.some(p => Math.abs(p.x-x)<0.01 && Math.abs(p.y-y)<0.01 && Math.abs(p.z-z)<0.01);
                if(!exists && nodes.length < 12) {
                    nodePositions.push({x,y,z});
                    const node = new THREE.Mesh(
                        new THREE.SphereGeometry(0.15, 8, 8),
                        new THREE.MeshBasicMaterial({color:0xffd700})
                    );
                    node.position.set(x, y, z);
                    nodes.push(node);
                    grp.add(node);
                }
            }
            
            // Energy Pulses along Ley Lines
            const pulseGeo = new THREE.BufferGeometry();
            const pulsePos = new Float32Array(100*3);
            pulseGeo.setAttribute('position', new THREE.BufferAttribute(pulsePos,3));
            const pulses = new THREE.Points(pulseGeo, new THREE.PointsMaterial({color:0x00ff00, size:0.1}));
            grp.add(pulses);
            
            scene.add(grp);
            
            let time = 0;
            function animateGrid() {
                time += 0.016;
                grp.rotation.y = time*0.1;
                nodes.forEach((n, i) => {
                    n.scale.setScalar(1 + Math.sin(time*2+i)*0.2);
                });
                // Pulse animation
                for(let i=0; i<100; i++) {
                    const progress = (time*0.5 + i/100) % 1;
                    const angle = progress*Math.PI*2;
                    const r = 3;
                    pulsePos[i*3] = Math.cos(angle)*r;
                    pulsePos[i*3+1] = Math.sin(angle)*r*Math.sin(time+i*0.1);
                    pulsePos[i*3+2] = Math.sin(angle)*r;
                }
                pulseGeo.attributes.position.needsUpdate = true;
                requestAnimationFrame(animateGrid);
            }
            animateGrid();
        }
        
        // Chapter 5: Die Stimmgabel (Tuning Fork with Heart Coherence)
        function createTuningForkScene() {
            const grp = new THREE.Group();
            // Two Prongs (Cherubim in Contact)
            const prong1 = new THREE.Mesh(new THREE.CylinderGeometry(0.1,0.1,4), new THREE.MeshBasicMaterial({color:0xff6600}));
            prong1.position.set(-0.6, 2, 0); grp.add(prong1);
            const prong2 = prong1.clone(); prong2.position.set(0.6, 2, 0); grp.add(prong2);
            const base = new THREE.Mesh(new THREE.CylinderGeometry(0.15,0.15,0.5), new THREE.MeshBasicMaterial({color:0xffaa00}));
            base.position.y = 0.25; grp.add(base);
            
            // Torus Field (3 Fu√ü = ~0.91m radius)
            const torus = new THREE.Mesh(new THREE.TorusGeometry(3, 0.05, 16, 100), new THREE.MeshBasicMaterial({color:0x00ff88, transparent:true, opacity:0.3}));
            torus.rotation.x = Math.PI/2; grp.add(torus);
            
            // Heart Coherence Waves
            const waveGeo = new THREE.BufferGeometry();
            const wPos = new Float32Array(200*3);
            for(let i=0; i<200; i++) {
                const angle = (i/200)*Math.PI*2;
                wPos[i*3] = Math.cos(angle)*3; wPos[i*3+1] = 0; wPos[i*3+2] = Math.sin(angle)*3;
            }
            waveGeo.setAttribute('position', new THREE.BufferAttribute(wPos,3));
            const waves = new THREE.Points(waveGeo, new THREE.PointsMaterial({color:0xff6600, size:0.1}));
            grp.add(waves);
            
            scene.add(grp);
            
            let time = 0;
            function animateFork() {
                time += 0.016;
                // 0.1 Hz Heart Coherence Frequency
                prong1.position.x = -0.6 + Math.sin(time*0.1*Math.PI*2)*0.05;
                prong2.position.x = 0.6 - Math.sin(time*0.1*Math.PI*2)*0.05;
                torus.scale.set(1+Math.sin(time*0.1*Math.PI*2)*0.1, 1+Math.sin(time*0.1*Math.PI*2)*0.1, 1);
                waves.rotation.y = time*0.1;
                grp.rotation.y = time*0.05;
                requestAnimationFrame(animateFork);
            }
            animateFork();
        }
        
        // Chapter 6: Tummo-Flamme (Kundalini Fire Breath)
        function createTummoScene() {
            const grp = new THREE.Group();
            // Central Channel (Sushumna)
            const channel = new THREE.Mesh(new THREE.CylinderGeometry(0.1,0.1,8), new THREE.MeshBasicMaterial({color:0xffffff, transparent:true, opacity:0.2}));
            grp.add(channel);
            
            // Spiral Fire Particles (Kundalini Rising)
            const pGeo = new THREE.BufferGeometry();
            const pCount = 1000;
            const pPos = new Float32Array(pCount*3);
            const pColors = new Float32Array(pCount*3);
            const bases = [];
            for(let i=0; i<pCount; i++) {
                const t = i/pCount;
                const angle = t*Math.PI*8; // 4 spirals
                const radius = 0.5 + t*0.5;
                const y = t*8 - 4;
                bases.push({angle, radius, y, offset: Math.random()*Math.PI*2});
                // Gradient: Red -> Orange -> Yellow -> White
                const heat = t;
                pColors[i*3] = 1; pColors[i*3+1] = heat*0.6; pColors[i*3+2] = heat*heat*0.3;
            }
            pGeo.setAttribute('position', new THREE.BufferAttribute(pPos,3));
            pGeo.setAttribute('color', new THREE.BufferAttribute(pColors,3));
            const fire = new THREE.Points(pGeo, new THREE.PointsMaterial({size:0.08, vertexColors:true, transparent:true, opacity:0.8}));
            grp.add(fire);
            
            // Base Flame
            const baseFlame = new THREE.Mesh(new THREE.ConeGeometry(0.5,1,8), new THREE.MeshBasicMaterial({color:0xff0000, transparent:true, opacity:0.5}));
            baseFlame.position.y = -4; grp.add(baseFlame);
            
            scene.add(grp);
            
            let time = 0;
            function animateTummo() {
                time += 0.016;
                for(let i=0; i<pCount; i++) {
                    const b = bases[i];
                    const spiral = b.angle + time*2 + b.offset;
                    pPos[i*3] = Math.cos(spiral)*b.radius;
                    pPos[i*3+1] = b.y + Math.sin(time*3+b.offset)*0.2;
                    pPos[i*3+2] = Math.sin(spiral)*b.radius;
                }
                pGeo.attributes.position.needsUpdate = true;
                baseFlame.scale.set(1+Math.sin(time*5)*0.2, 1+Math.sin(time*5)*0.3, 1+Math.sin(time*5)*0.2);
                grp.rotation.y = time*0.1;
                requestAnimationFrame(animateTummo);
            }
            animateTummo();
        }
        
        // Chapter 7: Gnostische Feldarbeit (Frequency Shield with Interference Pattern)
        function createShieldScene() {
            const grp = new THREE.Group();
            // Central Sphere (Bio-Field)
            const core = new THREE.Mesh(new THREE.SphereGeometry(1,32,32), new THREE.MeshBasicMaterial({color:0x00d2ff, wireframe:true, transparent:true, opacity:0.3}));
            grp.add(core);
            
            // Multi-Layer Shields (Harmonic Frequencies)
            const shields = [];
            const freqs = [1, 1.618, 2.618, 4.236]; // Fibonacci ratios
            freqs.forEach((f, idx) => {
                const shield = new THREE.Mesh(
                    new THREE.IcosahedronGeometry(2+idx*0.8, 1),
                    new THREE.MeshBasicMaterial({color:0x00d2ff, wireframe:true, transparent:true, opacity:0.15})
                );
                shield.userData.freq = f;
                shields.push(shield);
                grp.add(shield);
            });
            
            // Interference Particles
            const pGeo = new THREE.BufferGeometry();
            const pCount = 500;
            const pPos = new Float32Array(pCount*3);
            for(let i=0; i<pCount; i++) {
                const theta = Math.random()*Math.PI*2;
                const phi = Math.acos(2*Math.random()-1);
                const r = 3 + Math.random()*2;
                pPos[i*3] = r*Math.sin(phi)*Math.cos(theta);
                pPos[i*3+1] = r*Math.sin(phi)*Math.sin(theta);
                pPos[i*3+2] = r*Math.cos(phi);
            }
            pGeo.setAttribute('position', new THREE.BufferAttribute(pPos,3));
            const particles = new THREE.Points(pGeo, new THREE.PointsMaterial({color:0xffffff, size:0.05}));
            grp.add(particles);
            
            scene.add(grp);
            
            let time = 0;
            function animateShield() {
                time += 0.016;
                shields.forEach((s, i) => {
                    s.rotation.y = time*s.userData.freq*0.2;
                    s.rotation.x = time*s.userData.freq*0.1;
                    s.scale.setScalar(1 + Math.sin(time*s.userData.freq*2)*0.05);
                });
                particles.rotation.y = -time*0.3;
                core.rotation.y = time*0.5;
                requestAnimationFrame(animateShield);
            }
            animateShield();
        }
        
        // Chapter 8: Bau des Gitters (Three Sacred Anchors)
        function createAnchorsScene() {
            const grp = new THREE.Group();
            // 1. Kailash (Tibet) - Pyramid
            const kailash = new THREE.Mesh(
                new THREE.ConeGeometry(1, 2, 4),
                new THREE.MeshBasicMaterial({color:0xffffff, wireframe:true})
            );
            kailash.position.set(-3, 0, 0);
            grp.add(kailash);
            
            // 2. Gizeh (Egypt) - Pyramid
            const gizeh = new THREE.Mesh(
                new THREE.ConeGeometry(1.2, 2.2, 4),
                new THREE.MeshBasicMaterial({color:0xffaa00, wireframe:true})
            );
            gizeh.position.set(0, 0, 0);
            grp.add(gizeh);
            
            // 3. Scotland (Stone Circles) - Ring
            const scotland = new THREE.Mesh(
                new THREE.TorusGeometry(1, 0.1, 8, 16),
                new THREE.MeshBasicMaterial({color:0x00ff88, wireframe:true})
            );
            scotland.position.set(3, 0, 0);
            scotland.rotation.x = Math.PI/2;
            grp.add(scotland);
            
            // Connection Lines (Ley Lines)
            const lineGeo = new THREE.BufferGeometry();
            const linePos = new Float32Array([
                -3,0,0, 0,0,0,  0,0,0, 3,0,0,  3,0,0, -3,0,0
            ]);
            lineGeo.setAttribute('position', new THREE.BufferAttribute(linePos, 3));
            const lines = new THREE.Line(lineGeo, new THREE.LineBasicMaterial({color:0x00f0ff, transparent:true, opacity:0.5}));
            grp.add(lines);
            
            // Energy Flow Particles
            const pGeo = new THREE.BufferGeometry();
            const pPos = new Float32Array(60*3);
            const pBases = [];
            for(let i=0; i<20; i++) { pBases.push({from:0, to:1, progress:i/20}); }
            for(let i=0; i<20; i++) { pBases.push({from:1, to:2, progress:i/20}); }
            for(let i=0; i<20; i++) { pBases.push({from:2, to:0, progress:i/20}); }
            pGeo.setAttribute('position', new THREE.BufferAttribute(pPos,3));
            const flow = new THREE.Points(pGeo, new THREE.PointsMaterial({color:0x00ffff, size:0.1}));
            grp.add(flow);
            
            scene.add(grp);
            const anchors = [[-3,0,0], [0,0,0], [3,0,0]];
            
            let time = 0;
            function animateAnchors() {
                time += 0.016;
                grp.rotation.y = time*0.05;
                kailash.rotation.y = time*0.2;
                gizeh.rotation.y = -time*0.2;
                scotland.rotation.z = time*0.3;
                
                // Flow animation
                pBases.forEach((b, i) => {
                    const p = (b.progress + time*0.1) % 1;
                    const from = anchors[b.from];
                    const to = anchors[b.to];
                    pPos[i*3] = from[0] + (to[0]-from[0])*p;
                    pPos[i*3+1] = from[1] + (to[1]-from[1])*p + Math.sin(p*Math.PI)*0.5;
                    pPos[i*3+2] = from[2] + (to[2]-from[2])*p;
                });
                pGeo.attributes.position.needsUpdate = true;
                requestAnimationFrame(animateAnchors);
            }
            animateAnchors();
        }
        
        // Chapter 9: Die Trinity (Viral Network Spread)
        function createTrinityScene() {
            const grp = new THREE.Group();
            // Central Node (Trinity Core)
            const core = new THREE.Mesh(
                new THREE.OctahedronGeometry(0.5),
                new THREE.MeshBasicMaterial({color:0xff0000, wireframe:false})
            );
            grp.add(core);
            
            // Network Nodes (8th Sphere Grid)
            const nodes = [];
            const connections = [];
            for(let i=0; i<50; i++) {
                const theta = Math.random()*Math.PI*2;
                const phi = Math.acos(2*Math.random()-1);
                const r = 2 + Math.random()*5;
                const node = new THREE.Mesh(
                    new THREE.SphereGeometry(0.1, 6, 6),
                    new THREE.MeshBasicMaterial({color:0x666666})
                );
                node.position.set(
                    r*Math.sin(phi)*Math.cos(theta),
                    r*Math.sin(phi)*Math.sin(theta),
                    r*Math.cos(phi)
                );
                node.userData.infected = false;
                node.userData.infectionTime = 0;
                nodes.push(node);
                grp.add(node);
            }
            
            // Connection Lines
            nodes.forEach((n1, i) => {
                nodes.forEach((n2, j) => {
                    if(i<j && n1.position.distanceTo(n2.position) < 3) {
                        const geo = new THREE.BufferGeometry();
                        geo.setAttribute('position', new THREE.BufferAttribute(
                            new Float32Array([n1.position.x, n1.position.y, n1.position.z, n2.position.x, n2.position.y, n2.position.z]), 3
                        ));
                        const line = new THREE.Line(geo, new THREE.LineBasicMaterial({color:0x333333, transparent:true, opacity:0.2}));
                        connections.push({line, n1, n2});
                        grp.add(line);
                    }
                });
            });
            
            scene.add(grp);
            
            let time = 0;
            function animateTrinity() {
                time += 0.016;
                grp.rotation.y = time*0.1;
                core.rotation.x = time*0.5;
                core.rotation.y = time*0.7;
                
                // Infection Spread (Viral Pattern)
                nodes.forEach(n => {
                    if(!n.userData.infected) {
                        const dist = n.position.distanceTo(core.position);
                        if(time*2 > dist) {
                            n.userData.infected = true;
                            n.userData.infectionTime = time;
                            n.material.color.setHex(0xff0000);
                        }
                    } else {
                        const age = time - n.userData.infectionTime;
                        n.scale.setScalar(1 + Math.sin(age*5)*0.3);
                    }
                });
                
                // Update connection colors
                connections.forEach(c => {
                    if(c.n1.userData.infected && c.n2.userData.infected) {
                        c.line.material.color.setHex(0xff0000);
                        c.line.material.opacity = 0.6;
                    }
                });
                requestAnimationFrame(animateTrinity);
            }
            animateTrinity();
        }
        
        // Chapter 10: Die 1-Hz Z√ºndung (Resonance Beam - Angkor Wat)
        function createBeamScene() {
            const grp = new THREE.Group();
            // Temple Base (CSE Capacitor)
            const base = new THREE.Mesh(
                new THREE.BoxGeometry(3, 0.5, 3),
                new THREE.MeshBasicMaterial({color:0x888888, wireframe:true})
            );
            base.position.y = -2;
            grp.add(base);
            
            // Central Beam (1 Hz Standing Wave)
            const beamGeo = new THREE.CylinderGeometry(0.3, 0.3, 10, 32, 1, true);
            const beamMat = new THREE.MeshBasicMaterial({color:0xffffff, transparent:true, opacity:0.3, side:THREE.DoubleSide});
            const beam = new THREE.Mesh(beamGeo, beamMat);
            beam.position.y = 3;
            grp.add(beam);
            
            // Particle Beam (Vertical Flow)
            const pGeo = new THREE.BufferGeometry();
            const pCount = 1000;
            const pPos = new Float32Array(pCount*3);
            const pBases = [];
            for(let i=0; i<pCount; i++) {
                const angle = Math.random()*Math.PI*2;
                const r = Math.random()*0.3;
                pBases.push({angle, r, y:Math.random()*10-2});
            }
            pGeo.setAttribute('position', new THREE.BufferAttribute(pPos,3));
            const particles = new THREE.Points(pGeo, new THREE.PointsMaterial({color:0xffffff, size:0.05}));
            grp.add(particles);
            
            // Resonance Rings (1 Hz Pulses)
            const rings = [];
            for(let i=0; i<5; i++) {
                const ring = new THREE.Mesh(
                    new THREE.TorusGeometry(0.5, 0.05, 8, 32),
                    new THREE.MeshBasicMaterial({color:0x00ffff, transparent:true, opacity:0.6})
                );
                ring.rotation.x = Math.PI/2;
                ring.userData.offset = i*0.2;
                rings.push(ring);
                grp.add(ring);
            }
            
            scene.add(grp);
            
            let time = 0;
            function animateBeam() {
                time += 0.016;
                // 1 Hz Frequency (1 cycle per second)
                const phase = (time % 1)*Math.PI*2;
                beam.scale.x = beam.scale.z = 1 + Math.sin(phase)*0.2;
                
                // Particle flow
                pBases.forEach((b, i) => {
                    const y = (b.y + time*2) % 12 - 2;
                    pPos[i*3] = Math.cos(b.angle + time)*b.r;
                    pPos[i*3+1] = y;
                    pPos[i*3+2] = Math.sin(b.angle + time)*b.r;
                });
                pGeo.attributes.position.needsUpdate = true;
                
                // Resonance rings
                rings.forEach((r, i) => {
                    const y = ((time*2 + r.userData.offset) % 2)*5 - 2;
                    r.position.y = y;
                    r.scale.setScalar((y+2)/5 + 0.5);
                    r.material.opacity = 1 - (y+2)/5;
                });
                
                grp.rotation.y = time*0.05;
                requestAnimationFrame(animateBeam);
            }
            animateBeam();
        }
        
        // Chapter 11: Der 9-er Akt (Merkaba Superposition)
        function createMerkabaScene() {
            const grp = new THREE.Group();
            // Upward Tetrahedron (Male/Electric)
            const tetra1Geo = new THREE.TetrahedronGeometry(2);
            const tetra1 = new THREE.Mesh(tetra1Geo, new THREE.MeshBasicMaterial({color:0x00ffff, wireframe:true, transparent:true, opacity:0.6}));
            grp.add(tetra1);
            
            // Downward Tetrahedron (Female/Magnetic)
            const tetra2 = tetra1.clone();
            tetra2.rotation.y = Math.PI;
            tetra2.material = new THREE.MeshBasicMaterial({color:0xff00ff, wireframe:true, transparent:true, opacity:0.6});
            grp.add(tetra2);
            
            // Central Sphere (Unity Point)
            const core = new THREE.Mesh(
                new THREE.SphereGeometry(0.5, 16, 16),
                new THREE.MeshBasicMaterial({color:0xffffff, wireframe:true})
            );
            grp.add(core);
            
            // Energy Vortex (Counter-Rotating)
            const vortexGeo = new THREE.BufferGeometry();
            const vCount = 500;
            const vPos = new Float32Array(vCount*3);
            const vBases = [];
            for(let i=0; i<vCount; i++) {
                const t = i/vCount;
                vBases.push({t, dir: i<vCount/2 ? 1 : -1});
            }
            vortexGeo.setAttribute('position', new THREE.BufferAttribute(vPos,3));
            const vortex = new THREE.Points(vortexGeo, new THREE.PointsMaterial({color:0xffaa00, size:0.06}));
            grp.add(vortex);
            
            // 9 Sacred Points (Nonagon)
            const sacred9 = [];
            for(let i=0; i<9; i++) {
                const angle = (i/9)*Math.PI*2;
                const node = new THREE.Mesh(
                    new THREE.SphereGeometry(0.1, 8, 8),
                    new THREE.MeshBasicMaterial({color:0xffd700})
                );
                node.position.set(Math.cos(angle)*3, 0, Math.sin(angle)*3);
                node.userData.angle = angle;
                sacred9.push(node);
                grp.add(node);
            }
            
            scene.add(grp);
            
            let time = 0;
            function animateMerkaba() {
                time += 0.016;
                // Counter-rotation (Merkaba activation)
                tetra1.rotation.y = time*0.3;
                tetra2.rotation.y = -time*0.3;
                core.rotation.x = time*0.5;
                core.rotation.z = time*0.4;
                
                // Vortex animation
                vBases.forEach((b, i) => {
                    const spiral = time*2*b.dir + b.t*Math.PI*4;
                    const r = b.t*3;
                    const y = (b.t*4 - 2);
                    vPos[i*3] = Math.cos(spiral)*r;
                    vPos[i*3+1] = y;
                    vPos[i*3+2] = Math.sin(spiral)*r;
                });
                vortexGeo.attributes.position.needsUpdate = true;
                
                // 9 Points Pulse
                sacred9.forEach((n, i) => {
                    n.scale.setScalar(1 + Math.sin(time*2 + i*Math.PI*2/9)*0.3);
                    n.position.y = Math.sin(time + n.userData.angle)*0.5;
                });
                requestAnimationFrame(animateMerkaba);
            }
            animateMerkaba();
        }
        
        // Chapter 12: Bio-Gravitation (Water Crystal Lattice - H3O2)
        function createWaterScene() {
            const grp = new THREE.Group();
            const geo = new THREE.SphereGeometry(0.1,8,8);
            const mat = new THREE.MeshBasicMaterial({color:0x00aaff});
            const mesh = new THREE.InstancedMesh(geo, mat, 200);
            const dummy = new THREE.Object3D();
            let i=0;
            for(let x=-5; x<=5; x++) for(let z=-5; z<=5; z++) {
                if(i<200) {
                    dummy.position.set(x*0.8 + (z%2)*0.4, 0, z*0.7);
                    dummy.updateMatrix(); mesh.setMatrixAt(i++, dummy.matrix);
                }
            }
            grp.add(mesh);
            scene.add(grp);
            
            let time = 0;
            function animateWater() {
                time += 0.016;
                grp.rotation.y = time*0.1;
                requestAnimationFrame(animateWater);
            }
            animateWater();
        }
        
        // Chapter 13: Fraktaler Kollaps (Fractal Implosion)
        function createCollapseScene() {
            const grp = new THREE.Group();
            // Central Void
            const void_ = new THREE.Mesh(
                new THREE.SphereGeometry(0.3, 16, 16),
                new THREE.MeshBasicMaterial({color:0x000000})
            );
            grp.add(void_);
            
            // Fractal Cubes (Collapsing Hierarchy)
            const cubes = [];
            const levels = 5;
            for(let level=0; level<levels; level++) {
                const count = Math.pow(2, level);
                for(let i=0; i<count; i++) {
                    const cube = new THREE.Mesh(
                        new THREE.BoxGeometry(0.5, 0.5, 0.5),
                        new THREE.MeshBasicMaterial({color:0x555555, wireframe:true, transparent:true, opacity:0.4})
                    );
                    const angle = (i/count)*Math.PI*2;
                    const r = 2 + level*1.5;
                    cube.position.set(Math.cos(angle)*r, 0, Math.sin(angle)*r);
                    cube.userData = {level, angle, radius:r, index:i};
                    cubes.push(cube);
                    grp.add(cube);
                }
            }
            
            // Entropy Particles (Chaotic Decay)
            const pGeo = new THREE.BufferGeometry();
            const pCount = 1000;
            const pPos = new Float32Array(pCount*3);
            const pVel = [];
            for(let i=0; i<pCount; i++) {
                const theta = Math.random()*Math.PI*2;
                const phi = Math.acos(2*Math.random()-1);
                const r = 8 + Math.random()*5;
                pPos[i*3] = r*Math.sin(phi)*Math.cos(theta);
                pPos[i*3+1] = r*Math.sin(phi)*Math.sin(theta);
                pPos[i*3+2] = r*Math.cos(phi);
                pVel.push({x:-pPos[i*3]*0.01, y:-pPos[i*3+1]*0.01, z:-pPos[i*3+2]*0.01});
            }
            pGeo.setAttribute('position', new THREE.BufferAttribute(pPos,3));
            const entropy = new THREE.Points(pGeo, new THREE.PointsMaterial({color:0xff0000, size:0.03}));
            grp.add(entropy);
            
            scene.add(grp);
            
            let time = 0;
            function animateCollapse() {
                time += 0.016;
                // Collapse animation
                cubes.forEach(c => {
                    const collapseProgress = (time*0.5) % 3; // 3 second cycle
                    const targetR = c.userData.radius * (1 - Math.min(collapseProgress/2, 1));
                    const currentR = Math.max(targetR, 0.5);
                    c.position.x = Math.cos(c.userData.angle + time*0.2)*currentR;
                    c.position.z = Math.sin(c.userData.angle + time*0.2)*currentR;
                    c.rotation.x = time*(c.userData.level+1)*0.3;
                    c.rotation.y = time*(c.userData.level+1)*0.2;
                    c.material.opacity = currentR/c.userData.radius * 0.4;
                });
                
                // Entropy inward spiral
                for(let i=0; i<pCount; i++) {
                    pPos[i*3] += pVel[i].x;
                    pPos[i*3+1] += pVel[i].y;
                    pPos[i*3+2] += pVel[i].z;
                    const dist = Math.sqrt(pPos[i*3]**2 + pPos[i*3+1]**2 + pPos[i*3+2]**2);
                    if(dist < 0.5) {
                        // Reset
                        const theta = Math.random()*Math.PI*2;
                        const phi = Math.acos(2*Math.random()-1);
                        const r = 13;
                        pPos[i*3] = r*Math.sin(phi)*Math.cos(theta);
                        pPos[i*3+1] = r*Math.sin(phi)*Math.sin(theta);
                        pPos[i*3+2] = r*Math.cos(phi);
                        pVel[i] = {x:-pPos[i*3]*0.01, y:-pPos[i*3+1]*0.01, z:-pPos[i*3+2]*0.01};
                    }
                }
                pGeo.attributes.position.needsUpdate = true;
                
                void_.rotation.x = time*0.5;
                void_.rotation.y = time*0.7;
                requestAnimationFrame(animateCollapse);
            }
            animateCollapse();
        }
        
        // Chapter 14: Bio-Lumineszenz (DNA Double Helix - C12 Transformation)
        function createDNAScene() {
            const grp = new THREE.Group();
            // Double Helix Structure
            const helixPoints1 = [];
            const helixPoints2 = [];
            const segments = 50;
            
            for(let i=0; i<segments; i++) {
                const t = i/segments;
                const y = t*10 - 5;
                const angle = t*Math.PI*4; // 2 full turns
                const r = 1;
                
                // Strand 1
                const p1 = new THREE.Mesh(
                    new THREE.SphereGeometry(0.1, 8, 8),
                    new THREE.MeshBasicMaterial({color:0x00ffff})
                );
                p1.position.set(Math.cos(angle)*r, y, Math.sin(angle)*r);
                helixPoints1.push(p1);
                grp.add(p1);
                
                // Strand 2 (opposite)
                const p2 = new THREE.Mesh(
                    new THREE.SphereGeometry(0.1, 8, 8),
                    new THREE.MeshBasicMaterial({color:0xff00ff})
                );
                p2.position.set(Math.cos(angle+Math.PI)*r, y, Math.sin(angle+Math.PI)*r);
                helixPoints2.push(p2);
                grp.add(p2);
                
                // Base Pair Connection
                if(i % 3 === 0) {
                    const lineGeo = new THREE.BufferGeometry();
                    lineGeo.setAttribute('position', new THREE.BufferAttribute(
                        new Float32Array([
                            p1.position.x, p1.position.y, p1.position.z,
                            p2.position.x, p2.position.y, p2.position.z
                        ]), 3
                    ));
                    const line = new THREE.Line(lineGeo, new THREE.LineBasicMaterial({color:0xffffff, transparent:true, opacity:0.3}));
                    grp.add(line);
                }
            }
            
            // Backbone Lines
            const backbone1Geo = new THREE.BufferGeometry();
            const bb1Pos = [];
            helixPoints1.forEach(p => bb1Pos.push(p.position.x, p.position.y, p.position.z));
            backbone1Geo.setAttribute('position', new THREE.Float32BufferAttribute(bb1Pos, 3));
            const backbone1 = new THREE.Line(backbone1Geo, new THREE.LineBasicMaterial({color:0x00ffff, transparent:true, opacity:0.5}));
            grp.add(backbone1);
            
            const backbone2Geo = new THREE.BufferGeometry();
            const bb2Pos = [];
            helixPoints2.forEach(p => bb2Pos.push(p.position.x, p.position.y, p.position.z));
            backbone2Geo.setAttribute('position', new THREE.Float32BufferAttribute(bb2Pos, 3));
            const backbone2 = new THREE.Line(backbone2Geo, new THREE.LineBasicMaterial({color:0xff00ff, transparent:true, opacity:0.5}));
            grp.add(backbone2);
            
            // Light Emission (Bio-Photons)
            const photonGeo = new THREE.BufferGeometry();
            const photonPos = new Float32Array(100*3);
            const photonBases = [];
            for(let i=0; i<100; i++) {
                photonBases.push({y: Math.random()*10-5, offset: Math.random()*Math.PI*2, speed: 0.5+Math.random()*0.5});
            }
            photonGeo.setAttribute('position', new THREE.BufferAttribute(photonPos,3));
            const photons = new THREE.Points(photonGeo, new THREE.PointsMaterial({color:0xffffff, size:0.08, transparent:true, opacity:0.7}));
            grp.add(photons);
            
            scene.add(grp);
            
            let time = 0;
            function animateDNA() {
                time += 0.016;
                grp.rotation.y = time*0.1;
                
                // Pulse animation
                helixPoints1.forEach((p, i) => {
                    p.scale.setScalar(1 + Math.sin(time*2 + i*0.2)*0.2);
                });
                helixPoints2.forEach((p, i) => {
                    p.scale.setScalar(1 + Math.sin(time*2 + i*0.2 + Math.PI)*0.2);
                });
                
                // Bio-photon emission
                photonBases.forEach((b, i) => {
                    const angle = time*b.speed + b.offset;
                    const r = 1.5 + Math.sin(time*2+b.offset)*0.3;
                    photonPos[i*3] = Math.cos(angle)*r;
                    photonPos[i*3+1] = b.y;
                    photonPos[i*3+2] = Math.sin(angle)*r;
                });
                photonGeo.attributes.position.needsUpdate = true;
                requestAnimationFrame(animateDNA);
            }
            animateDNA();
        }

        // Learning Game
        function loadGame(chapterIndex) {
            const chapterId = CHAPTERS[chapterIndex].id;
            if (!QUIZZES[chapterId]) {
                document.getElementById('game-overlay').classList.remove('active');
                return;
            }
            getQuizProgress(chapterId);
            updateQuizProgressUI(chapterId);
            activeQuizQuestion = null;
            awaitingNextQuestion = false;
            const skipBtn = document.getElementById('skip-btn');
            const text = getQuizTextPack();
            if (skipBtn && text) {
                skipBtn.textContent = text.skipLabel;
            }
        }

        function getQuizProgress(chapterId) {
            if (!quizProgress[chapterId]) {
                quizProgress[chapterId] = { coreIndex: 0, extraIndex: 0, completedCore: false };
            }
            return quizProgress[chapterId];
        }

        function getQuizTextPack() {
            return QUIZ_TEXT[currentLanguage] || QUIZ_TEXT.de;
        }

        function resolveNextQuestion(chapterId) {
            const quiz = QUIZZES[chapterId];
            if (!quiz) return null;
            const progress = getQuizProgress(chapterId);
            const pool = progress.completedCore ? 'extra' : 'core';
            const list = quiz[pool];
            if (!list || list.length === 0) {
                if (pool === 'core') {
                    progress.completedCore = true;
                    return resolveNextQuestion(chapterId);
                }
                return null;
            }
            const indexKey = pool === 'core' ? 'coreIndex' : 'extraIndex';
            const idx = progress[indexKey] || 0;
            if (idx >= list.length) {
                if (pool === 'core') {
                    progress.completedCore = true;
                    return resolveNextQuestion(chapterId);
                }
                return null;
            }
            return {
                chapterId,
                pool,
                indexKey,
                list,
                question: list[idx]
            };
        }

        function getLocalizedQuestionText(question) {
            const lang = currentLanguage === 'en' ? 'en' : 'de';
            return question.question[lang] || question.question.de;
        }

        function getLocalizedOptions(question) {
            const lang = currentLanguage === 'en' ? 'en' : 'de';
            return question.options[lang] || question.options.de || [];
        }

        function getLocalizedExplanation(question) {
            const lang = currentLanguage === 'en' ? 'en' : 'de';
            return question.explanation[lang] || question.explanation.de;
        }

        function showGameQuestion() {
            const overlay = document.getElementById('game-overlay');
            if (!overlay || !overlay.classList.contains('active')) return;
            const chapterId = CHAPTERS[currentChapter].id;
            const quiz = QUIZZES[chapterId];
            if (!quiz) {
                renderQuizCompleteMessage('quizComplete');
                return;
            }
            const next = resolveNextQuestion(chapterId);
            if (!next) {
                const progress = getQuizProgress(chapterId);
                updateQuizProgressUI(chapterId);
                renderQuizCompleteMessage(progress.completedCore ? 'quizAllComplete' : 'quizCoreComplete');
                awaitingNextQuestion = false;
                activeQuizQuestion = null;
                return;
            }

            activeQuizQuestion = next;
            awaitingNextQuestion = false;

            const questionText = getLocalizedQuestionText(next.question);
            const options = getLocalizedOptions(next.question);

            const questionEl = document.getElementById('game-question');
            const optionsDiv = document.getElementById('game-options');
            const feedback = document.getElementById('game-feedback');
            if (questionEl) questionEl.textContent = questionText;
            if (optionsDiv) {
                optionsDiv.innerHTML = '';
                options.forEach((option, index) => {
                    const btn = document.createElement('div');
                    btn.className = 'game-option';
                    btn.textContent = option;
                    btn.onclick = () => handleAnswer(index);
                    optionsDiv.appendChild(btn);
                });
            }
            if (feedback) {
                feedback.classList.remove('show', 'correct', 'incorrect');
                feedback.innerHTML = '';
            }
            updateQuizProgressUI(chapterId);
        }

        function handleAnswer(selectedIndex) {
            if (!activeQuizQuestion || awaitingNextQuestion) return;
            const { chapterId, pool, indexKey, list, question } = activeQuizQuestion;
            const progress = getQuizProgress(chapterId);
            const correctIndex = question.correct;
            disableQuizOptions(selectedIndex, correctIndex);
            const isCorrect = selectedIndex === correctIndex;
            if (isCorrect) {
                progress[indexKey] = Math.min(list.length, (progress[indexKey] || 0) + 1);
                if (pool === 'core' && progress[indexKey] >= list.length) {
                    progress.completedCore = true;
                }
            }
            awaitingNextQuestion = true;
            showQuizFeedback(question, isCorrect, false);
            updateQuizProgressUI(chapterId);
            checkAndUnlockNext(chapterId);
        }

        function disableQuizOptions(selected, correct) {
            document.querySelectorAll('.game-option').forEach((opt, idx) => {
                opt.onclick = null;
                opt.classList.remove('correct', 'incorrect');
                if (idx === correct) {
                    opt.classList.add('correct');
                } else if (selected !== null && idx === selected && selected !== correct) {
                    opt.classList.add('incorrect');
                }
            });
        }

        function showQuizFeedback(question, isCorrect, skipped) {
            const feedback = document.getElementById('game-feedback');
            if (!feedback) return;
            const explanation = getLocalizedExplanation(question);
            const text = getQuizTextPack();
            const stateClass = isCorrect ? 'correct' : 'incorrect';
            feedback.classList.remove('correct', 'incorrect', 'show');
            const sourceLink = buildSourceLink(question.source);
            const baseText = skipped ? `${text.skipPenalty} ${explanation}` : explanation;
            feedback.innerHTML = sourceLink ? `${baseText}<div class="source-link">${sourceLink}</div>` : baseText;
            feedback.classList.add('show', stateClass);
        }

        function buildSourceLink(sourceIdx) {
            if (typeof sourceIdx !== 'number') return '';
            const url = SOURCES[sourceIdx];
            if (!url) return '';
            const label = getQuizTextPack().sourceLink;
            return `<a href="${url}" target="_blank" rel="noopener noreferrer">${label}</a>`;
        }

        function toggleGame() {
            const overlay = document.getElementById('game-overlay');
            overlay.classList.toggle('active');
            if (overlay.classList.contains('active')) {
                showGameQuestion();
            }
        }

        function nextGameQuestion() {
            if (!awaitingNextQuestion) {
                if (!activeQuizQuestion) {
                    showGameQuestion();
                    return;
                }
                showToast(getQuizTextPack().skipBlocked);
                return;
            }
            awaitingNextQuestion = false;
            activeQuizQuestion = null;
            showGameQuestion();
        }

        function skipCurrentQuestion() {
            if (!activeQuizQuestion || awaitingNextQuestion) {
                showToast(getQuizTextPack().skipBlocked);
                return;
            }
            if (!confirm(getQuizTextPack().skipConfirm)) return;
            const { chapterId, indexKey, list } = activeQuizQuestion;
            const progress = getQuizProgress(chapterId);
            progress[indexKey] = Math.min(list.length, (progress[indexKey] || 0) + 1);
            disableQuizOptions(null, activeQuizQuestion.question.correct);
            awaitingNextQuestion = true;
            showQuizFeedback(activeQuizQuestion.question, false, true);
            updateQuizProgressUI(chapterId);
            checkAndUnlockNext(chapterId);
        }

        function updateQuizProgressUI(chapterId) {
            const progressEl = document.getElementById('game-progress');
            const quiz = QUIZZES[chapterId];
            if (!progressEl || !quiz) return;
            const progress = getQuizProgress(chapterId);
            const text = getQuizTextPack();
            const coreTotal = quiz.core.length;
            const extraTotal = quiz.extra.length;
            const corePart = `${text.coreLabel}: ${Math.min(progress.coreIndex, coreTotal)}/${coreTotal}`;
            const extraPart = extraTotal > 0 ? ` ‚Ä¢ ${text.extraLabel}: ${Math.min(progress.extraIndex, extraTotal)}/${extraTotal}` : '';
            progressEl.textContent = corePart + extraPart;
        }

        function renderQuizCompleteMessage(messageKey) {
            const text = getQuizTextPack();
            const message = text[messageKey] || text.quizComplete;
            const questionEl = document.getElementById('game-question');
            const optionsDiv = document.getElementById('game-options');
            const feedback = document.getElementById('game-feedback');
            if (questionEl) questionEl.textContent = message;
            if (optionsDiv) optionsDiv.innerHTML = '';
            if (feedback) {
                feedback.classList.remove('correct', 'incorrect');
                feedback.classList.remove('show');
                feedback.innerHTML = '';
            }
        }

        // === NEW ENHANCEMENT FUNCTIONS ===
        
        function markChapterVisited(chapterIndex) {
            if (!visitedChapters.includes(chapterIndex)) {
                visitedChapters.push(chapterIndex);
                saveProgress();
                updateProgressStats();
                const msg = currentLanguage === 'en'
                    ? `Chapter ${chapterIndex + 1} completed! (${visitedChapters.length}/15)`
                    : `Kapitel ${chapterIndex + 1} abgeschlossen! (${visitedChapters.length}/15)`;
                showToast(msg);
            }
        }
        
        function updateProgressStats() {
            const visited = visitedChapters.length;
            const total = CHAPTERS.length;
            const percent = Math.round((visited / total) * 100);
            
            // Update stats
            const statChapters = document.getElementById('stat-chapters');
            const statProgress = document.getElementById('stat-progress');
            const progressBar = document.getElementById('chapter-progress-bar');
            
            if (statChapters) statChapters.textContent = visited;
            if (statProgress) statProgress.textContent = percent + '%';
            if (progressBar) progressBar.style.width = percent + '%';
            
            refreshChapterCards();
        }
        
        // Toast notification
        function showToast(message, duration = 3000) {
            const toast = document.getElementById('toast');
            if (!toast) return;
            toast.textContent = message;
            toast.classList.add('show');
            setTimeout(() => toast.classList.remove('show'), duration);
        }
        
        // Scroll to top
        function scrollToTop() {
            window.scrollTo({ top: 0, behavior: 'smooth' });
        }
        
        // Scroll-to-top button visibility
        function updateScrollTopButton() {
            const btn = document.getElementById('scroll-top');
            if (!btn) return;
            if (window.scrollY > 500) {
                btn.classList.add('visible');
            } else {
                btn.classList.remove('visible');
            }
        }
        
        // Keyboard shortcuts
        function initKeyboardShortcuts() {
            document.addEventListener('keydown', (e) => {
                // Don't trigger if typing in input
                if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
                
                const sceneContainer = document.getElementById('scene-container');
                const isInScene = sceneContainer && sceneContainer.classList.contains('active');
                
                switch(e.key) {
                    case 'ArrowRight':
                        if (isInScene) { nextChapter(); e.preventDefault(); }
                        break;
                    case 'ArrowLeft':
                        if (isInScene) { prevChapter(); e.preventDefault(); }
                        break;
                    case 'Escape':
                        if (isInScene) { exitScene(); e.preventDefault(); }
                        closeModal();
                        break;
                    case '?':
                        showToast('‚Üê ‚Üí Navigation | ESC Zur√ºck | G Spiel | I Info');
                        break;
                    case 'g':
                    case 'G':
                        if (isInScene) { toggleGame(); e.preventDefault(); }
                        break;
                    case 'i':
                    case 'I':
                        if (isInScene) { openInfo(); e.preventDefault(); }
                        break;
                    case 'a':
                    case 'A':
                        openArchive();
                        e.preventDefault();
                        break;
                }
            });
            
            // Show keyboard hints on desktop after 5 seconds
            const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
            if (!isMobile) {
                setTimeout(() => {
                    const hints = document.getElementById('keyboard-hints');
                    if (hints) hints.classList.add('visible');
                    setTimeout(() => hints?.classList.remove('visible'), 8000);
                }, 5000);
            }
        }
        
        // Initialize scroll listener
        window.addEventListener('scroll', updateScrollTopButton);
        
        // Initialize keyboard shortcuts
        initKeyboardShortcuts();

        // Profile panel init
        function initProfilePanel() {
            const nameInput = document.getElementById('profile-name');
            const seedInput = document.getElementById('profile-seed');
            const applyBtn = document.getElementById('profile-apply');
            const resetBtn = document.getElementById('profile-reset');
            if (!applyBtn || !resetBtn) return;

            applyBtn.onclick = () => {
                const name = (nameInput?.value || '').trim();
                const seed = (seedInput?.value || '').trim();
                if (!name) {
                    showToast(currentLanguage === 'en' ? 'Enter a name.' : 'Gib einen Namen ein.');
                    return;
                }
                currentProfile.name = name;
                currentProfile.seed = seed;
                const numericSeed = hashString(name + '::' + seed);
                initializeQuizData(numericSeed);
                const loaded = loadProgress();
                if (!loaded) {
                    initUnlocks();
                }
                refreshChapterCards();
                updateProgressStats();
                showToast(currentLanguage === 'en' ? `Profile "${name}" activated.` : `Profil "${name}" aktiviert.`);
            };

            resetBtn.onclick = () => {
                if (!confirm(currentLanguage === 'en' ? 'Reset all progress for this profile?' : 'Gesamten Fortschritt f√ºr dieses Profil zur√ºcksetzen?')) return;
                resetProgress();
                initializeQuizData();
                refreshChapterCards();
                updateProgressStats();
                showToast(currentLanguage === 'en' ? 'Progress reset.' : 'Fortschritt zur√ºckgesetzt.');
            };
        }

        // Utility
        function scrollToDashboard() {
            document.getElementById('dashboard').scrollIntoView({ behavior: 'smooth' });
        }

        // --- MODAL FUNCTIONS ---
        function closeModal() {
            document.querySelectorAll('.modal-overlay').forEach(m => m.classList.remove('active'));
        }

        function openArchive() {
            buildArchiveList();
            document.getElementById('archive-modal').classList.add('active');
        }

        function openInfo() {
            const ch = CHAPTERS[currentChapter];
            document.getElementById('info-title').innerText = ch.title;
            document.getElementById('info-desc').innerText = ch.desc;
            
            const ul = document.getElementById('info-sources');
            ul.innerHTML = '';
            
            if (ch.src && ch.src.length > 0) {
                ch.src.forEach(idx => {
                    if (SOURCES[idx]) {
                        const url = SOURCES[idx];
                        const title = getSourceTitle(url);
                        const archiveUrl = getArchiveUrl(url);
                        
                        // Badge for archive status
                        let badge = '';
                        if (offlineMode) {
                            if (url.includes('youtube.com') || url.includes('researchgate.net') || url.includes('pubmed.ncbi.nlm.nih.gov')) {
                                badge = '<span class="archive-badge" style="background: #ff3366;">LIVE</span>';
                            } else {
                                badge = '<span class="archive-badge">ARCHIVE</span>';
                            }
                        }
                        
                        ul.innerHTML += `<li><a href="${archiveUrl}" target="_blank">${title}</a>${badge}</li>`;
                    }
                });
            } else {
                ul.innerHTML = '<li style="color:#666;">Keine Quellen f√ºr dieses Kapitel verf√ºgbar</li>';
            }
            
            document.getElementById('info-modal').classList.add('active');
        }

        function openExplanation() {
            document.getElementById('explanation-modal').classList.add('active');
        }

        function toggleOfflineMode(enabled) {
            offlineMode = enabled;
            buildArchiveList();
        }

        function getArchiveUrl(url) {
            if (!offlineMode) return url;
            // Some sites don't work well with archive.org
            if (url.includes('youtube.com') || url.includes('researchgate.net') || url.includes('pubmed.ncbi.nlm.nih.gov')) {
                return url;
            }
            return 'https://web.archive.org/web/' + url;
        }

        function getSourceTitle(url) {
            for (const [pattern, title] of Object.entries(SOURCE_TITLES)) {
                if (url.includes(pattern)) return title;
            }
            try {
                const domain = new URL(url).hostname.replace('www.', '');
                return domain.charAt(0).toUpperCase() + domain.slice(1);
            } catch (e) {
                return url.substring(0, 50) + '...';
            }
        }

        function buildArchiveList() {
            const ul = document.getElementById('archive-list');
            if (!ul) return;
            ul.innerHTML = '';
            
            SOURCES.forEach((url, i) => {
                const title = getSourceTitle(url);
                const archiveUrl = getArchiveUrl(url);
                
                // Determine if archive works for this URL
                let badge = '';
                if (offlineMode) {
                    const noArchive = url.includes('youtube.com') || url.includes('researchgate.net') || url.includes('pubmed.ncbi.nlm.nih.gov');
                    badge = noArchive 
                        ? '<span class="archive-badge" style="background: #ff3366;">LIVE</span>'
                        : '<span class="archive-badge">ARCHIVE</span>';
                }
                
                const li = document.createElement('li');
                li.innerHTML = `<a href="${archiveUrl}" target="_blank">${title}</a>${badge}`;
                ul.appendChild(li);
            });
        }

        // --- GEMATRIA SCANNER ---
        function scanGematria(input) {
            const result = document.getElementById('scanner-result');
            if (!result) return;
            
            if (!input || input.trim() === '') {
                result.textContent = '';
                return;
            }
            
            const text = input.toUpperCase().replace(/[^A-Z]/g, '');
            if (text.length === 0) {
                result.textContent = 'Nur Buchstaben eingeben';
                return;
            }
            
            let sum = 0;
            let breakdown = [];
            
            for (const char of text) {
                const val = CHAR_VALS[char] || 0;
                if (val > 0) {
                    sum += val;
                    breakdown.push(`${char}=${val}`);
                }
            }
            
            // Calculate digital root (quersumme)
            let digitalRoot = sum;
            while (digitalRoot > 9) {
                digitalRoot = String(digitalRoot).split('').reduce((a, b) => a + parseInt(b), 0);
            }
            
            const labelSum = currentLanguage === 'en' ? 'Sum' : 'Summe';
            const labelRoot = currentLanguage === 'en' ? 'Root' : 'Wurzel';
            
            result.innerHTML = `<strong>${input.toUpperCase()}</strong> ‚Üí ${labelSum}: <span style="color: var(--gnosis)">${sum}</span> | ${labelRoot}: <span style="color: var(--magic)">${digitalRoot}</span>`;
        }

        // Close modal on click outside or Escape key
        document.addEventListener('click', function(e) {
            if (e.target.classList.contains('modal-overlay')) {
                closeModal();
            }
        });
        
        document.addEventListener('keydown', function(e) {
            if (e.key === 'Escape') {
                closeModal();
            }
        });
    </script>
</body>
</html>